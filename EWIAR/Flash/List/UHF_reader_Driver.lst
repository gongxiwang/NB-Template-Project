###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        12/Jul/2019  09:14:41
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\USER\BSP\UHF_reader_Driver.c
#    Command line =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\USER\BSP\UHF_reader_Driver.c
#        -D LORA_MODULE -lCN
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\List\ -o
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\Softwares\IAR7.40\arm\INC\c\DLib_Config_Full.h -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\CPU\inc\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-CPU\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-CPU\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-LIB\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-OSII\Ports\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-OSII\Source\
#        -I E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\USER\BSP\
#        -I E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\USER\APP\
#        -Om --use_c++_inline
#    List file    =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\List\UHF_reader_Driver.lst
#    Object file  =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\Obj\UHF_reader_Driver.o
#
###############################################################################

E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\USER\BSP\UHF_reader_Driver.c
      1          /** Copyright(c) 2015, XunFang Tech Limited. All rights reserved.
      2            * @file		UHF_reader_Driver.c
      3            * @author		qyz
      4            * @version	V1.0.0
      5            * @date		07/21/2015
      6            * @brief		UHF_Reader函数
      7            */
      8          /**
      9            * @brief Multi-Include-Prevent Section
     10            */
     11          /**
     12            * @brief Include File Section
     13            * @brief 包含头文件
     14            */
     15          #include "UHF_Reader_Driver.h"
     16          #include "bsp.h"
     17          #include "stdio.h"
     18          #include "string.h"
     19          #include "App_RF900M.h"
     20          #include "bsp_uart.h"
     21          #include "bsp_dma.h"
     22          #include "app_uart.h"
     23          
     24          
     25          /**
     26            * @brief  check_sum 
     27           */

   \                                 In section .text, align 2, keep-with-next
     28          static u8 check_sum(const u8 *pbuffer, u8 size)
     29          {
   \                     check_sum: (+1)
   \   00000000   0xB410             PUSH     {R4}
     30              u8 sum = 0;
   \   00000002   0x2200             MOVS     R2,#+0
     31              for(u8 i = 0; i < size; ++i)
   \   00000004   0x4613             MOV      R3,R2
   \   00000006   0xE004             B.N      ??check_sum_0
     32              {
     33                  sum += *pbuffer++;
   \                     ??check_sum_1: (+1)
   \   00000008   0xF810 0x4B01      LDRB     R4,[R0], #+1
   \   0000000C   0x18A2             ADDS     R2,R4,R2
   \   0000000E   0xB2D2             UXTB     R2,R2
     34              }
   \   00000010   0x1C5B             ADDS     R3,R3,#+1
   \                     ??check_sum_0: (+1)
   \   00000012   0xB2DB             UXTB     R3,R3
   \   00000014   0x428B             CMP      R3,R1
   \   00000016   0xD3F7             BCC.N    ??check_sum_1
     35              sum = ~sum + 1;
     36              
     37              return sum;
   \   00000018   0x43D0             MVNS     R0,R2
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0xB2C0             UXTB     R0,R0
   \   0000001E   0xBC10             POP      {R4}
   \   00000020   0x4770             BX       LR               ;; return
     38          }
     39          
     40          /**
     41            * @brief  packet_to_buffer 
     42           */

   \                                 In section .text, align 2, keep-with-next
     43          static u8 packet_to_buffer(const PST_UHF_PACK packet, u8 *pbuffer)
     44          {
   \                     packet_to_buffer: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
     45              u8 *p = pbuffer;
     46              
     47              *p = 0xA0;
   \   00000006   0x20A0             MOVS     R0,#+160
   \   00000008   0x7020             STRB     R0,[R4, #+0]
     48              p++;
     49              
     50              *p = packet->data_size + 3;
   \   0000000A   0x78A8             LDRB     R0,[R5, #+2]
   \   0000000C   0x1CC0             ADDS     R0,R0,#+3
   \   0000000E   0x7060             STRB     R0,[R4, #+1]
     51              p++;
     52              
     53              *p = packet->address;
   \   00000010   0x7828             LDRB     R0,[R5, #+0]
   \   00000012   0x70A0             STRB     R0,[R4, #+2]
     54              p++;
     55              
     56              *p = packet->cmd;
   \   00000014   0x7868             LDRB     R0,[R5, #+1]
   \   00000016   0x70E0             STRB     R0,[R4, #+3]
     57              p++;
   \   00000018   0x1D26             ADDS     R6,R4,#+4
     58              
     59              if(packet->data_size)
   \   0000001A   0x78AA             LDRB     R2,[R5, #+2]
   \   0000001C   0x2A00             CMP      R2,#+0
   \   0000001E   0xD005             BEQ.N    ??packet_to_buffer_0
     60              {
     61                  memcpy(p, packet->data, packet->data_size);
   \   00000020   0x1CE9             ADDS     R1,R5,#+3
   \   00000022   0x4630             MOV      R0,R6
   \   00000024   0x.... 0x....      BL       __aeabi_memcpy
     62                  p += packet->data_size;
   \   00000028   0x78A8             LDRB     R0,[R5, #+2]
   \   0000002A   0x1986             ADDS     R6,R0,R6
     63              }
     64              
     65              *p = check_sum(pbuffer, p - pbuffer);
   \                     ??packet_to_buffer_0: (+1)
   \   0000002C   0x4625             MOV      R5,R4
   \   0000002E   0x1B71             SUBS     R1,R6,R5
   \   00000030   0xB2C9             UXTB     R1,R1
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       check_sum
   \   00000038   0xF806 0x0B01      STRB     R0,[R6], #+1
     66              p++;
     67              
     68              return (p - pbuffer);
   \   0000003C   0x1B70             SUBS     R0,R6,R5
   \   0000003E   0xB2C0             UXTB     R0,R0
   \   00000040   0xBD70             POP      {R4-R6,PC}       ;; return
     69          }
     70          
     71          /**
     72            * @brief  buffer_to_packet 
     73           */

   \                                 In section .text, align 2, keep-with-next
     74          static u8 buffer_to_packet(const u8 *pbuffer, PST_UHF_PACK packet)
     75          {
   \                     buffer_to_packet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
     76              const u8 *p = pbuffer;
     77              u8 len;
     78              u8 sum;
     79              
     80              if(*p != 0xA0)
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x28A0             CMP      R0,#+160
   \   0000000A   0xD001             BEQ.N    ??buffer_to_packet_0
     81                  return 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBDF2             POP      {R1,R4-R7,PC}
     82              p++;
     83              
     84              len = *p++;
   \                     ??buffer_to_packet_0: (+1)
   \   00000010   0x7866             LDRB     R6,[R4, #+1]
     85              packet->data_size = len - 3;
   \   00000012   0x4630             MOV      R0,R6
   \   00000014   0x1EC0             SUBS     R0,R0,#+3
   \   00000016   0x70A8             STRB     R0,[R5, #+2]
     86              
     87              if(len < 3)
   \   00000018   0x2E03             CMP      R6,#+3
   \   0000001A   0xDA01             BGE.N    ??buffer_to_packet_1
     88                  return 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBDF2             POP      {R1,R4-R7,PC}
     89              
     90              packet->address = *p++;
   \                     ??buffer_to_packet_1: (+1)
   \   00000020   0x78A0             LDRB     R0,[R4, #+2]
   \   00000022   0x7028             STRB     R0,[R5, #+0]
     91              packet->cmd = (EN_UHF_CMD)*p++;
   \   00000024   0x78E0             LDRB     R0,[R4, #+3]
   \   00000026   0x7068             STRB     R0,[R5, #+1]
   \   00000028   0x1D27             ADDS     R7,R4,#+4
     92              
     93              if(packet->data_size)
   \   0000002A   0x78AA             LDRB     R2,[R5, #+2]
   \   0000002C   0x2A00             CMP      R2,#+0
   \   0000002E   0xD005             BEQ.N    ??buffer_to_packet_2
     94              {
     95                  memcpy(packet->data, p, packet->data_size);
   \   00000030   0x4639             MOV      R1,R7
   \   00000032   0x1CE8             ADDS     R0,R5,#+3
   \   00000034   0x.... 0x....      BL       __aeabi_memcpy
     96                  p += packet->data_size;
   \   00000038   0x78A8             LDRB     R0,[R5, #+2]
   \   0000003A   0x19C7             ADDS     R7,R0,R7
     97              }
     98              
     99              sum = check_sum(pbuffer, len + 1);
   \                     ??buffer_to_packet_2: (+1)
   \   0000003C   0x1C71             ADDS     R1,R6,#+1
   \   0000003E   0xB2C9             UXTB     R1,R1
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       check_sum
    100              
    101              if(sum != *p)
   \   00000046   0x7839             LDRB     R1,[R7, #+0]
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0xD001             BEQ.N    ??buffer_to_packet_3
    102                  return 0;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xBDF2             POP      {R1,R4-R7,PC}
    103              
    104              p++;
    105              
    106              return (p - pbuffer);    
   \                     ??buffer_to_packet_3: (+1)
   \   00000050   0x1C78             ADDS     R0,R7,#+1
   \   00000052   0x1B00             SUBS     R0,R0,R4
   \   00000054   0xB2C0             UXTB     R0,R0
   \   00000056   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    107          }
    108          
    109          /**
    110            * @brief  UHF_Tx_PACK 
    111           */

   \                                 In section .text, align 2, keep-with-next
    112          EN_UHF_STATUS UHF_Tx_PACK(PST_UHF_Device pst_UHF_device, const u8 *pdata, u8 data_size)
    113          {
   \                     UHF_Tx_PACK: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB0C1             SUB      SP,SP,#+260
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4614             MOV      R4,R2
    114          	u8 tx_buffer[UHF_TX_BUFFER_MAX_SIZE] = {0};
   \   0000000A   0xA800             ADD      R0,SP,#+0
   \   0000000C   0xF44F 0x7180      MOV      R1,#+256
   \   00000010   0x.... 0x....      BL       __aeabi_memclr4
    115          	u8 tx_valid_size;
    116          	u8 ret = UHF_STATUS_FAIL;
   \   00000014   0x2711             MOVS     R7,#+17
    117          
    118          	pst_UHF_device->st_UHF_pack.address = pst_UHF_device->address;
   \   00000016   0xF105 0x0023      ADD      R0,R5,#+35
   \   0000001A   0xF205 0x1125      ADDW     R1,R5,#+293
   \   0000001E   0x780A             LDRB     R2,[R1, #+0]
   \   00000020   0x7002             STRB     R2,[R0, #+0]
    119          	pst_UHF_device->st_UHF_pack.cmd = pst_UHF_device->cmd;
   \   00000022   0x7849             LDRB     R1,[R1, #+1]
   \   00000024   0x7041             STRB     R1,[R0, #+1]
    120          	pst_UHF_device->st_UHF_pack.data_size = data_size;
   \   00000026   0x7084             STRB     R4,[R0, #+2]
    121          	
    122          	for(u8 i = 0; i < data_size; ++ i)
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xE005             B.N      ??UHF_Tx_PACK_0
    123          	{
    124          		pst_UHF_device->st_UHF_pack.data[i] = pdata[i];							/* 数据包数据赋值 */
   \                     ??UHF_Tx_PACK_1: (+1)
   \   0000002C   0x5D8A             LDRB     R2,[R1, R6]
   \   0000002E   0x194B             ADDS     R3,R1,R5
   \   00000030   0xF883 0x2026      STRB     R2,[R3, #+38]
    125          	}
   \   00000034   0x1C49             ADDS     R1,R1,#+1
   \   00000036   0xB2C9             UXTB     R1,R1
   \                     ??UHF_Tx_PACK_0: (+1)
   \   00000038   0x42A1             CMP      R1,R4
   \   0000003A   0xDBF7             BLT.N    ??UHF_Tx_PACK_1
    126          	tx_valid_size = packet_to_buffer(&pst_UHF_device->st_UHF_pack, tx_buffer);	/* 数据包转换成数组 */
   \   0000003C   0xA900             ADD      R1,SP,#+0
   \   0000003E   0x.... 0x....      BL       packet_to_buffer
   \   00000042   0x0004             MOVS     R4,R0
    127          
    128          	if(tx_valid_size > 0)
   \   00000044   0xD016             BEQ.N    ??UHF_Tx_PACK_2
    129          	{
    130          		/*** debug打印发送的UHF900数据 ***/
    131          		debug_printf("\r\nUHF Send Data:");
   \   00000046   0x.... 0x....      ADR.W    R0,?_1
   \   0000004A   0x.... 0x....      BL       debug_printf
    132          		for(int i = 0; i < tx_valid_size; i ++)
   \   0000004E   0x2500             MOVS     R5,#+0
   \   00000050   0xE006             B.N      ??UHF_Tx_PACK_3
    133          		{
    134          			debug_printf("%02X ", tx_buffer[i]);
   \                     ??UHF_Tx_PACK_4: (+1)
   \   00000052   0xA800             ADD      R0,SP,#+0
   \   00000054   0x5C29             LDRB     R1,[R5, R0]
   \   00000056   0x.... 0x....      ADR.W    R0,?_2
   \   0000005A   0x.... 0x....      BL       debug_printf
    135          		}
   \   0000005E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??UHF_Tx_PACK_3: (+1)
   \   00000060   0x42A5             CMP      R5,R4
   \   00000062   0xDBF6             BLT.N    ??UHF_Tx_PACK_4
    136          		debug_printf("\r\n");
   \   00000064   0x....             ADR.N    R0,??DataTable22  ;; 0x0D, 0x0A, 0x00, 0x00
   \   00000066   0x.... 0x....      BL       debug_printf
    137          		/********************************/
    138          
    139          		/* 发送到900M设备 */
    140          		USART1DMA_Send_Data(tx_buffer, tx_valid_size);	
   \   0000006A   0x4621             MOV      R1,R4
   \   0000006C   0xA800             ADD      R0,SP,#+0
   \   0000006E   0x.... 0x....      BL       USART1DMA_Send_Data
    141          		ret = UHF_STATUS_SUCCESS;
   \   00000072   0x2710             MOVS     R7,#+16
    142          	}
    143          	return (ret > 0 ? UHF_STATUS_SUCCESS : UHF_STATUS_FAIL);
   \                     ??UHF_Tx_PACK_2: (+1)
   \   00000074   0x2F00             CMP      R7,#+0
   \   00000076   0xD001             BEQ.N    ??UHF_Tx_PACK_5
   \   00000078   0x2010             MOVS     R0,#+16
   \   0000007A   0xE000             B.N      ??UHF_Tx_PACK_6
   \                     ??UHF_Tx_PACK_5: (+1)
   \   0000007C   0x2011             MOVS     R0,#+17
   \                     ??UHF_Tx_PACK_6: (+1)
   \   0000007E   0xB041             ADD      SP,SP,#+260
   \   00000080   0xBDF0             POP      {R4-R7,PC}       ;; return
    144          }
    145          
    146          /**
    147            * @brief		UhfWRdata_list()
    148            * @details	寻标签
    149            * @param 	UHF_Uid 存储区
    150            * @retval 	0 失败 N成功 返回EPC号长度
    151            */

   \                                 In section .text, align 2, keep-with-next
    152          u8 UhfWRdata_list(PST_UHF_Device pst_UHF_Dev)	
    153          {			
   \                     UhfWRdata_list: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    154          	u8 UHF_Repeat = 0x01;					/* 根据协议Repeat字段设置0xFF--盘存少量标签快速 */
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    155          	EN_UHF_STATUS ret = UHF_STATUS_FAIL;
    156          	u32 timecount = pst_UHF_Dev->Timeout;
   \   0000000A   0xF8D4 0x512C      LDR      R5,[R4, #+300]
    157          	/* 发送盘存命令-寻卡-数据长度是0x01 */
    158          	UHF_Tx_PACK(pst_UHF_Dev, &UHF_Repeat, 0x01);
   \   0000000E   0x4602             MOV      R2,R0
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       UHF_Tx_PACK
   \   00000018   0xE005             B.N      ??UhfWRdata_list_0
    159          #if 1
    160          	while(timecount --)						/* 等待寻卡回应 6*800 = 4.8S */
    161          	{
    162          		if(WaitUHFDataReceive(pst_UHF_Dev) == UHF_STATUS_SUCCESS)
    163          		{
    164          			break;
    165          		}
    166          		OSTimeDlyHMSM(0, 0, 0, 1); 
   \                     ??UhfWRdata_list_1: (+1)
   \   0000001A   0x2301             MOVS     R3,#+1
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0x4611             MOV      R1,R2
   \   00000020   0x4608             MOV      R0,R1
   \   00000022   0x.... 0x....      BL       OSTimeDlyHMSM
   \                     ??UhfWRdata_list_0: (+1)
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x1E45             SUBS     R5,R0,#+1
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD004             BEQ.N    ??UhfWRdata_list_2
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       WaitUHFDataReceive
   \   00000034   0x2810             CMP      R0,#+16
   \   00000036   0xD1F0             BNE.N    ??UhfWRdata_list_1
    167          	}
    168          	/* EPC数据赋值 */
    169          	pst_UHF_Dev->st_UHF_epc.epc_length = (pst_UHF_Dev->st_UHF_pack.data[1] >> 3) *2;
   \                     ??UhfWRdata_list_2: (+1)
   \   00000038   0xF104 0x0525      ADD      R5,R4,#+37
   \   0000003C   0x78A8             LDRB     R0,[R5, #+2]
   \   0000003E   0x08C0             LSRS     R0,R0,#+3
   \   00000040   0x0042             LSLS     R2,R0,#+1
   \   00000042   0x7022             STRB     R2,[R4, #+0]
    170          	memcpy(pst_UHF_Dev->st_UHF_epc.epc, &pst_UHF_Dev->st_UHF_pack.data[3], pst_UHF_Dev->st_UHF_epc.epc_length);
   \   00000044   0xF104 0x0129      ADD      R1,R4,#+41
   \   00000048   0x1D60             ADDS     R0,R4,#+5
   \   0000004A   0x.... 0x....      BL       __aeabi_memcpy
    171          	return (pst_UHF_Dev->st_UHF_pack.data_size - 4);		/* 返回EPC数据长度 */
   \   0000004E   0x7828             LDRB     R0,[R5, #+0]
   \   00000050   0x1F00             SUBS     R0,R0,#+4
   \   00000052   0xB2C0             UXTB     R0,R0
   \   00000054   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    172          #endif
    173          }
    174          
    175          /**
    176            * @brief		WaitUHFDataReceive()
    177            * @details	寻标签
    178            * @param 	UHF_Uid 存储区
    179            * @retval 	
    180            */

   \                                 In section .text, align 2, keep-with-next
    181          EN_UHF_STATUS WaitUHFDataReceive(PST_UHF_Device pst_UHF_Dev)
    182          {
   \                     WaitUHFDataReceive: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0C0             SUB      SP,SP,#+256
   \   00000004   0x4604             MOV      R4,R0
    183          	u8 UsartSensorData[256] = {0};							/* 传感器接收串口数据数组 */
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0xF44F 0x7180      MOV      R1,#+256
   \   0000000C   0x.... 0x....      BL       __aeabi_memclr4
    184          	u32 ulReceiveLen = 0;									/* 保存的接收数据长度 */
    185          	ulReceiveLen = Uart1RecvData((u8*)UsartSensorData);		/* 接收串口1传过来的数据 */
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x.... 0x....      BL       Uart1RecvData
   \   00000016   0x0005             MOVS     R5,R0
    186          	if(ulReceiveLen >= 0x01)
   \   00000018   0xD024             BEQ.N    ??WaitUHFDataReceive_0
    187          	{
    188          		/* 打印测试 */
    189          		debug_printf("UHF900M Recv:");
   \   0000001A   0x.... 0x....      ADR.W    R0,?_5
   \   0000001E   0x.... 0x....      BL       debug_printf
    190          		for(int i = 0; i < ulReceiveLen; i ++)
   \   00000022   0x2600             MOVS     R6,#+0
   \   00000024   0xE006             B.N      ??WaitUHFDataReceive_1
    191          		{
    192          			debug_printf("%02X ", UsartSensorData[i]);
   \                     ??WaitUHFDataReceive_2: (+1)
   \   00000026   0xA800             ADD      R0,SP,#+0
   \   00000028   0x5C31             LDRB     R1,[R6, R0]
   \   0000002A   0x.... 0x....      ADR.W    R0,?_2
   \   0000002E   0x.... 0x....      BL       debug_printf
    193          		}
   \   00000032   0x1C76             ADDS     R6,R6,#+1
   \                     ??WaitUHFDataReceive_1: (+1)
   \   00000034   0x42AE             CMP      R6,R5
   \   00000036   0xD3F6             BCC.N    ??WaitUHFDataReceive_2
    194          		debug_printf("\r\n");
   \   00000038   0x....             ADR.N    R0,??DataTable22  ;; 0x0D, 0x0A, 0x00, 0x00
   \   0000003A   0x.... 0x....      BL       debug_printf
    195          		
    196          		/* 只在寻卡、读卡、写卡时对数据分析 */
    197          		if((pst_UHF_Dev->cmd == UHF_CMD_REAL_TIME_INVENTORY) || (pst_UHF_Dev->cmd == UHF_CMD_READ)
    198          			|| (pst_UHF_Dev->cmd == UHF_CMD_WRITE))
   \   0000003E   0xF894 0x0126      LDRB     R0,[R4, #+294]
   \   00000042   0x2889             CMP      R0,#+137
   \   00000044   0xD003             BEQ.N    ??WaitUHFDataReceive_3
   \   00000046   0x2881             CMP      R0,#+129
   \   00000048   0xD001             BEQ.N    ??WaitUHFDataReceive_3
   \   0000004A   0x2882             CMP      R0,#+130
   \   0000004C   0xD108             BNE.N    ??WaitUHFDataReceive_4
    199          		{
    200          			debug_printf("Buffer to Packet Starting ......\r\n");
   \                     ??WaitUHFDataReceive_3: (+1)
   \   0000004E   0x.... 0x....      ADR.W    R0,?_6
   \   00000052   0x.... 0x....      BL       debug_printf
    201          			buffer_to_packet(UsartSensorData, &pst_UHF_Dev->st_UHF_pack);/* 把接收的数组分配给PACK */
   \   00000056   0xF104 0x0123      ADD      R1,R4,#+35
   \   0000005A   0xA800             ADD      R0,SP,#+0
   \   0000005C   0x.... 0x....      BL       buffer_to_packet
    202          		}
    203          		return UHF_STATUS_SUCCESS;
   \                     ??WaitUHFDataReceive_4: (+1)
   \   00000060   0x2010             MOVS     R0,#+16
   \   00000062   0xE000             B.N      ??WaitUHFDataReceive_5
    204          	}
    205          	return 0;
   \                     ??WaitUHFDataReceive_0: (+1)
   \   00000064   0x2000             MOVS     R0,#+0
   \                     ??WaitUHFDataReceive_5: (+1)
   \   00000066   0xB040             ADD      SP,SP,#+256
   \   00000068   0xBD70             POP      {R4-R6,PC}       ;; return
    206          }
    207          
    208          /**
    209            * @brief		UhfWRdata_read()
    210            * @details	选定标签
    211            * @param 	bolck_data	数据存储区
    212            * @retval 	0 失败 1 成功
    213            */

   \                                 In section .text, align 2, keep-with-next
    214          u8 UhfSelect_TAG(Device_packet_t *packet, PST_UHF_Device pst_UHF_Dev)	
    215          {
   \                     UhfSelect_TAG: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB090             SUB      SP,SP,#+64
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x460C             MOV      R4,R1
    216          	u8 UHF_ReadDataRegion[64] = {0x00, 0x0C};
   \   00000008   0xA800             ADD      R0,SP,#+0
   \   0000000A   0x.... 0x....      ADR.W    R1,?_7
   \   0000000E   0x2240             MOVS     R2,#+64
   \   00000010   0x.... 0x....      BL       __aeabi_memcpy4
    217          	u32 timecount = pst_UHF_Dev->Timeout;
   \   00000014   0xF8D4 0x512C      LDR      R5,[R4, #+300]
    218          	pst_UHF_Dev->cmd = UHF_CMD_SET_ACCESS_EPC_MATCH;/* 选定标签命令 */
   \   00000018   0x2085             MOVS     R0,#+133
   \   0000001A   0xF884 0x0126      STRB     R0,[R4, #+294]
    219          	EN_UHF_STATUS ret = UHF_STATUS_FAIL;
    220          	for(int i = 0; i < 12; i ++)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE005             B.N      ??UhfSelect_TAG_0
    221          	{
    222          		UHF_ReadDataRegion[2 + i] = packet->data[i]; /* epc赋值 */
   \                     ??UhfSelect_TAG_1: (+1)
   \   00000022   0x1981             ADDS     R1,R0,R6
   \   00000024   0x7A49             LDRB     R1,[R1, #+9]
   \   00000026   0xAA00             ADD      R2,SP,#+0
   \   00000028   0x1882             ADDS     R2,R0,R2
   \   0000002A   0x7091             STRB     R1,[R2, #+2]
    223          	}
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \                     ??UhfSelect_TAG_0: (+1)
   \   0000002E   0x280C             CMP      R0,#+12
   \   00000030   0xDBF7             BLT.N    ??UhfSelect_TAG_1
    224          	/* 发送盘存命令-寻卡-数据长度 */
    225          	UHF_Tx_PACK(pst_UHF_Dev, UHF_ReadDataRegion, 0x0E);
   \   00000032   0x220E             MOVS     R2,#+14
   \   00000034   0xA900             ADD      R1,SP,#+0
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       UHF_Tx_PACK
    226          #if 1
    227          	debug_printf("Waitting Select Tag Data");
   \   0000003C   0x.... 0x....      ADR.W    R0,?_8
   \   00000040   0x.... 0x....      BL       debug_printf
   \   00000044   0xE005             B.N      ??UhfSelect_TAG_2
    228          	while(timecount --)						/* 等待寻卡回应5S */
    229          	{
    230          		debug_printf("...");
    231          		if(WaitUHFDataReceive(pst_UHF_Dev) == UHF_STATUS_SUCCESS)
    232          		{
    233          			debug_printf("\r\n");/* 打印换行 */
    234          			break;
    235          		}
    236          		OSTimeDlyHMSM(0, 0, 0, 1); 
   \                     ??UhfSelect_TAG_3: (+1)
   \   00000046   0x2301             MOVS     R3,#+1
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0x4611             MOV      R1,R2
   \   0000004C   0x4608             MOV      R0,R1
   \   0000004E   0x.... 0x....      BL       OSTimeDlyHMSM
   \                     ??UhfSelect_TAG_2: (+1)
   \   00000052   0x4628             MOV      R0,R5
   \   00000054   0x1E45             SUBS     R5,R0,#+1
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD00A             BEQ.N    ??UhfSelect_TAG_4
   \   0000005A   0x....             ADR.N    R0,??DataTable22_1  ;; "..."
   \   0000005C   0x.... 0x....      BL       debug_printf
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       WaitUHFDataReceive
   \   00000066   0x2810             CMP      R0,#+16
   \   00000068   0xD1ED             BNE.N    ??UhfSelect_TAG_3
   \   0000006A   0x....             ADR.N    R0,??DataTable22  ;; 0x0D, 0x0A, 0x00, 0x00
   \   0000006C   0x.... 0x....      BL       debug_printf
    237          	}
    238          	debug_printf("\r\n");	/* 打印换行 */
   \                     ??UhfSelect_TAG_4: (+1)
   \   00000070   0x....             ADR.N    R0,??DataTable22  ;; 0x0D, 0x0A, 0x00, 0x00
   \   00000072   0x.... 0x....      BL       debug_printf
    239          
    240          	if(timecount == 0)		/* 判断是否超时退出 */
   \   00000076   0x2D00             CMP      R5,#+0
   \   00000078   0xD101             BNE.N    ??UhfSelect_TAG_5
    241          	{
    242          		return ACK_CARD_HANDLE_ERR;
   \   0000007A   0x2008             MOVS     R0,#+8
   \   0000007C   0xE000             B.N      ??UhfSelect_TAG_6
    243          	}
    244          #endif
    245          
    246          	return 0;					/* 返回读取到的数据长度 */
   \                     ??UhfSelect_TAG_5: (+1)
   \   0000007E   0x2000             MOVS     R0,#+0
   \                     ??UhfSelect_TAG_6: (+1)
   \   00000080   0xB010             ADD      SP,SP,#+64
   \   00000082   0xBD70             POP      {R4-R6,PC}       ;; return
    247          }
    248          
    249          
    250          
    251          /**
    252            * @brief		UhfWRdata_read()
    253            * @details	读标签数据
    254            * @param 	bolck_data	数据存储区
    255            * @retval 	0 失败 1 成功
    256            */

   \                                 In section .text, align 2, keep-with-next
    257          u8 UhfWRdata_read(PST_UHF_Device pst_UHF_Dev, PST_READ_TAG pst_READ_TAG)	
    258          {
   \                     UhfWRdata_read: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
    259          	u8 UHF_ReadDataRegion[3] = {0x03, 0x00, 0x08};
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x.... 0x....      ADR.W    R1,?_10
   \   0000000C   0x680A             LDR      R2,[R1, #0]
   \   0000000E   0x6002             STR      R2,[R0, #+0]
    260          	u32 timecount = pst_UHF_Dev->Timeout;
   \   00000010   0xF8D5 0x612C      LDR      R6,[R5, #+300]
    261          	EN_UHF_STATUS ret = UHF_STATUS_FAIL;
    262          	/* 发送盘存命令-寻卡-数据长度是0x01 */
    263          	UHF_Tx_PACK(pst_UHF_Dev, UHF_ReadDataRegion, 0x03);
   \   00000014   0x2203             MOVS     R2,#+3
   \   00000016   0xA900             ADD      R1,SP,#+0
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x.... 0x....      BL       UHF_Tx_PACK
    264          	debug_printf("Start Recving UHF Data...");
   \   0000001E   0x.... 0x....      ADR.W    R0,?_11
   \   00000022   0x.... 0x....      BL       debug_printf
   \   00000026   0xE005             B.N      ??UhfWRdata_read_0
    265          	while(timecount --)						/* 等待寻卡回应5S */
    266          	{
    267          		debug_printf("...");
    268          		if(WaitUHFDataReceive(pst_UHF_Dev) == UHF_STATUS_SUCCESS)
    269          		{
    270          			debug_printf("\r\n");/* 打印换行 */
    271          			break;
    272          		}
    273          		OSTimeDlyHMSM(0, 0, 0, 1); 
   \                     ??UhfWRdata_read_1: (+1)
   \   00000028   0x2301             MOVS     R3,#+1
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x4611             MOV      R1,R2
   \   0000002E   0x4608             MOV      R0,R1
   \   00000030   0x.... 0x....      BL       OSTimeDlyHMSM
   \                     ??UhfWRdata_read_0: (+1)
   \   00000034   0x4630             MOV      R0,R6
   \   00000036   0x1E46             SUBS     R6,R0,#+1
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD00A             BEQ.N    ??UhfWRdata_read_2
   \   0000003C   0x....             ADR.N    R0,??DataTable22_1  ;; "..."
   \   0000003E   0x.... 0x....      BL       debug_printf
   \   00000042   0x4628             MOV      R0,R5
   \   00000044   0x.... 0x....      BL       WaitUHFDataReceive
   \   00000048   0x2810             CMP      R0,#+16
   \   0000004A   0xD1ED             BNE.N    ??UhfWRdata_read_1
   \   0000004C   0x....             ADR.N    R0,??DataTable22  ;; 0x0D, 0x0A, 0x00, 0x00
   \   0000004E   0x.... 0x....      BL       debug_printf
    274          	}
    275          	debug_printf("\r\n");	/* 打印换行 */
   \                     ??UhfWRdata_read_2: (+1)
   \   00000052   0x....             ADR.N    R0,??DataTable22  ;; 0x0D, 0x0A, 0x00, 0x00
   \   00000054   0x.... 0x....      BL       debug_printf
    276          	if(timecount == 0)		/* 判断是否超时退出 */
   \   00000058   0x2E00             CMP      R6,#+0
   \   0000005A   0xD101             BNE.N    ??UhfWRdata_read_3
    277          	{
    278          		return ACK_CARD_HANDLE_ERR;
   \   0000005C   0x2008             MOVS     R0,#+8
   \   0000005E   0xBDF2             POP      {R1,R4-R7,PC}
    279          	}
    280          	/* 读取到的标签数据赋值*/
    281          	debug_printf("Read Card Data:");
   \                     ??UhfWRdata_read_3: (+1)
   \   00000060   0x.... 0x....      ADR.W    R0,?_12
   \   00000064   0x.... 0x....      BL       debug_printf
    282          	for(int i = 0; i < pst_UHF_Dev->st_UHF_pack.data_size; i ++)
   \   00000068   0x2600             MOVS     R6,#+0
   \   0000006A   0xF105 0x0725      ADD      R7,R5,#+37
   \   0000006E   0xE007             B.N      ??UhfWRdata_read_4
    283          	{
    284          		debug_printf("%02X ", pst_UHF_Dev->st_UHF_pack.data[i]);
   \                     ??UhfWRdata_read_5: (+1)
   \   00000070   0x1970             ADDS     R0,R6,R5
   \   00000072   0xF890 0x1026      LDRB     R1,[R0, #+38]
   \   00000076   0x.... 0x....      ADR.W    R0,?_2
   \   0000007A   0x.... 0x....      BL       debug_printf
    285          	}
   \   0000007E   0x1C76             ADDS     R6,R6,#+1
   \                     ??UhfWRdata_read_4: (+1)
   \   00000080   0x7838             LDRB     R0,[R7, #+0]
   \   00000082   0x4286             CMP      R6,R0
   \   00000084   0xDBF4             BLT.N    ??UhfWRdata_read_5
    286          	debug_printf("\n");
   \   00000086   0x....             ADR.N    R6,??DataTable22_2  ;; "\n"
   \   00000088   0x4630             MOV      R0,R6
   \   0000008A   0x.... 0x....      BL       debug_printf
    287          	pst_READ_TAG->DataLen = (pst_UHF_Dev->st_UHF_pack.data[2] - 0x10);								/* 标签数据长度赋值--PC+EPC+DATA */
   \   0000008E   0x78F8             LDRB     R0,[R7, #+3]
   \   00000090   0xF1A0 0x0210      SUB      R2,R0,#+16
   \   00000094   0x70A2             STRB     R2,[R4, #+2]
    288          	memcpy(pst_READ_TAG->Data, &pst_UHF_Dev->st_UHF_pack.data[19], pst_READ_TAG->DataLen);		/* 标签数据赋值 */
   \   00000096   0xB2D2             UXTB     R2,R2
   \   00000098   0xF105 0x0139      ADD      R1,R5,#+57
   \   0000009C   0x1CE0             ADDS     R0,R4,#+3
   \   0000009E   0x.... 0x....      BL       __aeabi_memcpy
    289          
    290          	/* 读取到的标签数据赋值*/
    291          	debug_printf("ANISIS Card Data:");
   \   000000A2   0x.... 0x....      ADR.W    R0,?_14
   \   000000A6   0x.... 0x....      BL       debug_printf
    292          	for(int i = 0; i < pst_READ_TAG->DataLen; i ++)
   \   000000AA   0x2500             MOVS     R5,#+0
   \   000000AC   0xE006             B.N      ??UhfWRdata_read_6
    293          	{
    294          		debug_printf("%02X ", pst_READ_TAG->Data[i]);
   \                     ??UhfWRdata_read_7: (+1)
   \   000000AE   0x1928             ADDS     R0,R5,R4
   \   000000B0   0x78C1             LDRB     R1,[R0, #+3]
   \   000000B2   0x.... 0x....      ADR.W    R0,?_2
   \   000000B6   0x.... 0x....      BL       debug_printf
    295          	}
   \   000000BA   0x1C6D             ADDS     R5,R5,#+1
   \                     ??UhfWRdata_read_6: (+1)
   \   000000BC   0x78A0             LDRB     R0,[R4, #+2]
   \   000000BE   0x4285             CMP      R5,R0
   \   000000C0   0xDBF5             BLT.N    ??UhfWRdata_read_7
    296          	debug_printf("\n");
   \   000000C2   0x4630             MOV      R0,R6
   \   000000C4   0x.... 0x....      BL       debug_printf
    297          	
    298          	return (pst_READ_TAG->DataLen);					/* 返回读取到的数据长度 */
   \   000000C8   0x78A0             LDRB     R0,[R4, #+2]
   \   000000CA   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    299          }
    300          
    301          /**
    302            * @brief		UhfWRdata_write()
    303            * @details	写标签数据
    304            * @param 	bolck_data	数据存储区
    305            * @retval 	0 失败 1 成功
    306            */

   \                                 In section .text, align 2, keep-with-next
    307          u8 UhfWRdata_write(PST_UHF_Device pst_UHF_Dev, Device_packet_t *packet)	
    308          {
   \                     UhfWRdata_write: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB090             SUB      SP,SP,#+64
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    309          	u8 UHF_WriteData[64] = {0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0X08};
   \   00000008   0xA800             ADD      R0,SP,#+0
   \   0000000A   0x.... 0x....      ADR.W    R1,?_15
   \   0000000E   0x2240             MOVS     R2,#+64
   \   00000010   0x.... 0x....      BL       __aeabi_memcpy4
    310          	memcpy(pst_UHF_Dev->st_UHF_epc.epc, packet->data, 12);/* epc赋值 */
   \   00000014   0x220C             MOVS     R2,#+12
   \   00000016   0xF105 0x0109      ADD      R1,R5,#+9
   \   0000001A   0x1D60             ADDS     R0,R4,#+5
   \   0000001C   0x.... 0x....      BL       __aeabi_memcpy
    311          	debug_printf("Read Write Data:");
   \   00000020   0x.... 0x....      ADR.W    R0,?_16
   \   00000024   0x.... 0x....      BL       debug_printf
    312          	for(int i = 0; i < 16; i ++)						/* 协议规定写入16字节数据 */		
   \   00000028   0x2600             MOVS     R6,#+0
   \   0000002A   0xE00B             B.N      ??UhfWRdata_write_0
    313          	{
    314          		UHF_WriteData[7 + i] = packet->data[12 + i];	/* 赋值想要写入的数据 */
   \                     ??UhfWRdata_write_1: (+1)
   \   0000002C   0x1970             ADDS     R0,R6,R5
   \   0000002E   0x7D40             LDRB     R0,[R0, #+21]
   \   00000030   0xA900             ADD      R1,SP,#+0
   \   00000032   0x1871             ADDS     R1,R6,R1
   \   00000034   0x71C8             STRB     R0,[R1, #+7]
    315          		debug_printf("%02X ", packet->data[12 + i]);
   \   00000036   0x1970             ADDS     R0,R6,R5
   \   00000038   0x7D41             LDRB     R1,[R0, #+21]
   \   0000003A   0x.... 0x....      ADR.W    R0,?_2
   \   0000003E   0x.... 0x....      BL       debug_printf
    316          	}
   \   00000042   0x1C76             ADDS     R6,R6,#+1
   \                     ??UhfWRdata_write_0: (+1)
   \   00000044   0x2E10             CMP      R6,#+16
   \   00000046   0xDBF1             BLT.N    ??UhfWRdata_write_1
    317          	debug_printf("\r\n");
   \   00000048   0x....             ADR.N    R5,??DataTable22  ;; 0x0D, 0x0A, 0x00, 0x00
   \   0000004A   0x4628             MOV      R0,R5
   \   0000004C   0x.... 0x....      BL       debug_printf
    318          	EN_UHF_STATUS ret = UHF_STATUS_FAIL;
    319          	u32 timecount = pst_UHF_Dev->Timeout;
   \   00000050   0xF8D4 0x612C      LDR      R6,[R4, #+300]
    320          	/* 发送盘存命令-写入数据 */
    321          	UHF_Tx_PACK(pst_UHF_Dev, UHF_WriteData, 0x17);
   \   00000054   0x2217             MOVS     R2,#+23
   \   00000056   0xA900             ADD      R1,SP,#+0
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       UHF_Tx_PACK
    322          	debug_printf("Wait Write Card return...");
   \   0000005E   0x.... 0x....      ADR.W    R0,?_17
   \   00000062   0x.... 0x....      BL       debug_printf
   \   00000066   0xE005             B.N      ??UhfWRdata_write_2
    323          	while(timecount --)						/* 等待寻卡回应 6*800 = 4.8S */
    324          	{
    325          		debug_printf("...");
    326          		if(WaitUHFDataReceive(pst_UHF_Dev) == UHF_STATUS_SUCCESS)
    327          		{
    328          			debug_printf("\r\n");/* 打印换行 */
    329          			break;
    330          		}
    331          		OSTimeDlyHMSM(0, 0, 0, 1); 
   \                     ??UhfWRdata_write_3: (+1)
   \   00000068   0x2301             MOVS     R3,#+1
   \   0000006A   0x2200             MOVS     R2,#+0
   \   0000006C   0x4611             MOV      R1,R2
   \   0000006E   0x4608             MOV      R0,R1
   \   00000070   0x.... 0x....      BL       OSTimeDlyHMSM
   \                     ??UhfWRdata_write_2: (+1)
   \   00000074   0x4630             MOV      R0,R6
   \   00000076   0x1E46             SUBS     R6,R0,#+1
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD00A             BEQ.N    ??UhfWRdata_write_4
   \   0000007C   0x....             ADR.N    R0,??DataTable22_1  ;; "..."
   \   0000007E   0x.... 0x....      BL       debug_printf
   \   00000082   0x4620             MOV      R0,R4
   \   00000084   0x.... 0x....      BL       WaitUHFDataReceive
   \   00000088   0x2810             CMP      R0,#+16
   \   0000008A   0xD1ED             BNE.N    ??UhfWRdata_write_3
   \   0000008C   0x4628             MOV      R0,R5
   \   0000008E   0x.... 0x....      BL       debug_printf
    332          	}
    333          	debug_printf("\r\n");
   \                     ??UhfWRdata_write_4: (+1)
   \   00000092   0x4628             MOV      R0,R5
   \   00000094   0x.... 0x....      BL       debug_printf
    334          	if(timecount == 0)		/* 判断是否超时退出 */
   \   00000098   0x2E00             CMP      R6,#+0
   \   0000009A   0xD101             BNE.N    ??UhfWRdata_write_5
    335          	{
    336          		return ACK_CARD_HANDLE_ERR;
   \   0000009C   0x2008             MOVS     R0,#+8
   \   0000009E   0xE000             B.N      ??UhfWRdata_write_6
    337          	}
    338          
    339          	return pst_UHF_Dev->st_UHF_epc.epc_length;
   \                     ??UhfWRdata_write_5: (+1)
   \   000000A0   0x7820             LDRB     R0,[R4, #+0]
   \                     ??UhfWRdata_write_6: (+1)
   \   000000A2   0xB010             ADD      SP,SP,#+64
   \   000000A4   0xBD70             POP      {R4-R6,PC}       ;; return
    340          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0x0D 0x0A          DC8      0x0D, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0x2E 0x2E          DC8      "..."
   \              0x2E 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x0D 0x0A          DC8 "\015\012UHF Send Data:"
   \              0x55 0x48    
   \              0x46 0x20    
   \              0x53 0x65    
   \              0x6E 0x64    
   \              0x20 0x44    
   \              0x61 0x74    
   \              0x61 0x3A    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x25 0x30          DC8 "%02X "
   \              0x32 0x58    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x55 0x48          DC8 "UHF900M Recv:"
   \              0x46 0x39    
   \              0x30 0x30    
   \              0x4D 0x20    
   \              0x52 0x65    
   \              0x63 0x76    
   \              0x3A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x42 0x75          DC8 "Buffer to Packet Starting ......\015\012"
   \              0x66 0x66    
   \              0x65 0x72    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x50 0x61    
   \              0x63 0x6B    
   \              0x65 0x74    
   \              0x20 0x53    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x2E 0x2E    
   \              0x2E 0x2E    
   \              0x2E 0x2E    
   \              0x0D 0x0A    
   \              0x00         
   \   00000023   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000017   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000002E   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000045   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000005C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000073   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000008A   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000A1   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000B8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000CF   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000E6   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000FD   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x0D 0x0A          DC8 "\015\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000017   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000002E   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000045   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000005C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000073   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000008A   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000A1   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000B8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000CF   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000E6   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000FD   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_9:
   \   00000000   0x2E 0x2E          DC8 "..."
   \              0x2E 0x00    

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_13:
   \   00000000   0x0A 0x00          DC8 "\012"

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x00 0x0C          DC8 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000016   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000002D   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \   00000000   0x57 0x61          DC8 "Waitting Select Tag Data"
   \              0x69 0x74    
   \              0x74 0x69    
   \              0x6E 0x67    
   \              0x20 0x53    
   \              0x65 0x6C    
   \              0x65 0x63    
   \              0x74 0x20    
   \              0x54 0x61    
   \              0x67 0x20    
   \              0x44 0x61    
   \              0x74 0x61    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \   00000000   0x03 0x00          DC8 3, 0, 8, 0
   \              0x08 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_11:
   \   00000000   0x53 0x74          DC8 "Start Recving UHF Data..."
   \              0x61 0x72    
   \              0x74 0x20    
   \              0x52 0x65    
   \              0x63 0x76    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x55 0x48    
   \              0x46 0x20    
   \              0x44 0x61    
   \              0x74 0x61    
   \              0x2E 0x2E    
   \              0x2E 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_12:
   \   00000000   0x52 0x65          DC8 "Read Card Data:"
   \              0x61 0x64    
   \              0x20 0x43    
   \              0x61 0x72    
   \              0x64 0x20    
   \              0x44 0x61    
   \              0x74 0x61    
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_14:
   \   00000000   0x41 0x4E          DC8 "ANISIS Card Data:"
   \              0x49 0x53    
   \              0x49 0x53    
   \              0x20 0x43    
   \              0x61 0x72    
   \              0x64 0x20    
   \              0x44 0x61    
   \              0x74 0x61    
   \              0x3A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_15:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x03 0x00    
   \              0x08 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000017   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000002E   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_16:
   \   00000000   0x52 0x65          DC8 "Read Write Data:"
   \              0x61 0x64    
   \              0x20 0x57    
   \              0x72 0x69    
   \              0x74 0x65    
   \              0x20 0x44    
   \              0x61 0x74    
   \              0x61 0x3A    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_17:
   \   00000000   0x57 0x61          DC8 "Wait Write Card return..."
   \              0x69 0x74    
   \              0x20 0x57    
   \              0x72 0x69    
   \              0x74 0x65    
   \              0x20 0x43    
   \              0x61 0x72    
   \              0x64 0x20    
   \              0x72 0x65    
   \              0x74 0x75    
   \              0x72 0x6E    
   \              0x2E 0x2E    
   \              0x2E 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0
    341          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     280   UHF_Tx_PACK
       280   -> USART1DMA_Send_Data
       280   -> __aeabi_memclr4
       280   -> debug_printf
       280   -> packet_to_buffer
      80   UhfSelect_TAG
        80   -> OSTimeDlyHMSM
        80   -> UHF_Tx_PACK
        80   -> WaitUHFDataReceive
        80   -> __aeabi_memcpy4
        80   -> debug_printf
      16   UhfWRdata_list
        16   -> OSTimeDlyHMSM
        16   -> UHF_Tx_PACK
        16   -> WaitUHFDataReceive
        16   -> __aeabi_memcpy
      24   UhfWRdata_read
        24   -> OSTimeDlyHMSM
        24   -> UHF_Tx_PACK
        24   -> WaitUHFDataReceive
        24   -> __aeabi_memcpy
        24   -> debug_printf
      80   UhfWRdata_write
        80   -> OSTimeDlyHMSM
        80   -> UHF_Tx_PACK
        80   -> WaitUHFDataReceive
        80   -> __aeabi_memcpy
        80   -> __aeabi_memcpy4
        80   -> debug_printf
     272   WaitUHFDataReceive
       272   -> Uart1RecvData
       272   -> __aeabi_memclr4
       272   -> buffer_to_packet
       272   -> debug_printf
      24   buffer_to_packet
        24   -> __aeabi_memcpy
        24   -> check_sum
       4   check_sum
      16   packet_to_buffer
        16   -> __aeabi_memcpy
        16   -> check_sum


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
     256  ?_0
      20  ?_1
       4  ?_10
      28  ?_11
      16  ?_12
       2  ?_13
      20  ?_14
      64  ?_15
      20  ?_16
      28  ?_17
       8  ?_2
       4  ?_3
     256  ?_4
      16  ?_5
      36  ?_6
      64  ?_7
      28  ?_8
       4  ?_9
     130  UHF_Tx_PACK
     132  UhfSelect_TAG
      86  UhfWRdata_list
     204  UhfWRdata_read
     166  UhfWRdata_write
     106  WaitUHFDataReceive
      88  buffer_to_packet
      34  check_sum
      66  packet_to_buffer

 
   522 bytes in section .rodata
 1 376 bytes in section .text
 
 1 376 bytes of CODE  memory
   522 bytes of CONST memory

Errors: none
Warnings: 5
