###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        12/Jul/2019  09:14:41
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\UCOS-II\CPU\src\stm32f10x_gpio.c
#    Command line =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\UCOS-II\CPU\src\stm32f10x_gpio.c
#        -D LORA_MODULE -lCN
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\List\ -o
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\Softwares\IAR7.40\arm\INC\c\DLib_Config_Full.h -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\CPU\inc\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-CPU\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-CPU\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-LIB\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-OSII\Ports\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-OSII\Source\
#        -I E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\USER\BSP\
#        -I E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\USER\APP\
#        -Om --use_c++_inline
#    List file    =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\List\stm32f10x_gpio.lst
#    Object file  =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\Obj\stm32f10x_gpio.o
#
###############################################################################

E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\UCOS-II\CPU\src\stm32f10x_gpio.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : stm32f10x_gpio.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.0
      5          * Date               : 05/23/2008
      6          * Description        : This file provides all the GPIO firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
     15          * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     16          *******************************************************************************/
     17          
     18          /* Includes ------------------------------------------------------------------*/
     19          #include "stm32f10x_gpio.h"
     20          #include "stm32f10x_rcc.h"
     21          
     22          /* Private typedef -----------------------------------------------------------*/
     23          /* Private define ------------------------------------------------------------*/
     24          /* ------------ RCC registers bit address in the alias region ----------- */
     25          #define AFIO_OFFSET                 (AFIO_BASE - PERIPH_BASE)
     26          
     27          /* --- EVENTCR Register ---*/
     28          /* Alias word address of EVOE bit */
     29          #define EVCR_OFFSET                 (AFIO_OFFSET + 0x00)
     30          #define EVOE_BitNumber              ((u8)0x07)
     31          #define EVCR_EVOE_BB                (PERIPH_BB_BASE + (EVCR_OFFSET * 32) + (EVOE_BitNumber * 4))
     32          
     33          #define EVCR_PORTPINCONFIG_MASK     ((u16)0xFF80)
     34          #define LSB_MASK                    ((u16)0xFFFF)
     35          #define DBGAFR_POSITION_MASK        ((u32)0x000F0000)
     36          #define DBGAFR_SWJCFG_MASK          ((u32)0xF0FFFFFF)
     37          #define DBGAFR_LOCATION_MASK        ((u32)0x00200000)
     38          #define DBGAFR_NUMBITS_MASK         ((u32)0x00100000)
     39          
     40          /* Private macro -------------------------------------------------------------*/
     41          /* Private variables ---------------------------------------------------------*/
     42          /* Private function prototypes -----------------------------------------------*/
     43          /* Private functions ---------------------------------------------------------*/
     44          
     45          /*******************************************************************************
     46          * Function Name  : GPIO_DeInit
     47          * Description    : Deinitializes the GPIOx peripheral registers to their default
     48          *                  reset values.
     49          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
     50          * Output         : None
     51          * Return         : None
     52          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     53          void GPIO_DeInit(GPIO_TypeDef* GPIOx)
     54          {
   \                     GPIO_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     55            /* Check the parameters */
     56            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
     57            
     58            switch (*(u32*)&GPIOx)
   \   00000002   0x....             LDR.N    R1,??DataTable4  ;; 0x40010800
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD012             BEQ.N    ??GPIO_DeInit_0
   \   00000008   0x....             LDR.N    R1,??DataTable4_1  ;; 0x40010c00
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD019             BEQ.N    ??GPIO_DeInit_1
   \   0000000E   0x....             LDR.N    R1,??DataTable4_2  ;; 0x40011000
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD020             BEQ.N    ??GPIO_DeInit_2
   \   00000014   0x....             LDR.N    R1,??DataTable4_3  ;; 0x40011400
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xD027             BEQ.N    ??GPIO_DeInit_3
   \   0000001A   0x....             LDR.N    R1,??DataTable4_4  ;; 0x40011800
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD02E             BEQ.N    ??GPIO_DeInit_4
   \   00000020   0x....             LDR.N    R1,??DataTable4_5  ;; 0x40011c00
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD035             BEQ.N    ??GPIO_DeInit_5
   \   00000026   0x....             LDR.N    R1,??DataTable4_6  ;; 0x40012000
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xD03C             BEQ.N    ??GPIO_DeInit_6
   \   0000002C   0xBD01             POP      {R0,PC}
     59            {
     60              case GPIOA_BASE:
     61                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
   \                     ??GPIO_DeInit_0: (+1)
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0x2004             MOVS     R0,#+4
   \   00000032   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     62                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x2004             MOVS     R0,#+4
   \   0000003A   0xE8BD 0x4004      POP      {R2,LR}
   \   0000003E   0x.... 0x....      B.W      RCC_APB2PeriphResetCmd
     63                break;
     64          
     65              case GPIOB_BASE:
     66                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
   \                     ??GPIO_DeInit_1: (+1)
   \   00000042   0x2101             MOVS     R1,#+1
   \   00000044   0x2008             MOVS     R0,#+8
   \   00000046   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     67                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x2008             MOVS     R0,#+8
   \   0000004E   0xE8BD 0x4004      POP      {R2,LR}
   \   00000052   0x.... 0x....      B.W      RCC_APB2PeriphResetCmd
     68                break;
     69          
     70              case GPIOC_BASE:
     71                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
   \                     ??GPIO_DeInit_2: (+1)
   \   00000056   0x2101             MOVS     R1,#+1
   \   00000058   0x2010             MOVS     R0,#+16
   \   0000005A   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     72                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x2010             MOVS     R0,#+16
   \   00000062   0xE8BD 0x4004      POP      {R2,LR}
   \   00000066   0x.... 0x....      B.W      RCC_APB2PeriphResetCmd
     73                break;
     74          
     75              case GPIOD_BASE:
     76                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
   \                     ??GPIO_DeInit_3: (+1)
   \   0000006A   0x2101             MOVS     R1,#+1
   \   0000006C   0x2020             MOVS     R0,#+32
   \   0000006E   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     77                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
   \   00000072   0x2100             MOVS     R1,#+0
   \   00000074   0x2020             MOVS     R0,#+32
   \   00000076   0xE8BD 0x4004      POP      {R2,LR}
   \   0000007A   0x.... 0x....      B.W      RCC_APB2PeriphResetCmd
     78                break;
     79                
     80              case GPIOE_BASE:
     81                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
   \                     ??GPIO_DeInit_4: (+1)
   \   0000007E   0x2101             MOVS     R1,#+1
   \   00000080   0x2040             MOVS     R0,#+64
   \   00000082   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     82                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x2040             MOVS     R0,#+64
   \   0000008A   0xE8BD 0x4004      POP      {R2,LR}
   \   0000008E   0x.... 0x....      B.W      RCC_APB2PeriphResetCmd
     83                break; 
     84          
     85              case GPIOF_BASE:
     86                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
   \                     ??GPIO_DeInit_5: (+1)
   \   00000092   0x2101             MOVS     R1,#+1
   \   00000094   0x2080             MOVS     R0,#+128
   \   00000096   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     87                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
   \   0000009A   0x2100             MOVS     R1,#+0
   \   0000009C   0x2080             MOVS     R0,#+128
   \   0000009E   0xE8BD 0x4004      POP      {R2,LR}
   \   000000A2   0x.... 0x....      B.W      RCC_APB2PeriphResetCmd
     88                break;
     89          
     90              case GPIOG_BASE:
     91                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
   \                     ??GPIO_DeInit_6: (+1)
   \   000000A6   0x2101             MOVS     R1,#+1
   \   000000A8   0xF44F 0x7080      MOV      R0,#+256
   \   000000AC   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     92                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
   \   000000B0   0x2100             MOVS     R1,#+0
   \   000000B2   0xF44F 0x7080      MOV      R0,#+256
   \   000000B6   0xE8BD 0x4004      POP      {R2,LR}
   \   000000BA   0x.... 0x....      B.W      RCC_APB2PeriphResetCmd
     93                break;                       
     94          
     95              default:
     96                break;
     97            }
     98          }
     99          
    100          /*******************************************************************************
    101          * Function Name  : GPIO_AFIODeInit
    102          * Description    : Deinitializes the Alternate Functions (remap, event control
    103          *                  and EXTI configuration) registers to their default reset
    104          *                  values.
    105          * Input          : None
    106          * Output         : None
    107          * Return         : None
    108          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    109          void GPIO_AFIODeInit(void)
    110          {
   \                     GPIO_AFIODeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    111            RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x4608             MOV      R0,R1
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    112            RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE8BD 0x4004      POP      {R2,LR}
   \   00000012   0x.... 0x....      B.W      RCC_APB2PeriphResetCmd
    113          }
    114          
    115          /*******************************************************************************
    116          * Function Name  : GPIO_Init
    117          * Description    : Initializes the GPIOx peripheral according to the specified
    118          *                  parameters in the GPIO_InitStruct.
    119          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    120          *                  - GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
    121          *                    contains the configuration information for the specified GPIO
    122          *                    peripheral.
    123          * Output         : None
    124          * Return         : None
    125          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    126          void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
    127          {
   \                     GPIO_Init: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    128            u32 currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
   \   00000002   0x2200             MOVS     R2,#+0
    129            u32 tmpreg = 0x00, pinmask = 0x00;
    130          
    131            /* Check the parameters */
    132            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    133            assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
    134            assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
    135            
    136          /*---------------------------- GPIO Mode Configuration -----------------------*/
    137            currentmode = ((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x0F);
   \   00000004   0x78CC             LDRB     R4,[R1, #+3]
   \   00000006   0xF004 0x030F      AND      R3,R4,#0xF
    138          
    139            if ((((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x10)) != 0x00)
   \   0000000A   0x06E4             LSLS     R4,R4,#+27
   \   0000000C   0xD501             BPL.N    ??GPIO_Init_0
    140            { 
    141              /* Check the parameters */
    142              assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    143              /* Output mode */
    144              currentmode |= (u32)GPIO_InitStruct->GPIO_Speed;
   \   0000000E   0x788C             LDRB     R4,[R1, #+2]
   \   00000010   0x4323             ORRS     R3,R4,R3
    145            }
    146          
    147          /*---------------------------- GPIO CRL Configuration ------------------------*/
    148            /* Configure the eight low port pins */
    149            if (((u32)GPIO_InitStruct->GPIO_Pin & ((u32)0x00FF)) != 0x00)
   \                     ??GPIO_Init_0: (+1)
   \   00000012   0x880C             LDRH     R4,[R1, #+0]
   \   00000014   0xB2E4             UXTB     R4,R4
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD01B             BEQ.N    ??GPIO_Init_1
    150            {
    151              tmpreg = GPIOx->CRL;
   \   0000001A   0x6805             LDR      R5,[R0, #+0]
    152          
    153              for (pinpos = 0x00; pinpos < 0x08; pinpos++)
   \   0000001C   0xE016             B.N      ??GPIO_Init_2
    154              {
    155                pos = ((u32)0x01) << pinpos;
   \                     ??GPIO_Init_3: (+1)
   \   0000001E   0x2401             MOVS     R4,#+1
   \   00000020   0x4094             LSLS     R4,R4,R2
   \   00000022   0x4626             MOV      R6,R4
    156                /* Get the port pins position */
    157                currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
    158          
    159                if (currentpin == pos)
   \   00000024   0x880F             LDRH     R7,[R1, #+0]
   \   00000026   0x4037             ANDS     R7,R6,R7
   \   00000028   0x42B7             CMP      R7,R6
   \   0000002A   0xD10E             BNE.N    ??GPIO_Init_4
    160                {
    161                  pos = pinpos << 2;
   \   0000002C   0x0096             LSLS     R6,R2,#+2
    162                  /* Clear the corresponding low control register bits */
    163                  pinmask = ((u32)0x0F) << pos;
    164                  tmpreg &= ~pinmask;
    165          
    166                  /* Write the mode configuration in the corresponding bits */
    167                  tmpreg |= (currentmode << pos);
   \   0000002E   0x270F             MOVS     R7,#+15
   \   00000030   0x40B7             LSLS     R7,R7,R6
   \   00000032   0x43BD             BICS     R5,R5,R7
   \   00000034   0xFA03 0xF606      LSL      R6,R3,R6
   \   00000038   0x4335             ORRS     R5,R6,R5
    168          
    169                  /* Reset the corresponding ODR bit */
    170                  if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
   \   0000003A   0x78CE             LDRB     R6,[R1, #+3]
   \   0000003C   0x2E28             CMP      R6,#+40
   \   0000003E   0xD100             BNE.N    ??GPIO_Init_5
    171                  {
    172                    GPIOx->BRR = (((u32)0x01) << pinpos);
   \   00000040   0x6144             STR      R4,[R0, #+20]
    173                  }
    174                  /* Set the corresponding ODR bit */
    175                  if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
   \                     ??GPIO_Init_5: (+1)
   \   00000042   0x78CE             LDRB     R6,[R1, #+3]
   \   00000044   0x2E48             CMP      R6,#+72
   \   00000046   0xD100             BNE.N    ??GPIO_Init_4
    176                  {
    177                    GPIOx->BSRR = (((u32)0x01) << pinpos);
   \   00000048   0x6104             STR      R4,[R0, #+16]
    178                  }
    179                }
    180              }
   \                     ??GPIO_Init_4: (+1)
   \   0000004A   0x1C52             ADDS     R2,R2,#+1
   \                     ??GPIO_Init_2: (+1)
   \   0000004C   0x2A08             CMP      R2,#+8
   \   0000004E   0xD3E6             BCC.N    ??GPIO_Init_3
    181              GPIOx->CRL = tmpreg;
   \   00000050   0x6005             STR      R5,[R0, #+0]
    182            }
    183          
    184          /*---------------------------- GPIO CRH Configuration ------------------------*/
    185            /* Configure the eight high port pins */
    186            if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
   \                     ??GPIO_Init_1: (+1)
   \   00000052   0x880A             LDRH     R2,[R1, #+0]
   \   00000054   0x2AFF             CMP      R2,#+255
   \   00000056   0xDD1E             BLE.N    ??GPIO_Init_6
    187            {
    188              tmpreg = GPIOx->CRH;
   \   00000058   0x6845             LDR      R5,[R0, #+4]
    189              for (pinpos = 0x00; pinpos < 0x08; pinpos++)
   \   0000005A   0x2200             MOVS     R2,#+0
   \   0000005C   0xE018             B.N      ??GPIO_Init_7
    190              {
    191                pos = (((u32)0x01) << (pinpos + 0x08));
   \                     ??GPIO_Init_8: (+1)
   \   0000005E   0x2401             MOVS     R4,#+1
   \   00000060   0xF102 0x0608      ADD      R6,R2,#+8
   \   00000064   0x40B4             LSLS     R4,R4,R6
   \   00000066   0x4626             MOV      R6,R4
    192                /* Get the port pins position */
    193                currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
    194                if (currentpin == pos)
   \   00000068   0x880F             LDRH     R7,[R1, #+0]
   \   0000006A   0x4037             ANDS     R7,R6,R7
   \   0000006C   0x42B7             CMP      R7,R6
   \   0000006E   0xD10E             BNE.N    ??GPIO_Init_9
    195                {
    196                  pos = pinpos << 2;
   \   00000070   0x0096             LSLS     R6,R2,#+2
    197                  /* Clear the corresponding high control register bits */
    198                  pinmask = ((u32)0x0F) << pos;
    199                  tmpreg &= ~pinmask;
    200          
    201                  /* Write the mode configuration in the corresponding bits */
    202                  tmpreg |= (currentmode << pos);
   \   00000072   0x270F             MOVS     R7,#+15
   \   00000074   0x40B7             LSLS     R7,R7,R6
   \   00000076   0x43BD             BICS     R5,R5,R7
   \   00000078   0xFA03 0xF606      LSL      R6,R3,R6
   \   0000007C   0x4335             ORRS     R5,R6,R5
    203          
    204                  /* Reset the corresponding ODR bit */
    205                  if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
   \   0000007E   0x78CE             LDRB     R6,[R1, #+3]
   \   00000080   0x2E28             CMP      R6,#+40
   \   00000082   0xD100             BNE.N    ??GPIO_Init_10
    206                  {
    207                    GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
   \   00000084   0x6144             STR      R4,[R0, #+20]
    208                  }
    209                  /* Set the corresponding ODR bit */
    210                  if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
   \                     ??GPIO_Init_10: (+1)
   \   00000086   0x78CE             LDRB     R6,[R1, #+3]
   \   00000088   0x2E48             CMP      R6,#+72
   \   0000008A   0xD100             BNE.N    ??GPIO_Init_9
    211                  {
    212                    GPIOx->BSRR = (((u32)0x01) << (pinpos + 0x08));
   \   0000008C   0x6104             STR      R4,[R0, #+16]
    213                  }
    214                }
    215              }
   \                     ??GPIO_Init_9: (+1)
   \   0000008E   0x1C52             ADDS     R2,R2,#+1
   \                     ??GPIO_Init_7: (+1)
   \   00000090   0x2A08             CMP      R2,#+8
   \   00000092   0xD3E4             BCC.N    ??GPIO_Init_8
    216              GPIOx->CRH = tmpreg;
   \   00000094   0x6045             STR      R5,[R0, #+4]
    217            }
    218          }
   \                     ??GPIO_Init_6: (+1)
   \   00000096   0xBCF0             POP      {R4-R7}
   \   00000098   0x4770             BX       LR               ;; return
    219          
    220          /*******************************************************************************
    221          * Function Name  : GPIO_StructInit
    222          * Description    : Fills each GPIO_InitStruct member with its default value.
    223          * Input          : - GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure
    224          *                    which will be initialized.
    225          * Output         : None
    226          * Return         : None
    227          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    228          void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
    229          {
    230            /* Reset GPIO init structure parameters values */
    231            GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
   \                     GPIO_StructInit: (+1)
   \   00000000   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000004   0x8001             STRH     R1,[R0, #+0]
    232            GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x7081             STRB     R1,[R0, #+2]
    233            GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   0000000A   0x2104             MOVS     R1,#+4
   \   0000000C   0x70C1             STRB     R1,[R0, #+3]
    234          }
   \   0000000E   0x4770             BX       LR               ;; return
    235          
    236          /*******************************************************************************
    237          * Function Name  : GPIO_ReadInputDataBit
    238          * Description    : Reads the specified input port pin.
    239          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    240          *                : - GPIO_Pin:  specifies the port bit to read.
    241          *                    This parameter can be GPIO_Pin_x where x can be (0..15).
    242          * Output         : None
    243          * Return         : The input port pin value.
    244          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    245          u8 GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
    246          {
    247            u8 bitstatus = 0x00;
   \                     GPIO_ReadInputDataBit: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    248            
    249            /* Check the parameters */
    250            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    251            assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
    252            
    253            if ((GPIOx->IDR & GPIO_Pin) != (u32)Bit_RESET)
   \   00000002   0x6880             LDR      R0,[R0, #+8]
   \   00000004   0x4208             TST      R0,R1
   \   00000006   0xD000             BEQ.N    ??GPIO_ReadInputDataBit_0
    254            {
    255              bitstatus = (u8)Bit_SET;
   \   00000008   0x2201             MOVS     R2,#+1
    256            }
    257            else
    258            {
    259              bitstatus = (u8)Bit_RESET;
    260            }
    261            return bitstatus;
   \                     ??GPIO_ReadInputDataBit_0: (+1)
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0x4770             BX       LR               ;; return
    262          }
    263          
    264          /*******************************************************************************
    265          * Function Name  : GPIO_ReadInputData
    266          * Description    : Reads the specified GPIO input data port.
    267          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    268          * Output         : None
    269          * Return         : GPIO input data port value.
    270          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    271          u16 GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
    272          {
    273            /* Check the parameters */
    274            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    275            
    276            return ((u16)GPIOx->IDR);
   \                     GPIO_ReadInputData: (+1)
   \   00000000   0x6880             LDR      R0,[R0, #+8]
   \   00000002   0xB280             UXTH     R0,R0
   \   00000004   0x4770             BX       LR               ;; return
    277          }
    278          
    279          /*******************************************************************************
    280          * Function Name  : GPIO_ReadOutputDataBit
    281          * Description    : Reads the specified output data port bit.
    282          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    283          *                : - GPIO_Pin:  specifies the port bit to read.
    284          *                    This parameter can be GPIO_Pin_x where x can be (0..15).
    285          * Output         : None
    286          * Return         : The output port pin value.
    287          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    288          u8 GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
    289          {
    290            u8 bitstatus = 0x00;
   \                     GPIO_ReadOutputDataBit: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    291          
    292            /* Check the parameters */
    293            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    294            assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
    295            
    296            if ((GPIOx->ODR & GPIO_Pin) != (u32)Bit_RESET)
   \   00000002   0x68C0             LDR      R0,[R0, #+12]
   \   00000004   0x4208             TST      R0,R1
   \   00000006   0xD000             BEQ.N    ??GPIO_ReadOutputDataBit_0
    297            {
    298              bitstatus = (u8)Bit_SET;
   \   00000008   0x2201             MOVS     R2,#+1
    299            }
    300            else
    301            {
    302              bitstatus = (u8)Bit_RESET;
    303            }
    304            return bitstatus;
   \                     ??GPIO_ReadOutputDataBit_0: (+1)
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0x4770             BX       LR               ;; return
    305          }
    306          
    307          /*******************************************************************************
    308          * Function Name  : GPIO_ReadOutputData
    309          * Description    : Reads the specified GPIO output data port.
    310          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    311          * Output         : None
    312          * Return         : GPIO output data port value.
    313          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    314          u16 GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
    315          {
    316            /* Check the parameters */
    317            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    318              
    319            return ((u16)GPIOx->ODR);
   \                     GPIO_ReadOutputData: (+1)
   \   00000000   0x68C0             LDR      R0,[R0, #+12]
   \   00000002   0xB280             UXTH     R0,R0
   \   00000004   0x4770             BX       LR               ;; return
    320          }
    321          
    322          /*******************************************************************************
    323          * Function Name  : GPIO_SetBits
    324          * Description    : Sets the selected data port bits.
    325          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    326          *                  - GPIO_Pin: specifies the port bits to be written.
    327          *                    This parameter can be any combination of GPIO_Pin_x where 
    328          *                    x can be (0..15).
    329          * Output         : None
    330          * Return         : None
    331          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    332          void GPIO_SetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
    333          {
    334            /* Check the parameters */
    335            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    336            assert_param(IS_GPIO_PIN(GPIO_Pin));
    337            
    338            GPIOx->BSRR = GPIO_Pin;
   \                     GPIO_SetBits: (+1)
   \   00000000   0x6101             STR      R1,[R0, #+16]
    339          }
   \   00000002   0x4770             BX       LR               ;; return
    340          
    341          /*******************************************************************************
    342          * Function Name  : GPIO_ResetBits
    343          * Description    : Clears the selected data port bits.
    344          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    345          *                  - GPIO_Pin: specifies the port bits to be written.
    346          *                    This parameter can be any combination of GPIO_Pin_x where 
    347          *                    x can be (0..15).
    348          * Output         : None
    349          * Return         : None
    350          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    351          void GPIO_ResetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
    352          {
    353            /* Check the parameters */
    354            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    355            assert_param(IS_GPIO_PIN(GPIO_Pin));
    356            
    357            GPIOx->BRR = GPIO_Pin;
   \                     GPIO_ResetBits: (+1)
   \   00000000   0x6141             STR      R1,[R0, #+20]
    358          }
   \   00000002   0x4770             BX       LR               ;; return
    359          
    360          /*******************************************************************************
    361          * Function Name  : GPIO_WriteBit
    362          * Description    : Sets or clears the selected data port bit.
    363          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    364          *                  - GPIO_Pin: specifies the port bit to be written.
    365          *                    This parameter can be one of GPIO_Pin_x where x can be (0..15).
    366          *                  - BitVal: specifies the value to be written to the selected bit.
    367          *                    This parameter can be one of the BitAction enum values:
    368          *                       - Bit_RESET: to clear the port pin
    369          *                       - Bit_SET: to set the port pin
    370          * Output         : None
    371          * Return         : None
    372          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    373          void GPIO_WriteBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin, BitAction BitVal)
    374          {
    375            /* Check the parameters */
    376            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    377            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
    378            assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
    379            
    380            if (BitVal != Bit_RESET)
   \                     GPIO_WriteBit: (+1)
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0xD001             BEQ.N    ??GPIO_WriteBit_0
    381            {
    382              GPIOx->BSRR = GPIO_Pin;
   \   00000004   0x6101             STR      R1,[R0, #+16]
   \   00000006   0x4770             BX       LR
    383            }
    384            else
    385            {
    386              GPIOx->BRR = GPIO_Pin;
   \                     ??GPIO_WriteBit_0: (+1)
   \   00000008   0x6141             STR      R1,[R0, #+20]
    387            }
    388          }
   \   0000000A   0x4770             BX       LR               ;; return
    389          
    390          /*******************************************************************************
    391          * Function Name  : GPIO_Write
    392          * Description    : Writes data to the specified GPIO data port.
    393          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    394          *                  - PortVal: specifies the value to be written to the port output
    395          *                    data register.
    396          * Output         : None
    397          * Return         : None
    398          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    399          void GPIO_Write(GPIO_TypeDef* GPIOx, u16 PortVal)
    400          {
    401            /* Check the parameters */
    402            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    403            
    404            GPIOx->ODR = PortVal;
   \                     GPIO_Write: (+1)
   \   00000000   0x60C1             STR      R1,[R0, #+12]
    405          }
   \   00000002   0x4770             BX       LR               ;; return
    406          
    407          /*******************************************************************************
    408          * Function Name  : GPIO_PinLockConfig
    409          * Description    : Locks GPIO Pins configuration registers.
    410          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    411          *                  - GPIO_Pin: specifies the port bit to be written.
    412          *                    This parameter can be any combination of GPIO_Pin_x where 
    413          *                    x can be (0..15).
    414          * Output         : None
    415          * Return         : None
    416          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    417          void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
    418          {
    419            u32 tmp = 0x00010000;
    420            
    421            /* Check the parameters */
    422            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    423            assert_param(IS_GPIO_PIN(GPIO_Pin));
    424            
    425            tmp |= GPIO_Pin;
   \                     GPIO_PinLockConfig: (+1)
   \   00000000   0xF441 0x3280      ORR      R2,R1,#0x10000
    426            /* Set LCKK bit */
    427            GPIOx->LCKR = tmp;
   \   00000004   0x6182             STR      R2,[R0, #+24]
    428            /* Reset LCKK bit */
    429            GPIOx->LCKR =  GPIO_Pin;
   \   00000006   0x6181             STR      R1,[R0, #+24]
    430            /* Set LCKK bit */
    431            GPIOx->LCKR = tmp;
   \   00000008   0x6182             STR      R2,[R0, #+24]
    432            /* Read LCKK bit*/
    433            tmp = GPIOx->LCKR;
   \   0000000A   0x6981             LDR      R1,[R0, #+24]
    434            /* Read LCKK bit*/
    435            tmp = GPIOx->LCKR;
   \   0000000C   0x6980             LDR      R0,[R0, #+24]
    436          }
   \   0000000E   0x4770             BX       LR               ;; return
    437          
    438          /*******************************************************************************
    439          * Function Name  : GPIO_EventOutputConfig
    440          * Description    : Selects the GPIO pin used as Event output.
    441          * Input          : - GPIO_PortSource: selects the GPIO port to be used as source
    442          *                    for Event output.
    443          *                    This parameter can be GPIO_PortSourceGPIOx where x can be
    444          *                    (A..E).
    445          *                  - GPIO_PinSource: specifies the pin for the Event output.
    446          *                    This parameter can be GPIO_PinSourcex where x can be (0..15).
    447          * Output         : None
    448          * Return         : None
    449          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    450          void GPIO_EventOutputConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
    451          {
   \                     GPIO_EventOutputConfig: (+1)
   \   00000000   0xB410             PUSH     {R4}
    452            u32 tmpreg = 0x00;
    453          
    454            /* Check the parameters */
    455            assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
    456            assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    457              
    458            tmpreg = AFIO->EVCR;
   \   00000002   0x....             LDR.N    R2,??DataTable4_7  ;; 0x40010000
   \   00000004   0x6813             LDR      R3,[R2, #+0]
    459            /* Clear the PORT[6:4] and PIN[3:0] bits */
    460            tmpreg &= EVCR_PORTPINCONFIG_MASK;
    461            tmpreg |= (u32)GPIO_PortSource << 0x04;
    462            tmpreg |= GPIO_PinSource;
    463          
    464            AFIO->EVCR = tmpreg;
   \   00000006   0xF64F 0x7480      MOVW     R4,#+65408
   \   0000000A   0x4023             ANDS     R3,R4,R3
   \   0000000C   0xEA43 0x1000      ORR      R0,R3,R0, LSL #+4
   \   00000010   0x4308             ORRS     R0,R1,R0
   \   00000012   0x6010             STR      R0,[R2, #+0]
    465          }
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x4770             BX       LR               ;; return
    466          
    467          /*******************************************************************************
    468          * Function Name  : GPIO_EventOutputCmd
    469          * Description    : Enables or disables the Event Output.
    470          * Input          : - NewState: new state of the Event output.
    471          *                    This parameter can be: ENABLE or DISABLE.
    472          * Output         : None
    473          * Return         : None
    474          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    475          void GPIO_EventOutputCmd(FunctionalState NewState)
    476          {
    477            /* Check the parameters */
    478            assert_param(IS_FUNCTIONAL_STATE(NewState));
    479            
    480            *(vu32 *) EVCR_EVOE_BB = (u32)NewState;
   \                     GPIO_EventOutputCmd: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable4_8  ;; 0x4220001c
   \   00000002   0x6008             STR      R0,[R1, #+0]
    481          }
   \   00000004   0x4770             BX       LR               ;; return
    482          
    483          /*******************************************************************************
    484          * Function Name  : GPIO_PinRemapConfig
    485          * Description    : Changes the mapping of the specified pin.
    486          * Input          : - GPIO_Remap: selects the pin to remap.
    487          *                    This parameter can be one of the following values:
    488          *                       - GPIO_Remap_SPI1
    489          *                       - GPIO_Remap_I2C1
    490          *                       - GPIO_Remap_USART1
    491          *                       - GPIO_Remap_USART2
    492          *                       - GPIO_PartialRemap_USART3
    493          *                       - GPIO_FullRemap_USART3
    494          *                       - GPIO_PartialRemap_TIM1
    495          *                       - GPIO_FullRemap_TIM1
    496          *                       - GPIO_PartialRemap1_TIM2
    497          *                       - GPIO_PartialRemap2_TIM2
    498          *                       - GPIO_FullRemap_TIM2
    499          *                       - GPIO_PartialRemap_TIM3
    500          *                       - GPIO_FullRemap_TIM3
    501          *                       - GPIO_Remap_TIM4
    502          *                       - GPIO_Remap1_CAN
    503          *                       - GPIO_Remap2_CAN
    504          *                       - GPIO_Remap_PD01
    505          *                       - GPIO_Remap_TIM5CH4_LSI
    506          *                       - GPIO_Remap_ADC1_ETRGINJ
    507          *                       - GPIO_Remap_ADC1_ETRGREG
    508          *                       - GPIO_Remap_ADC2_ETRGINJ
    509          *                       - GPIO_Remap_ADC2_ETRGREG
    510          *                       - GPIO_Remap_SWJ_NoJTRST
    511          *                       - GPIO_Remap_SWJ_JTAGDisable
    512          *                       - GPIO_Remap_SWJ_Disable
    513          *                  - NewState: new state of the port pin remapping.
    514          *                    This parameter can be: ENABLE or DISABLE.
    515          * Output         : None
    516          * Return         : None
    517          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    518          void GPIO_PinRemapConfig(u32 GPIO_Remap, FunctionalState NewState)
    519          {
   \                     GPIO_PinRemapConfig: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    520            u32 tmp = 0x00, tmp1 = 0x00, tmpreg = 0x00, tmpmask = 0x00;
    521          
    522            /* Check the parameters */
    523            assert_param(IS_GPIO_REMAP(GPIO_Remap));
    524            assert_param(IS_FUNCTIONAL_STATE(NewState));  
    525            
    526            tmpreg = AFIO->MAPR;
   \   00000002   0x....             LDR.N    R2,??DataTable4_9  ;; 0x40010004
   \   00000004   0x6814             LDR      R4,[R2, #+0]
    527          
    528            tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
   \   00000006   0xF3C0 0x4503      UBFX     R5,R0,#+16,#+4
    529            tmp = GPIO_Remap & LSB_MASK;
   \   0000000A   0xB283             UXTH     R3,R0
    530          
    531            if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
   \   0000000C   0xF400 0x1640      AND      R6,R0,#0x300000
   \   00000010   0xF5B6 0x1F40      CMP      R6,#+3145728
   \   00000014   0xD106             BNE.N    ??GPIO_PinRemapConfig_0
    532            {
    533              tmpreg &= DBGAFR_SWJCFG_MASK;
   \   00000016   0xF024 0x6470      BIC      R4,R4,#0xF000000
    534              AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
   \   0000001A   0x6815             LDR      R5,[R2, #+0]
   \   0000001C   0xF025 0x6570      BIC      R5,R5,#0xF000000
   \   00000020   0x6015             STR      R5,[R2, #+0]
   \   00000022   0xE00F             B.N      ??GPIO_PinRemapConfig_1
    535            }
    536            else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
   \                     ??GPIO_PinRemapConfig_0: (+1)
   \   00000024   0x02C6             LSLS     R6,R0,#+11
   \   00000026   0xD506             BPL.N    ??GPIO_PinRemapConfig_2
    537            {
    538              tmp1 = ((u32)0x03) << tmpmask;
    539              tmpreg &= ~tmp1;
    540              tmpreg |= ~DBGAFR_SWJCFG_MASK;
   \   00000028   0x2603             MOVS     R6,#+3
   \   0000002A   0xFA06 0xF505      LSL      R5,R6,R5
   \   0000002E   0x43AC             BICS     R4,R4,R5
   \   00000030   0xF044 0x6470      ORR      R4,R4,#0xF000000
   \   00000034   0xE006             B.N      ??GPIO_PinRemapConfig_1
    541            }
    542            else
    543            {
    544              tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
    545              tmpreg |= ~DBGAFR_SWJCFG_MASK;
   \                     ??GPIO_PinRemapConfig_2: (+1)
   \   00000036   0x0D45             LSRS     R5,R0,#+21
   \   00000038   0x012D             LSLS     R5,R5,#+4
   \   0000003A   0xFA03 0xF505      LSL      R5,R3,R5
   \   0000003E   0x43AC             BICS     R4,R4,R5
   \   00000040   0xF044 0x6470      ORR      R4,R4,#0xF000000
    546            }
    547          
    548            if (NewState != DISABLE)
   \                     ??GPIO_PinRemapConfig_1: (+1)
   \   00000044   0x2900             CMP      R1,#+0
   \   00000046   0xD004             BEQ.N    ??GPIO_PinRemapConfig_3
    549            {
    550              tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
   \   00000048   0x0D40             LSRS     R0,R0,#+21
   \   0000004A   0x0100             LSLS     R0,R0,#+4
   \   0000004C   0xFA03 0xF000      LSL      R0,R3,R0
   \   00000050   0x4304             ORRS     R4,R0,R4
    551            }
    552          
    553            AFIO->MAPR = tmpreg;
   \                     ??GPIO_PinRemapConfig_3: (+1)
   \   00000052   0x6014             STR      R4,[R2, #+0]
    554          }
   \   00000054   0xBC70             POP      {R4-R6}
   \   00000056   0x4770             BX       LR               ;; return
    555          
    556          /*******************************************************************************
    557          * Function Name  : GPIO_EXTILineConfig
    558          * Description    : Selects the GPIO pin used as EXTI Line.
    559          * Input          : - GPIO_PortSource: selects the GPIO port to be used as
    560          *                    source for EXTI lines.
    561          *                    This parameter can be GPIO_PortSourceGPIOx where x can be
    562          *                    (A..G).
    563          *                  - GPIO_PinSource: specifies the EXTI line to be configured.
    564          *                   This parameter can be GPIO_PinSourcex where x can be (0..15).
    565          * Output         : None
    566          * Return         : None
    567          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    568          void GPIO_EXTILineConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
    569          {
   \                     GPIO_EXTILineConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    570            u32 tmp = 0x00;
    571          
    572            /* Check the parameters */
    573            assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
    574            assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    575            
    576            tmp = ((u32)0x0F) << (0x04 * (GPIO_PinSource & (u8)0x03));
    577          
    578            AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
   \   00000002   0xF001 0x0203      AND      R2,R1,#0x3
   \   00000006   0x0092             LSLS     R2,R2,#+2
   \   00000008   0xF021 0x0103      BIC      R1,R1,#0x3
   \   0000000C   0x....             LDR.N    R3,??DataTable4_10  ;; 0x40010008
   \   0000000E   0x58CC             LDR      R4,[R1, R3]
   \   00000010   0x250F             MOVS     R5,#+15
   \   00000012   0x4095             LSLS     R5,R5,R2
   \   00000014   0x43AC             BICS     R4,R4,R5
   \   00000016   0x50CC             STR      R4,[R1, R3]
    579            AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((u32)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (u8)0x03)));
   \   00000018   0x58CC             LDR      R4,[R1, R3]
   \   0000001A   0x4090             LSLS     R0,R0,R2
   \   0000001C   0x4320             ORRS     R0,R0,R4
   \   0000001E   0x50C8             STR      R0,[R1, R3]
    580          }
   \   00000020   0xBC30             POP      {R4,R5}
   \   00000022   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x40011800         DC32     0x40011800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x40011C00         DC32     0x40011c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x40012000         DC32     0x40012000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x4220001C         DC32     0x4220001c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x40010004         DC32     0x40010004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0x40010008         DC32     0x40010008
    581          
    582          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   GPIO_AFIODeInit
         0   -> RCC_APB2PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
       8   GPIO_DeInit
         0   -> RCC_APB2PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
       8   GPIO_EXTILineConfig
       0   GPIO_EventOutputCmd
       4   GPIO_EventOutputConfig
      16   GPIO_Init
       0   GPIO_PinLockConfig
      12   GPIO_PinRemapConfig
       0   GPIO_ReadInputData
       0   GPIO_ReadInputDataBit
       0   GPIO_ReadOutputData
       0   GPIO_ReadOutputDataBit
       0   GPIO_ResetBits
       0   GPIO_SetBits
       0   GPIO_StructInit
       0   GPIO_Write
       0   GPIO_WriteBit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
      22  GPIO_AFIODeInit
     190  GPIO_DeInit
      36  GPIO_EXTILineConfig
       6  GPIO_EventOutputCmd
      24  GPIO_EventOutputConfig
     154  GPIO_Init
      16  GPIO_PinLockConfig
      88  GPIO_PinRemapConfig
       6  GPIO_ReadInputData
      14  GPIO_ReadInputDataBit
       6  GPIO_ReadOutputData
      14  GPIO_ReadOutputDataBit
       4  GPIO_ResetBits
       4  GPIO_SetBits
      16  GPIO_StructInit
       4  GPIO_Write
      12  GPIO_WriteBit

 
 660 bytes in section .text
 
 660 bytes of CODE memory

Errors: none
Warnings: none
