###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        12/Jul/2019  09:14:40
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\UCOS-II\uC-OSII\Source\os_task.c
#    Command line =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\UCOS-II\uC-OSII\Source\os_task.c
#        -D LORA_MODULE -lCN
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\List\ -o
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\Softwares\IAR7.40\arm\INC\c\DLib_Config_Full.h -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\CPU\inc\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-CPU\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-CPU\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-LIB\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-OSII\Ports\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-OSII\Source\
#        -I E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\USER\BSP\
#        -I E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\USER\APP\
#        -Om --use_c++_inline
#    List file    =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\List\os_task.lst
#    Object file  =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\Obj\os_task.o
#
###############################################################################

E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\UCOS-II\uC-OSII\Source\os_task.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                            TASK MANAGEMENT
      6          *
      7          *                              (c) Copyright 1992-2007, Micrium, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_TASK.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.86
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license 
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience 
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #include <ucos_ii.h>
     26          #endif
     27          
     28          /*$PAGE*/
     29          /*
     30          *********************************************************************************************************
     31          *                                        CHANGE PRIORITY OF A TASK
     32          *
     33          * Description: This function allows you to change the priority of a task dynamically.  Note that the new
     34          *              priority MUST be available.
     35          *
     36          * Arguments  : oldp     is the old priority
     37          *
     38          *              newp     is the new priority
     39          *
     40          * Returns    : OS_ERR_NONE            is the call was successful
     41          *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
     42          *                                     (i.e. >= OS_LOWEST_PRIO)
     43          *              OS_ERR_PRIO_EXIST      if the new priority already exist.
     44          *              OS_ERR_PRIO            there is no task with the specified OLD priority (i.e. the OLD task does
     45          *                                     not exist.
     46          *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP.
     47          *********************************************************************************************************
     48          */
     49          
     50          #if OS_TASK_CHANGE_PRIO_EN > 0

   \                                 In section .text, align 2, keep-with-next
     51          INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
     52          {
   \                     OSTaskChangePrio: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
     53          #if (OS_EVENT_EN)
     54              OS_EVENT  *pevent;
     55          #if (OS_EVENT_MULTI_EN > 0)
     56              OS_EVENT **pevents;
     57          #endif
     58          #endif
     59              OS_TCB    *ptcb;
     60              INT8U      y_new;
     61              INT8U      x_new;
     62              INT8U      y_old;
     63          #if OS_LOWEST_PRIO <= 63
     64              INT8U      bity_new;
     65              INT8U      bitx_new;
     66              INT8U      bity_old;
     67              INT8U      bitx_old;
     68          #else
     69              INT16U     bity_new;
     70              INT16U     bitx_new;
     71              INT16U     bity_old;
     72              INT16U     bitx_old;
     73          #endif
     74          #if OS_CRITICAL_METHOD == 3
     75              OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
     76          #endif
     77          
     78          
     79          /*$PAGE*/
     80          #if OS_ARG_CHK_EN > 0
     81              if (oldprio >= OS_LOWEST_PRIO) {
     82                  if (oldprio != OS_PRIO_SELF) {
     83                      return (OS_ERR_PRIO_INVALID);
     84                  }
     85              }
     86              if (newprio >= OS_LOWEST_PRIO) {
     87                  return (OS_ERR_PRIO_INVALID);
     88              }
     89          #endif
     90              OS_ENTER_CRITICAL();
   \   00000008   0x.... 0x....      BL       OS_CPU_SR_Save
     91              if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
   \   0000000C   0x4629             MOV      R1,R5
   \   0000000E   0x.... 0x....      LDR.W    R12,??DataTable10
   \   00000012   0xF85C 0x2021      LDR      R2,[R12, R1, LSL #+2]
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD003             BEQ.N    ??OSTaskChangePrio_0
     92                  OS_EXIT_CRITICAL();
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Restore
     93                  return (OS_ERR_PRIO_EXIST);
   \   0000001E   0x2028             MOVS     R0,#+40
   \   00000020   0xE0B3             B.N      ??OSTaskChangePrio_1
     94              }
     95              if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
   \                     ??OSTaskChangePrio_0: (+1)
   \   00000022   0x2CFF             CMP      R4,#+255
   \   00000024   0xD104             BNE.N    ??OSTaskChangePrio_2
     96                  oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
   \   00000026   0x.... 0x....      LDR.W    R2,??DataTable10_1
   \   0000002A   0x6812             LDR      R2,[R2, #+0]
   \   0000002C   0xF892 0x4032      LDRB     R4,[R2, #+50]
     97              }
     98              ptcb = OSTCBPrioTbl[oldprio];
   \                     ??OSTaskChangePrio_2: (+1)
   \   00000030   0xF85C 0x2024      LDR      R2,[R12, R4, LSL #+2]
     99              if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
   \   00000034   0x2A00             CMP      R2,#+0
   \   00000036   0xD103             BNE.N    ??OSTaskChangePrio_3
    100                  OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
   \   00000038   0x.... 0x....      BL       OS_CPU_SR_Restore
    101                  return (OS_ERR_PRIO);
   \   0000003C   0x2029             MOVS     R0,#+41
   \   0000003E   0xE0A4             B.N      ??OSTaskChangePrio_1
    102              }
    103              if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
   \                     ??OSTaskChangePrio_3: (+1)
   \   00000040   0x2A01             CMP      R2,#+1
   \   00000042   0xD103             BNE.N    ??OSTaskChangePrio_4
    104                  OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
   \   00000044   0x.... 0x....      BL       OS_CPU_SR_Restore
    105                  return (OS_ERR_TASK_NOT_EXIST);
   \   00000048   0x2043             MOVS     R0,#+67
   \   0000004A   0xE09E             B.N      ??OSTaskChangePrio_1
    106              }
    107          #if OS_LOWEST_PRIO <= 63
    108              y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
   \                     ??OSTaskChangePrio_4: (+1)
   \   0000004C   0x08EB             LSRS     R3,R5,#+3
    109              x_new                 = (INT8U)(newprio & 0x07);
   \   0000004E   0xF005 0x0607      AND      R6,R5,#0x7
    110              bity_new              = (INT8U)(1 << y_new);
   \   00000052   0xF04F 0x0E01      MOV      LR,#+1
   \   00000056   0xFA0E 0xF703      LSL      R7,LR,R3
   \   0000005A   0xB2FF             UXTB     R7,R7
    111              bitx_new              = (INT8U)(1 << x_new);
   \   0000005C   0xFA0E 0xFE06      LSL      LR,LR,R6
   \   00000060   0xFA5F 0xFE8E      UXTB     LR,LR
    112          #else
    113              y_new                 = (INT8U)((newprio >> 4) & 0x0F);
    114              x_new                 = (INT8U)( newprio & 0x0F);
    115              bity_new              = (INT16U)(1 << y_new);
    116              bitx_new              = (INT16U)(1 << x_new);
    117          #endif
    118          
    119              OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
   \   00000064   0xF04F 0x0800      MOV      R8,#+0
   \   00000068   0xF84C 0x8024      STR      R8,[R12, R4, LSL #+2]
    120              OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
   \   0000006C   0xF84C 0x2021      STR      R2,[R12, R1, LSL #+2]
    121              y_old                 =  ptcb->OSTCBY;
   \   00000070   0xF102 0x0432      ADD      R4,R2,#+50
   \   00000074   0xF894 0x8002      LDRB     R8,[R4, #+2]
    122              bity_old              =  ptcb->OSTCBBitY;
   \   00000078   0x7921             LDRB     R1,[R4, #+4]
   \   0000007A   0x9100             STR      R1,[SP, #+0]
    123              bitx_old              =  ptcb->OSTCBBitX;
   \   0000007C   0xF894 0xC003      LDRB     R12,[R4, #+3]
    124              if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
   \   00000080   0x.... 0x....      LDR.W    R9,??DataTable10_2
   \   00000084   0xF818 0xA009      LDRB     R10,[R8, R9]
   \   00000088   0x46E3             MOV      R11,R12
   \   0000008A   0xEA1A 0x0F0B      TST      R10,R11
   \   0000008E   0xD01C             BEQ.N    ??OSTaskChangePrio_5
    125                   OSRdyTbl[y_old] &= ~bitx_old;
   \   00000090   0xEA6F 0x010C      MVN      R1,R12
   \   00000094   0xEA11 0x0A0A      ANDS     R10,R1,R10
   \   00000098   0xF808 0xA009      STRB     R10,[R8, R9]
    126                   if (OSRdyTbl[y_old] == 0) {
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   000000A0   0xD107             BNE.N    ??OSTaskChangePrio_6
    127                       OSRdyGrp &= ~bity_old;
   \   000000A2   0xF891 0xA000      LDRB     R10,[R1, #+0]
   \   000000A6   0xF8DD 0xB000      LDR      R11,[SP, #+0]
   \   000000AA   0xEA2A 0x0A0B      BIC      R10,R10,R11
   \   000000AE   0xF881 0xA000      STRB     R10,[R1, #+0]
    128                   }
    129                   OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
   \                     ??OSTaskChangePrio_6: (+1)
   \   000000B2   0xF891 0xA000      LDRB     R10,[R1, #+0]
   \   000000B6   0xEA47 0x0A0A      ORR      R10,R7,R10
   \   000000BA   0xF881 0xA000      STRB     R10,[R1, #+0]
    130                   OSRdyTbl[y_new] |= bitx_new;
   \   000000BE   0xF813 0x1009      LDRB     R1,[R3, R9]
   \   000000C2   0xEA4E 0x0101      ORR      R1,LR,R1
   \   000000C6   0xF803 0x1009      STRB     R1,[R3, R9]
    131              }
    132          
    133          #if (OS_EVENT_EN)
    134              pevent = ptcb->OSTCBEventPtr;
   \                     ??OSTaskChangePrio_5: (+1)
   \   000000CA   0xF8D2 0x901C      LDR      R9,[R2, #+28]
    135              if (pevent != (OS_EVENT *)0) {
   \   000000CE   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000D2   0xD01F             BEQ.N    ??OSTaskChangePrio_7
    136                  pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
   \   000000D4   0xEB08 0x0A09      ADD      R10,R8,R9
   \   000000D8   0xEA6F 0x010C      MVN      R1,R12
   \   000000DC   0xF89A 0xB00B      LDRB     R11,[R10, #+11]
   \   000000E0   0xEA11 0x010B      ANDS     R1,R1,R11
   \   000000E4   0xF88A 0x100B      STRB     R1,[R10, #+11]
    137                  if (pevent->OSEventTbl[y_old] == 0) {
   \   000000E8   0xD107             BNE.N    ??OSTaskChangePrio_8
    138                      pevent->OSEventGrp    &= ~bity_old;
   \   000000EA   0xF899 0x100A      LDRB     R1,[R9, #+10]
   \   000000EE   0xF8DD 0xA000      LDR      R10,[SP, #+0]
   \   000000F2   0xEA21 0x010A      BIC      R1,R1,R10
   \   000000F6   0xF889 0x100A      STRB     R1,[R9, #+10]
    139                  }
    140                  pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
   \                     ??OSTaskChangePrio_8: (+1)
   \   000000FA   0xF899 0x100A      LDRB     R1,[R9, #+10]
   \   000000FE   0x4339             ORRS     R1,R7,R1
   \   00000100   0xF889 0x100A      STRB     R1,[R9, #+10]
    141                  pevent->OSEventTbl[y_new] |= bitx_new;
   \   00000104   0xEB03 0x0109      ADD      R1,R3,R9
   \   00000108   0xF891 0x900B      LDRB     R9,[R1, #+11]
   \   0000010C   0xEA4E 0x0909      ORR      R9,LR,R9
   \   00000110   0xF881 0x900B      STRB     R9,[R1, #+11]
    142              }
    143          #if (OS_EVENT_MULTI_EN > 0)
    144              if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
   \                     ??OSTaskChangePrio_7: (+1)
   \   00000114   0x6A12             LDR      R2,[R2, #+32]
   \   00000116   0x2A00             CMP      R2,#+0
   \   00000118   0xD027             BEQ.N    ??OSTaskChangePrio_9
    145                  pevents =  ptcb->OSTCBEventMultiPtr;
    146                  pevent  = *pevents;
   \   0000011A   0xF8D2 0x9000      LDR      R9,[R2, #+0]
   \   0000011E   0xE021             B.N      ??OSTaskChangePrio_10
    147                  while (pevent != (OS_EVENT *)0) {
    148                      pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
   \                     ??OSTaskChangePrio_11: (+1)
   \   00000120   0xEB08 0x0A09      ADD      R10,R8,R9
   \   00000124   0xEA6F 0x010C      MVN      R1,R12
   \   00000128   0xF89A 0xB00B      LDRB     R11,[R10, #+11]
   \   0000012C   0xEA11 0x010B      ANDS     R1,R1,R11
   \   00000130   0xF88A 0x100B      STRB     R1,[R10, #+11]
    149                      if (pevent->OSEventTbl[y_old] == 0) {
   \   00000134   0xD107             BNE.N    ??OSTaskChangePrio_12
    150                          pevent->OSEventGrp    &= ~bity_old;
   \   00000136   0xF899 0x100A      LDRB     R1,[R9, #+10]
   \   0000013A   0xF8DD 0xA000      LDR      R10,[SP, #+0]
   \   0000013E   0xEA21 0x010A      BIC      R1,R1,R10
   \   00000142   0xF889 0x100A      STRB     R1,[R9, #+10]
    151                      }
    152                      pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
   \                     ??OSTaskChangePrio_12: (+1)
   \   00000146   0xF899 0x100A      LDRB     R1,[R9, #+10]
   \   0000014A   0x4339             ORRS     R1,R7,R1
   \   0000014C   0xF889 0x100A      STRB     R1,[R9, #+10]
    153                      pevent->OSEventTbl[y_new] |= bitx_new;
   \   00000150   0xEB03 0x0109      ADD      R1,R3,R9
   \   00000154   0xF891 0x900B      LDRB     R9,[R1, #+11]
   \   00000158   0xEA4E 0x0909      ORR      R9,LR,R9
   \   0000015C   0xF881 0x900B      STRB     R9,[R1, #+11]
    154                      pevents++;
    155                      pevent                     = *pevents;
   \   00000160   0xF852 0x9F04      LDR      R9,[R2, #+4]!
    156                  }
   \                     ??OSTaskChangePrio_10: (+1)
   \   00000164   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000168   0xD1DA             BNE.N    ??OSTaskChangePrio_11
    157              }
    158          #endif
    159          #endif
    160          
    161              ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
   \                     ??OSTaskChangePrio_9: (+1)
   \   0000016A   0x7025             STRB     R5,[R4, #+0]
    162              ptcb->OSTCBY    = y_new;
   \   0000016C   0x70A3             STRB     R3,[R4, #+2]
    163              ptcb->OSTCBX    = x_new;
   \   0000016E   0x7066             STRB     R6,[R4, #+1]
    164              ptcb->OSTCBBitY = bity_new;
   \   00000170   0x7127             STRB     R7,[R4, #+4]
    165              ptcb->OSTCBBitX = bitx_new;
   \   00000172   0xF884 0xE003      STRB     LR,[R4, #+3]
    166              OS_EXIT_CRITICAL();
   \   00000176   0x.... 0x....      BL       OS_CPU_SR_Restore
    167              if (OSRunning == OS_TRUE) {
   \   0000017A   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \   0000017E   0x7800             LDRB     R0,[R0, #+0]
   \   00000180   0x2801             CMP      R0,#+1
   \   00000182   0xD101             BNE.N    ??OSTaskChangePrio_13
    168                  OS_Sched();                                         /* Find new highest priority task          */
   \   00000184   0x.... 0x....      BL       OS_Sched
    169              }
    170              return (OS_ERR_NONE);
   \                     ??OSTaskChangePrio_13: (+1)
   \   00000188   0x2000             MOVS     R0,#+0
   \                     ??OSTaskChangePrio_1: (+1)
   \   0000018A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    171          }
    172          #endif
    173          /*$PAGE*/
    174          /*
    175          *********************************************************************************************************
    176          *                                            CREATE A TASK
    177          *
    178          * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
    179          *              be created prior to the start of multitasking or by a running task.  A task cannot be
    180          *              created by an ISR.
    181          *
    182          * Arguments  : task     is a pointer to the task's code
    183          *
    184          *              p_arg    is a pointer to an optional data area which can be used to pass parameters to
    185          *                       the task when the task first executes.  Where the task is concerned it thinks
    186          *                       it was invoked and passed the argument 'p_arg' as follows:
    187          *
    188          *                           void Task (void *p_arg)
    189          *                           {
    190          *                               for (;;) {
    191          *                                   Task code;
    192          *                               }
    193          *                           }
    194          *
    195          *              ptos     is a pointer to the task's top of stack.  If the configuration constant
    196          *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
    197          *                       memory to low memory).  'pstk' will thus point to the highest (valid) memory
    198          *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pstk' will point to the
    199          *                       lowest memory location of the stack and the stack will grow with increasing
    200          *                       memory locations.
    201          *
    202          *              prio     is the task's priority.  A unique priority MUST be assigned to each task and the
    203          *                       lower the number, the higher the priority.
    204          *
    205          * Returns    : OS_ERR_NONE             if the function was successful.
    206          *              OS_PRIO_EXIT            if the task priority already exist
    207          *                                      (each task MUST have a unique priority).
    208          *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
    209          *                                      (i.e. >= OS_LOWEST_PRIO)
    210          *              OS_ERR_TASK_CREATE_ISR  if you tried to create a task from an ISR.
    211          *********************************************************************************************************
    212          */
    213          
    214          #if OS_TASK_CREATE_EN > 0

   \                                 In section .text, align 2, keep-with-next
    215          INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
    216          {
   \                     OSTaskCreate: (+1)
   \   00000000   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    217              OS_STK    *psp;
    218              INT8U      err;
    219          #if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    220              OS_CPU_SR  cpu_sr = 0;
    221          #endif
    222          
    223          
    224          
    225          #if OS_ARG_CHK_EN > 0
    226              if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
    227                  return (OS_ERR_PRIO_INVALID);
    228              }
    229          #endif
    230              OS_ENTER_CRITICAL();
   \   0000000C   0x.... 0x....      BL       OS_CPU_SR_Save
    231              if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable10_5
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD003             BEQ.N    ??OSTaskCreate_0
    232                  OS_EXIT_CRITICAL();
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Restore
    233                  return (OS_ERR_TASK_CREATE_ISR);
   \   0000001E   0x203C             MOVS     R0,#+60
   \   00000020   0xE031             B.N      ??OSTaskCreate_1
    234              }
    235              if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
   \                     ??OSTaskCreate_0: (+1)
   \   00000022   0x46B8             MOV      R8,R7
   \   00000024   0x.... 0x....      LDR.W    R9,??DataTable10
   \   00000028   0xF859 0x1028      LDR      R1,[R9, R8, LSL #+2]
   \   0000002C   0x2900             CMP      R1,#+0
   \   0000002E   0xD127             BNE.N    ??OSTaskCreate_2
    236                  OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0xF849 0x1028      STR      R1,[R9, R8, LSL #+2]
    237                                                       /* ... the same thing until task is created.              */
    238                  OS_EXIT_CRITICAL();
   \   00000036   0x.... 0x....      BL       OS_CPU_SR_Restore
    239                  psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
   \   0000003A   0x2300             MOVS     R3,#+0
   \   0000003C   0x4632             MOV      R2,R6
   \   0000003E   0x4629             MOV      R1,R5
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       OSTaskStkInit
   \   00000046   0x4601             MOV      R1,R0
    240                  err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x9002             STR      R0,[SP, #+8]
   \   0000004C   0x9001             STR      R0,[SP, #+4]
   \   0000004E   0x9000             STR      R0,[SP, #+0]
   \   00000050   0x4603             MOV      R3,R0
   \   00000052   0x4602             MOV      R2,R0
   \   00000054   0x4638             MOV      R0,R7
   \   00000056   0x.... 0x....      BL       OS_TCBInit
   \   0000005A   0x0004             MOVS     R4,R0
    241                  if (err == OS_ERR_NONE) {
   \   0000005C   0xD107             BNE.N    ??OSTaskCreate_3
    242                      if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \   00000062   0x7800             LDRB     R0,[R0, #+0]
   \   00000064   0x2801             CMP      R0,#+1
   \   00000066   0xD109             BNE.N    ??OSTaskCreate_4
    243                          OS_Sched();
   \   00000068   0x.... 0x....      BL       OS_Sched
   \   0000006C   0xE006             B.N      ??OSTaskCreate_4
    244                      }
    245                  } else {
    246                      OS_ENTER_CRITICAL();
   \                     ??OSTaskCreate_3: (+1)
   \   0000006E   0x.... 0x....      BL       OS_CPU_SR_Save
    247                      OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
   \   00000072   0x2100             MOVS     R1,#+0
   \   00000074   0xF849 0x1028      STR      R1,[R9, R8, LSL #+2]
    248                      OS_EXIT_CRITICAL();
   \   00000078   0x.... 0x....      BL       OS_CPU_SR_Restore
    249                  }
    250                  return (err);
   \                     ??OSTaskCreate_4: (+1)
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0xE002             B.N      ??OSTaskCreate_1
    251              }
    252              OS_EXIT_CRITICAL();
   \                     ??OSTaskCreate_2: (+1)
   \   00000080   0x.... 0x....      BL       OS_CPU_SR_Restore
    253              return (OS_ERR_PRIO_EXIST);
   \   00000084   0x2028             MOVS     R0,#+40
   \                     ??OSTaskCreate_1: (+1)
   \   00000086   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
    254          }
    255          #endif
    256          /*$PAGE*/
    257          /*
    258          *********************************************************************************************************
    259          *                                     CREATE A TASK (Extended Version)
    260          *
    261          * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
    262          *              be created prior to the start of multitasking or by a running task.  A task cannot be
    263          *              created by an ISR.  This function is similar to OSTaskCreate() except that it allows
    264          *              additional information about a task to be specified.
    265          *
    266          * Arguments  : task      is a pointer to the task's code
    267          *
    268          *              p_arg     is a pointer to an optional data area which can be used to pass parameters to
    269          *                        the task when the task first executes.  Where the task is concerned it thinks
    270          *                        it was invoked and passed the argument 'p_arg' as follows:
    271          *
    272          *                            void Task (void *p_arg)
    273          *                            {
    274          *                                for (;;) {
    275          *                                    Task code;
    276          *                                }
    277          *                            }
    278          *
    279          *              ptos      is a pointer to the task's top of stack.  If the configuration constant
    280          *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
    281          *                        memory to low memory).  'ptos' will thus point to the highest (valid) memory
    282          *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'ptos' will point to the
    283          *                        lowest memory location of the stack and the stack will grow with increasing
    284          *                        memory locations.  'ptos' MUST point to a valid 'free' data item.
    285          *
    286          *              prio      is the task's priority.  A unique priority MUST be assigned to each task and the
    287          *                        lower the number, the higher the priority.
    288          *
    289          *              id        is the task's ID (0..65535)
    290          *
    291          *              pbos      is a pointer to the task's bottom of stack.  If the configuration constant
    292          *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
    293          *                        memory to low memory).  'pbos' will thus point to the LOWEST (valid) memory
    294          *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
    295          *                        HIGHEST memory location of the stack and the stack will grow with increasing
    296          *                        memory locations.  'pbos' MUST point to a valid 'free' data item.
    297          *
    298          *              stk_size  is the size of the stack in number of elements.  If OS_STK is set to INT8U,
    299          *                        'stk_size' corresponds to the number of bytes available.  If OS_STK is set to
    300          *                        INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
    301          *                        OS_STK is set to INT32U, 'stk_size' contains the number of 32-bit entries
    302          *                        available on the stack.
    303          *
    304          *              pext      is a pointer to a user supplied memory location which is used as a TCB extension.
    305          *                        For example, this user memory can hold the contents of floating-point registers
    306          *                        during a context switch, the time each task takes to execute, the number of times
    307          *                        the task has been switched-in, etc.
    308          *
    309          *              opt       contains additional information (or options) about the behavior of the task.  The
    310          *                        LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
    311          *                        specific.  See OS_TASK_OPT_??? in uCOS-II.H.  Current choices are:
    312          *
    313          *                        OS_TASK_OPT_STK_CHK      Stack checking to be allowed for the task
    314          *                        OS_TASK_OPT_STK_CLR      Clear the stack when the task is created
    315          *                        OS_TASK_OPT_SAVE_FP      If the CPU has floating-point registers, save them
    316          *                                                 during a context switch.
    317          *
    318          * Returns    : OS_ERR_NONE             if the function was successful.
    319          *              OS_PRIO_EXIT            if the task priority already exist
    320          *                                      (each task MUST have a unique priority).
    321          *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
    322          *                                      (i.e. > OS_LOWEST_PRIO)
    323          *              OS_ERR_TASK_CREATE_ISR  if you tried to create a task from an ISR.
    324          *********************************************************************************************************
    325          */
    326          /*$PAGE*/
    327          #if OS_TASK_CREATE_EXT_EN > 0

   \                                 In section .text, align 2, keep-with-next
    328          INT8U  OSTaskCreateExt (void   (*task)(void *p_arg),
    329                                  void    *p_arg,
    330                                  OS_STK  *ptos,
    331                                  INT8U    prio,
    332                                  INT16U   id,
    333                                  OS_STK  *pbos,
    334                                  INT32U   stk_size,
    335                                  void    *pext,
    336                                  INT16U   opt)
    337          {
   \                     OSTaskCreateExt: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x4699             MOV      R9,R3
    338              OS_STK    *psp;
    339              INT8U      err;
    340          #if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    341              OS_CPU_SR  cpu_sr = 0;
    342          #endif
    343          
    344          
    345          
    346          #if OS_ARG_CHK_EN > 0
    347              if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
    348                  return (OS_ERR_PRIO_INVALID);
    349              }
    350          #endif
    351              OS_ENTER_CRITICAL();
   \   0000000C   0x.... 0x....      BL       OS_CPU_SR_Save
    352              if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable10_5
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD003             BEQ.N    ??OSTaskCreateExt_0
    353                  OS_EXIT_CRITICAL();
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Restore
    354                  return (OS_ERR_TASK_CREATE_ISR);
   \   0000001E   0x203C             MOVS     R0,#+60
   \   00000020   0xE03C             B.N      ??OSTaskCreateExt_1
    355              }
    356              if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
   \                     ??OSTaskCreateExt_0: (+1)
   \   00000022   0x464D             MOV      R5,R9
   \   00000024   0x.... 0x....      LDR.W    R6,??DataTable10
   \   00000028   0xF856 0x1025      LDR      R1,[R6, R5, LSL #+2]
   \   0000002C   0x2900             CMP      R1,#+0
   \   0000002E   0xD132             BNE.N    ??OSTaskCreateExt_2
    357                  OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0xF846 0x1025      STR      R1,[R6, R5, LSL #+2]
    358                                                       /* ... the same thing until task is created.              */
    359                  OS_EXIT_CRITICAL();
   \   00000036   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   0000003A   0xF8DD 0xA03C      LDR      R10,[SP, #+60]
   \   0000003E   0xF8DD 0xB040      LDR      R11,[SP, #+64]
   \   00000042   0x9C12             LDR      R4,[SP, #+72]
    360          
    361          #if (OS_TASK_STAT_STK_CHK_EN > 0)
    362                  OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
   \   00000044   0x4622             MOV      R2,R4
   \   00000046   0x4659             MOV      R1,R11
   \   00000048   0x4650             MOV      R0,R10
   \   0000004A   0x.... 0x....      BL       OS_TaskStkClr
    363          #endif
    364          
    365                  psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
   \   0000004E   0x4623             MOV      R3,R4
   \   00000050   0x4642             MOV      R2,R8
   \   00000052   0x4639             MOV      R1,R7
   \   00000054   0x9804             LDR      R0,[SP, #+16]
   \   00000056   0x.... 0x....      BL       OSTaskStkInit
   \   0000005A   0x4601             MOV      R1,R0
    366                  err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
   \   0000005C   0x9402             STR      R4,[SP, #+8]
   \   0000005E   0x9811             LDR      R0,[SP, #+68]
   \   00000060   0x9001             STR      R0,[SP, #+4]
   \   00000062   0xF8CD 0xB000      STR      R11,[SP, #+0]
   \   00000066   0x9B0E             LDR      R3,[SP, #+56]
   \   00000068   0x4652             MOV      R2,R10
   \   0000006A   0x4648             MOV      R0,R9
   \   0000006C   0x.... 0x....      BL       OS_TCBInit
   \   00000070   0x0004             MOVS     R4,R0
    367                  if (err == OS_ERR_NONE) {
   \   00000072   0xD107             BNE.N    ??OSTaskCreateExt_3
    368                      if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \   00000078   0x7800             LDRB     R0,[R0, #+0]
   \   0000007A   0x2801             CMP      R0,#+1
   \   0000007C   0xD109             BNE.N    ??OSTaskCreateExt_4
    369                          OS_Sched();
   \   0000007E   0x.... 0x....      BL       OS_Sched
   \   00000082   0xE006             B.N      ??OSTaskCreateExt_4
    370                      }
    371                  } else {
    372                      OS_ENTER_CRITICAL();
   \                     ??OSTaskCreateExt_3: (+1)
   \   00000084   0x.... 0x....      BL       OS_CPU_SR_Save
    373                      OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
   \   00000088   0x2100             MOVS     R1,#+0
   \   0000008A   0xF846 0x1025      STR      R1,[R6, R5, LSL #+2]
    374                      OS_EXIT_CRITICAL();
   \   0000008E   0x.... 0x....      BL       OS_CPU_SR_Restore
    375                  }
    376                  return (err);
   \                     ??OSTaskCreateExt_4: (+1)
   \   00000092   0x4620             MOV      R0,R4
   \   00000094   0xE002             B.N      ??OSTaskCreateExt_1
    377              }
    378              OS_EXIT_CRITICAL();
   \                     ??OSTaskCreateExt_2: (+1)
   \   00000096   0x.... 0x....      BL       OS_CPU_SR_Restore
    379              return (OS_ERR_PRIO_EXIST);
   \   0000009A   0x2028             MOVS     R0,#+40
   \                     ??OSTaskCreateExt_1: (+1)
   \   0000009C   0xB005             ADD      SP,SP,#+20
   \   0000009E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    380          }
    381          #endif
    382          /*$PAGE*/
    383          /*
    384          *********************************************************************************************************
    385          *                                            DELETE A TASK
    386          *
    387          * Description: This function allows you to delete a task.  The calling task can delete itself by
    388          *              its own priority number.  The deleted task is returned to the dormant state and can be
    389          *              re-activated by creating the deleted task again.
    390          *
    391          * Arguments  : prio    is the priority of the task to delete.  Note that you can explicitely delete
    392          *                      the current task without knowing its priority level by setting 'prio' to
    393          *                      OS_PRIO_SELF.
    394          *
    395          * Returns    : OS_ERR_NONE             if the call is successful
    396          *              OS_ERR_TASK_DEL_IDLE    if you attempted to delete uC/OS-II's idle task
    397          *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
    398          *                                      (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
    399          *              OS_ERR_TASK_DEL         if the task is assigned to a Mutex PIP.   
    400          *              OS_ERR_TASK_NOT_EXIST   if the task you want to delete does not exist.
    401          *              OS_ERR_TASK_DEL_ISR     if you tried to delete a task from an ISR
    402          *
    403          * Notes      : 1) To reduce interrupt latency, OSTaskDel() 'disables' the task:
    404          *                    a) by making it not ready
    405          *                    b) by removing it from any wait lists
    406          *                    c) by preventing OSTimeTick() from making the task ready to run.
    407          *                 The task can then be 'unlinked' from the miscellaneous structures in uC/OS-II.
    408          *              2) The function OS_Dummy() is called after OS_EXIT_CRITICAL() because, on most processors,
    409          *                 the next instruction following the enable interrupt instruction is ignored.
    410          *              3) An ISR cannot delete a task.
    411          *              4) The lock nesting counter is incremented because, for a brief instant, if the current
    412          *                 task is being deleted, the current task would not be able to be rescheduled because it
    413          *                 is removed from the ready list.  Incrementing the nesting counter prevents another task
    414          *                 from being schedule.  This means that an ISR would return to the current task which is
    415          *                 being deleted.  The rest of the deletion would thus be able to be completed.
    416          *********************************************************************************************************
    417          */
    418          
    419          #if OS_TASK_DEL_EN > 0

   \                                 In section .text, align 2, keep-with-next
    420          INT8U  OSTaskDel (INT8U prio)
    421          {
   \                     OSTaskDel: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4680             MOV      R8,R0
    422          #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    423              OS_FLAG_NODE *pnode;
    424          #endif
    425              OS_TCB       *ptcb;
    426          #if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    427              OS_CPU_SR     cpu_sr = 0;
    428          #endif
    429          
    430          
    431          
    432              if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD001             BEQ.N    ??OSTaskDel_0
    433                  return (OS_ERR_TASK_DEL_ISR);
   \   00000010   0x2040             MOVS     R0,#+64
   \   00000012   0xE08B             B.N      ??OSTaskDel_1
    434              }
    435              if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
   \                     ??OSTaskDel_0: (+1)
   \   00000014   0xF1B8 0x0F1F      CMP      R8,#+31
   \   00000018   0xD101             BNE.N    ??OSTaskDel_2
    436                  return (OS_ERR_TASK_DEL_IDLE);
   \   0000001A   0x203E             MOVS     R0,#+62
   \   0000001C   0xE086             B.N      ??OSTaskDel_1
    437              }
    438          #if OS_ARG_CHK_EN > 0
    439              if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
    440                  if (prio != OS_PRIO_SELF) {
    441                      return (OS_ERR_PRIO_INVALID);
    442                  }
    443              }
    444          #endif
    445          
    446          /*$PAGE*/
    447              OS_ENTER_CRITICAL();
   \                     ??OSTaskDel_2: (+1)
   \   0000001E   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000022   0x4604             MOV      R4,R0
    448              if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
   \   00000024   0xF1B8 0x0FFF      CMP      R8,#+255
   \   00000028   0xD104             BNE.N    ??OSTaskDel_3
    449                  prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF890 0x8032      LDRB     R8,[R0, #+50]
    450              }
    451              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskDel_3: (+1)
   \   00000034   0x.... 0x....      LDR.W    R5,??DataTable10
   \   00000038   0xF855 0x6028      LDR      R6,[R5, R8, LSL #+2]
    452              if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
   \   0000003C   0x2E00             CMP      R6,#+0
   \   0000003E   0xD104             BNE.N    ??OSTaskDel_4
    453                  OS_EXIT_CRITICAL();
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       OS_CPU_SR_Restore
    454                  return (OS_ERR_TASK_NOT_EXIST);
   \   00000046   0x2043             MOVS     R0,#+67
   \   00000048   0xE070             B.N      ??OSTaskDel_1
    455              }
    456              if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
   \                     ??OSTaskDel_4: (+1)
   \   0000004A   0x2E01             CMP      R6,#+1
   \   0000004C   0xD104             BNE.N    ??OSTaskDel_5
    457                  OS_EXIT_CRITICAL();
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       OS_CPU_SR_Restore
    458                  return (OS_ERR_TASK_DEL);
   \   00000054   0x203D             MOVS     R0,#+61
   \   00000056   0xE069             B.N      ??OSTaskDel_1
    459              }
    460          
    461              OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
   \                     ??OSTaskDel_5: (+1)
   \   00000058   0xF106 0x0730      ADD      R7,R6,#+48
   \   0000005C   0x7938             LDRB     R0,[R7, #+4]
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   00000062   0x5C42             LDRB     R2,[R0, R1]
   \   00000064   0x797B             LDRB     R3,[R7, #+5]
   \   00000066   0x439A             BICS     R2,R2,R3
   \   00000068   0x5442             STRB     R2,[R0, R1]
    462              if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
   \   0000006A   0x7938             LDRB     R0,[R7, #+4]
   \   0000006C   0x5C40             LDRB     R0,[R0, R1]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD105             BNE.N    ??OSTaskDel_6
    463                  OSRdyGrp           &= ~ptcb->OSTCBBitY;
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   00000076   0x7801             LDRB     R1,[R0, #+0]
   \   00000078   0x79BA             LDRB     R2,[R7, #+6]
   \   0000007A   0x4391             BICS     R1,R1,R2
   \   0000007C   0x7001             STRB     R1,[R0, #+0]
    464              }
    465              
    466          #if (OS_EVENT_EN)
    467              if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
   \                     ??OSTaskDel_6: (+1)
   \   0000007E   0x69F1             LDR      R1,[R6, #+28]
   \   00000080   0x2900             CMP      R1,#+0
   \   00000082   0xD002             BEQ.N    ??OSTaskDel_7
    468                  OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
   \   00000084   0x4630             MOV      R0,R6
   \   00000086   0x.... 0x....      BL       OS_EventTaskRemove
    469              }
    470          #if (OS_EVENT_MULTI_EN > 0)
    471              if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
   \                     ??OSTaskDel_7: (+1)
   \   0000008A   0x6A31             LDR      R1,[R6, #+32]
   \   0000008C   0x2900             CMP      R1,#+0
   \   0000008E   0xD002             BEQ.N    ??OSTaskDel_8
    472                  OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
   \   00000090   0x4630             MOV      R0,R6
   \   00000092   0x.... 0x....      BL       OS_EventTaskRemoveMulti
    473              }
    474          #endif
    475          #endif
    476          
    477          #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    478              pnode = ptcb->OSTCBFlagNode;
   \                     ??OSTaskDel_8: (+1)
   \   00000096   0x6AB0             LDR      R0,[R6, #+40]
    479              if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD001             BEQ.N    ??OSTaskDel_9
    480                  OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
   \   0000009C   0x.... 0x....      BL       OS_FlagUnlink
    481              }
    482          #endif
    483          
    484              ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
   \                     ??OSTaskDel_9: (+1)
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x85F0             STRH     R0,[R6, #+46]
    485              ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
   \   000000A4   0x7038             STRB     R0,[R7, #+0]
    486              ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
   \   000000A6   0x7078             STRB     R0,[R7, #+1]
    487              if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
   \   000000A8   0x.... 0x....      LDR.W    R9,??DataTable10_6
   \   000000AC   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   000000B0   0x28FF             CMP      R0,#+255
   \   000000B2   0xD002             BEQ.N    ??OSTaskDel_10
    488                  OSLockNesting++;
   \   000000B4   0x1C40             ADDS     R0,R0,#+1
   \   000000B6   0xF889 0x0000      STRB     R0,[R9, #+0]
    489              }
    490              OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
   \                     ??OSTaskDel_10: (+1)
   \   000000BA   0x4620             MOV      R0,R4
   \   000000BC   0x.... 0x....      BL       OS_CPU_SR_Restore
    491              OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
   \   000000C0   0x.... 0x....      BL       OS_Dummy
    492              OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
   \   000000C4   0x.... 0x....      BL       OS_CPU_SR_Save
   \   000000C8   0x4604             MOV      R4,R0
    493              if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
   \   000000CA   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD002             BEQ.N    ??OSTaskDel_11
    494                  OSLockNesting--;
   \   000000D2   0x1E40             SUBS     R0,R0,#+1
   \   000000D4   0xF889 0x0000      STRB     R0,[R9, #+0]
    495              }
    496              OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
   \                     ??OSTaskDel_11: (+1)
   \   000000D8   0x4630             MOV      R0,R6
   \   000000DA   0x.... 0x....      BL       OSTaskDelHook
    497              OSTaskCtr--;                                        /* One less task being managed                 */
   \   000000DE   0x....             LDR.N    R0,??DataTable10_7
   \   000000E0   0x7801             LDRB     R1,[R0, #+0]
   \   000000E2   0x1E49             SUBS     R1,R1,#+1
   \   000000E4   0x7001             STRB     R1,[R0, #+0]
    498              OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0xF845 0x0028      STR      R0,[R5, R8, LSL #+2]
    499              if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
   \   000000EC   0x6970             LDR      R0,[R6, #+20]
   \   000000EE   0x69B1             LDR      R1,[R6, #+24]
   \   000000F0   0x2900             CMP      R1,#+0
   \   000000F2   0xD105             BNE.N    ??OSTaskDel_12
    500                  ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
   \   000000F4   0x2100             MOVS     R1,#+0
   \   000000F6   0x6181             STR      R1,[R0, #+24]
    501                  OSTCBList                  = ptcb->OSTCBNext;
   \   000000F8   0x6970             LDR      R0,[R6, #+20]
   \   000000FA   0x....             LDR.N    R1,??DataTable10_8
   \   000000FC   0x6008             STR      R0,[R1, #+0]
   \   000000FE   0xE003             B.N      ??OSTaskDel_13
    502              } else {
    503                  ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
   \                     ??OSTaskDel_12: (+1)
   \   00000100   0x6148             STR      R0,[R1, #+20]
    504                  ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
   \   00000102   0x69B0             LDR      R0,[R6, #+24]
   \   00000104   0x6971             LDR      R1,[R6, #+20]
   \   00000106   0x6188             STR      R0,[R1, #+24]
    505              }
    506              ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
   \                     ??OSTaskDel_13: (+1)
   \   00000108   0x....             LDR.N    R0,??DataTable10_9
   \   0000010A   0x6801             LDR      R1,[R0, #+0]
   \   0000010C   0x6171             STR      R1,[R6, #+20]
    507              OSTCBFreeList     = ptcb;
   \   0000010E   0x6006             STR      R6,[R0, #+0]
    508          #if OS_TASK_NAME_SIZE > 1
    509              ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
   \   00000110   0x203F             MOVS     R0,#+63
   \   00000112   0x7738             STRB     R0,[R7, #+28]
    510              ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
   \   00000114   0x2000             MOVS     R0,#+0
   \   00000116   0x7778             STRB     R0,[R7, #+29]
    511          #endif
    512              OS_EXIT_CRITICAL();
   \   00000118   0x4620             MOV      R0,R4
   \   0000011A   0x.... 0x....      BL       OS_CPU_SR_Restore
    513              if (OSRunning == OS_TRUE) {
   \   0000011E   0x....             LDR.N    R0,??DataTable10_4
   \   00000120   0x7800             LDRB     R0,[R0, #+0]
   \   00000122   0x2801             CMP      R0,#+1
   \   00000124   0xD101             BNE.N    ??OSTaskDel_14
    514                  OS_Sched();                                     /* Find new highest priority task              */
   \   00000126   0x.... 0x....      BL       OS_Sched
    515              }
    516              return (OS_ERR_NONE);
   \                     ??OSTaskDel_14: (+1)
   \   0000012A   0x2000             MOVS     R0,#+0
   \                     ??OSTaskDel_1: (+1)
   \   0000012C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    517          }
    518          #endif
    519          /*$PAGE*/
    520          /*
    521          *********************************************************************************************************
    522          *                                    REQUEST THAT A TASK DELETE ITSELF
    523          *
    524          * Description: This function is used to:
    525          *                   a) notify a task to delete itself.
    526          *                   b) to see if a task requested that the current task delete itself.
    527          *              This function is a little tricky to understand.  Basically, you have a task that needs
    528          *              to be deleted however, this task has resources that it has allocated (memory buffers,
    529          *              semaphores, mailboxes, queues etc.).  The task cannot be deleted otherwise these
    530          *              resources would not be freed.  The requesting task calls OSTaskDelReq() to indicate that
    531          *              the task needs to be deleted.  Deleting of the task is however, deferred to the task to
    532          *              be deleted.  For example, suppose that task #10 needs to be deleted.  The requesting task
    533          *              example, task #5, would call OSTaskDelReq(10).  When task #10 gets to execute, it calls
    534          *              this function by specifying OS_PRIO_SELF and monitors the returned value.  If the return
    535          *              value is OS_ERR_TASK_DEL_REQ, another task requested a task delete.  Task #10 would look like
    536          *              this:
    537          *
    538          *                   void Task(void *p_arg)
    539          *                   {
    540          *                       .
    541          *                       .
    542          *                       while (1) {
    543          *                           OSTimeDly(1);
    544          *                           if (OSTaskDelReq(OS_PRIO_SELF) == OS_ERR_TASK_DEL_REQ) {
    545          *                               Release any owned resources;
    546          *                               De-allocate any dynamic memory;
    547          *                               OSTaskDel(OS_PRIO_SELF);
    548          *                           }
    549          *                       }
    550          *                   }
    551          *
    552          * Arguments  : prio    is the priority of the task to request the delete from
    553          *
    554          * Returns    : OS_ERR_NONE            if the task exist and the request has been registered
    555          *              OS_ERR_TASK_NOT_EXIST  if the task has been deleted.  This allows the caller to know whether
    556          *                                     the request has been executed.
    557          *              OS_ERR_TASK_DEL        if the task is assigned to a Mutex.
    558          *              OS_ERR_TASK_DEL_IDLE   if you requested to delete uC/OS-II's idle task
    559          *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
    560          *                                     (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
    561          *              OS_ERR_TASK_DEL_REQ    if a task (possibly another task) requested that the running task be
    562          *                                     deleted.
    563          *********************************************************************************************************
    564          */
    565          /*$PAGE*/
    566          #if OS_TASK_DEL_EN > 0

   \                                 In section .text, align 2, keep-with-next
    567          INT8U  OSTaskDelReq (INT8U prio)
    568          {
   \                     OSTaskDelReq: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    569              INT8U      stat;
    570              OS_TCB    *ptcb;
    571          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    572              OS_CPU_SR  cpu_sr = 0;
    573          #endif
    574          
    575          
    576          
    577              if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x2C1F             CMP      R4,#+31
   \   00000006   0xD101             BNE.N    ??OSTaskDelReq_0
    578                  return (OS_ERR_TASK_DEL_IDLE);
   \   00000008   0x203E             MOVS     R0,#+62
   \   0000000A   0xBD10             POP      {R4,PC}
    579              }
    580          #if OS_ARG_CHK_EN > 0
    581              if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
    582                  if (prio != OS_PRIO_SELF) {
    583                      return (OS_ERR_PRIO_INVALID);
    584                  }
    585              }
    586          #endif
    587              if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
   \                     ??OSTaskDelReq_0: (+1)
   \   0000000C   0x28FF             CMP      R0,#+255
   \   0000000E   0xD109             BNE.N    ??OSTaskDelReq_1
    588                  OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
   \   00000010   0x.... 0x....      BL       OS_CPU_SR_Save
    589                  stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
   \   00000014   0x....             LDR.N    R1,??DataTable10_1
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0xF891 0x4037      LDRB     R4,[R1, #+55]
    590                  OS_EXIT_CRITICAL();
   \   0000001C   0x.... 0x....      BL       OS_CPU_SR_Restore
    591                  return (stat);
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0xBD10             POP      {R4,PC}
    592              }
    593              OS_ENTER_CRITICAL();
   \                     ??OSTaskDelReq_1: (+1)
   \   00000024   0x.... 0x....      BL       OS_CPU_SR_Save
    594              ptcb = OSTCBPrioTbl[prio];
   \   00000028   0x....             LDR.N    R1,??DataTable10
   \   0000002A   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
    595              if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
   \   0000002E   0x2900             CMP      R1,#+0
   \   00000030   0xD103             BNE.N    ??OSTaskDelReq_2
    596                  OS_EXIT_CRITICAL();
   \   00000032   0x.... 0x....      BL       OS_CPU_SR_Restore
    597                  return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
   \   00000036   0x2043             MOVS     R0,#+67
   \   00000038   0xBD10             POP      {R4,PC}
    598              }
    599              if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
   \                     ??OSTaskDelReq_2: (+1)
   \   0000003A   0x2901             CMP      R1,#+1
   \   0000003C   0xD103             BNE.N    ??OSTaskDelReq_3
    600                  OS_EXIT_CRITICAL();
   \   0000003E   0x.... 0x....      BL       OS_CPU_SR_Restore
    601                  return (OS_ERR_TASK_DEL);
   \   00000042   0x203D             MOVS     R0,#+61
   \   00000044   0xBD10             POP      {R4,PC}
    602              }
    603              ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
   \                     ??OSTaskDelReq_3: (+1)
   \   00000046   0x223F             MOVS     R2,#+63
   \   00000048   0xF881 0x2037      STRB     R2,[R1, #+55]
    604              OS_EXIT_CRITICAL();
   \   0000004C   0x.... 0x....      BL       OS_CPU_SR_Restore
    605              return (OS_ERR_NONE);
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
    606          }
    607          #endif
    608          /*$PAGE*/
    609          /*
    610          *********************************************************************************************************
    611          *                                        GET THE NAME OF A TASK
    612          *
    613          * Description: This function is called to obtain the name of a task.
    614          *
    615          * Arguments  : prio      is the priority of the task that you want to obtain the name from.
    616          *
    617          *              pname     is a pointer to an ASCII string that will receive the name of the task.  The
    618          *                        string must be able to hold at least OS_TASK_NAME_SIZE characters.
    619          *
    620          *              perr      is a pointer to an error code that can contain one of the following values:
    621          *
    622          *                        OS_ERR_NONE                if the requested task is resumed
    623          *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
    624          *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
    625          *                                                   A higher value than the idle task or not OS_PRIO_SELF.
    626          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    627          *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
    628          *                        
    629          *
    630          * Returns    : The length of the string or 0 if the task does not exist.
    631          *********************************************************************************************************
    632          */
    633          
    634          #if OS_TASK_NAME_SIZE > 1

   \                                 In section .text, align 2, keep-with-next
    635          INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
    636          {
   \                     OSTaskNameGet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4607             MOV      R7,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4614             MOV      R4,R2
    637              OS_TCB    *ptcb;
    638              INT8U      len;
    639          #if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    640              OS_CPU_SR  cpu_sr = 0;
    641          #endif
    642          
    643          
    644          
    645          #if OS_ARG_CHK_EN > 0
    646              if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
    647                  return (0);
    648              }
    649              if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
    650                  if (prio != OS_PRIO_SELF) {
    651                      *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
    652                      return (0);
    653                  }
    654              }
    655              if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
    656                  *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
    657                  return (0);
    658              }
    659          #endif
    660              if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
   \   00000008   0x....             LDR.N    R0,??DataTable10_5
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??OSTaskNameGet_0
    661                  *perr = OS_ERR_NAME_GET_ISR;
   \   00000010   0x2011             MOVS     R0,#+17
   \   00000012   0x7020             STRB     R0,[R4, #+0]
    662                  return (0);
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBDF2             POP      {R1,R4-R7,PC}
    663              }
    664              OS_ENTER_CRITICAL();
   \                     ??OSTaskNameGet_0: (+1)
   \   00000018   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001C   0x4606             MOV      R6,R0
    665              if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
   \   0000001E   0x2FFF             CMP      R7,#+255
   \   00000020   0xD103             BNE.N    ??OSTaskNameGet_1
    666                  prio = OSTCBCur->OSTCBPrio;
   \   00000022   0x....             LDR.N    R0,??DataTable10_1
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF890 0x7032      LDRB     R7,[R0, #+50]
    667              }
    668              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskNameGet_1: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable10
   \   0000002C   0xF850 0x0027      LDR      R0,[R0, R7, LSL #+2]
    669              if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD001             BEQ.N    ??OSTaskNameGet_2
    670                  OS_EXIT_CRITICAL();                              /* No                                         */
    671                  *perr = OS_ERR_TASK_NOT_EXIST;
    672                  return (0);
    673              }
    674              if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD106             BNE.N    ??OSTaskNameGet_3
    675                  OS_EXIT_CRITICAL();                              /* Yes                                        */
   \                     ??OSTaskNameGet_2: (+1)
   \   00000038   0x4630             MOV      R0,R6
   \   0000003A   0x.... 0x....      BL       OS_CPU_SR_Restore
    676                  *perr = OS_ERR_TASK_NOT_EXIST;
   \   0000003E   0x2043             MOVS     R0,#+67
   \   00000040   0x7020             STRB     R0,[R4, #+0]
    677                  return (0);
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xBDF2             POP      {R1,R4-R7,PC}
    678              }
    679              len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
   \                     ??OSTaskNameGet_3: (+1)
   \   00000046   0xF100 0x014C      ADD      R1,R0,#+76
   \   0000004A   0x4628             MOV      R0,R5
   \   0000004C   0x.... 0x....      BL       OS_StrCopy
   \   00000050   0x4605             MOV      R5,R0
    680              OS_EXIT_CRITICAL();
   \   00000052   0x4630             MOV      R0,R6
   \   00000054   0x.... 0x....      BL       OS_CPU_SR_Restore
    681              *perr = OS_ERR_NONE;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x7020             STRB     R0,[R4, #+0]
    682              return (len);
   \   0000005C   0x4628             MOV      R0,R5
   \   0000005E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    683          }
    684          #endif
    685          
    686          /*$PAGE*/
    687          /*
    688          *********************************************************************************************************
    689          *                                        ASSIGN A NAME TO A TASK
    690          *
    691          * Description: This function is used to set the name of a task.
    692          *
    693          * Arguments  : prio      is the priority of the task that you want the assign a name to.
    694          *
    695          *              pname     is a pointer to an ASCII string that contains the name of the task.  The ASCII
    696          *                        string must be NUL terminated.
    697          *
    698          *              perr       is a pointer to an error code that can contain one of the following values:
    699          *
    700          *                        OS_ERR_NONE                if the requested task is resumed
    701          *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
    702          *                        OS_ERR_TASK_NAME_TOO_LONG  if the name you are giving to the task exceeds the
    703          *                                                   storage capacity of a task name as specified by
    704          *                                                   OS_TASK_NAME_SIZE.
    705          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    706          *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
    707          *                                                   A higher value than the idle task or not OS_PRIO_SELF.
    708          *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
    709          *
    710          * Returns    : None
    711          *********************************************************************************************************
    712          */
    713          #if OS_TASK_NAME_SIZE > 1

   \                                 In section .text, align 2, keep-with-next
    714          void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
    715          {
   \                     OSTaskNameSet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4614             MOV      R4,R2
    716              INT8U      len;
    717              OS_TCB    *ptcb;
    718          #if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    719              OS_CPU_SR  cpu_sr = 0;
    720          #endif
    721          
    722          
    723          
    724          #if OS_ARG_CHK_EN > 0
    725              if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
    726                  return;
    727              }
    728              if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
    729                  if (prio != OS_PRIO_SELF) {
    730                      *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
    731                      return;
    732                  }
    733              }
    734              if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
    735                  *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
    736                  return;
    737              }
    738          #endif
    739              if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
   \   00000008   0x....             LDR.N    R0,??DataTable10_5
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD002             BEQ.N    ??OSTaskNameSet_0
    740                  *perr = OS_ERR_NAME_SET_ISR;
   \   00000010   0x2012             MOVS     R0,#+18
   \   00000012   0x7020             STRB     R0,[R4, #+0]
    741                  return;
   \   00000014   0xBDF1             POP      {R0,R4-R7,PC}
    742              }
    743              OS_ENTER_CRITICAL();
   \                     ??OSTaskNameSet_0: (+1)
   \   00000016   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001A   0x4607             MOV      R7,R0
    744              if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
   \   0000001C   0x2EFF             CMP      R6,#+255
   \   0000001E   0xD103             BNE.N    ??OSTaskNameSet_1
    745                  prio = OSTCBCur->OSTCBPrio;
   \   00000020   0x....             LDR.N    R0,??DataTable10_1
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF890 0x6032      LDRB     R6,[R0, #+50]
    746              }
    747              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskNameSet_1: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable10
   \   0000002A   0xF850 0x6026      LDR      R6,[R0, R6, LSL #+2]
    748              if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
   \   0000002E   0x2E00             CMP      R6,#+0
   \   00000030   0xD001             BEQ.N    ??OSTaskNameSet_2
    749                  OS_EXIT_CRITICAL();                          /* No                                             */
    750                  *perr = OS_ERR_TASK_NOT_EXIST;
    751                  return;
    752              }
    753              if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
   \   00000032   0x2E01             CMP      R6,#+1
   \   00000034   0xD105             BNE.N    ??OSTaskNameSet_3
    754                  OS_EXIT_CRITICAL();                          /* Yes                                            */
   \                     ??OSTaskNameSet_2: (+1)
   \   00000036   0x4638             MOV      R0,R7
   \   00000038   0x.... 0x....      BL       OS_CPU_SR_Restore
    755                  *perr = OS_ERR_TASK_NOT_EXIST;
   \   0000003C   0x2043             MOVS     R0,#+67
   \   0000003E   0x7020             STRB     R0,[R4, #+0]
    756                  return;
   \   00000040   0xBDF1             POP      {R0,R4-R7,PC}
    757              }
    758              len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
    759              if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
   \                     ??OSTaskNameSet_3: (+1)
   \   00000042   0x4628             MOV      R0,R5
   \   00000044   0x.... 0x....      BL       OS_StrLen
   \   00000048   0x2810             CMP      R0,#+16
   \   0000004A   0xDB05             BLT.N    ??OSTaskNameSet_4
    760                  OS_EXIT_CRITICAL();
   \   0000004C   0x4638             MOV      R0,R7
   \   0000004E   0x.... 0x....      BL       OS_CPU_SR_Restore
    761                  *perr = OS_ERR_TASK_NAME_TOO_LONG;
   \   00000052   0x2041             MOVS     R0,#+65
   \   00000054   0x7020             STRB     R0,[R4, #+0]
    762                  return;
   \   00000056   0xBDF1             POP      {R0,R4-R7,PC}
    763              }
    764              (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
   \                     ??OSTaskNameSet_4: (+1)
   \   00000058   0x4629             MOV      R1,R5
   \   0000005A   0xF106 0x004C      ADD      R0,R6,#+76
   \   0000005E   0x.... 0x....      BL       OS_StrCopy
    765              OS_EXIT_CRITICAL();
   \   00000062   0x4638             MOV      R0,R7
   \   00000064   0x.... 0x....      BL       OS_CPU_SR_Restore
    766              *perr = OS_ERR_NONE;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x7020             STRB     R0,[R4, #+0]
    767          }
   \   0000006C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    768          #endif
    769          
    770          /*$PAGE*/
    771          /*
    772          *********************************************************************************************************
    773          *                                        RESUME A SUSPENDED TASK
    774          *
    775          * Description: This function is called to resume a previously suspended task.  This is the only call that
    776          *              will remove an explicit task suspension.
    777          *
    778          * Arguments  : prio     is the priority of the task to resume.
    779          *
    780          * Returns    : OS_ERR_NONE                if the requested task is resumed
    781          *              OS_ERR_PRIO_INVALID        if the priority you specify is higher that the maximum allowed
    782          *                                         (i.e. >= OS_LOWEST_PRIO)
    783          *              OS_ERR_TASK_RESUME_PRIO    if the task to resume does not exist
    784          *              OS_ERR_TASK_NOT_EXIST      if the task is assigned to a Mutex PIP
    785          *              OS_ERR_TASK_NOT_SUSPENDED  if the task to resume has not been suspended
    786          *********************************************************************************************************
    787          */
    788          
    789          #if OS_TASK_SUSPEND_EN > 0

   \                                 In section .text, align 2, keep-with-next
    790          INT8U  OSTaskResume (INT8U prio)
    791          {
   \                     OSTaskResume: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    792              OS_TCB    *ptcb;
    793          #if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    794              OS_CPU_SR  cpu_sr = 0;
    795          #endif
    796          
    797          
    798          
    799          #if OS_ARG_CHK_EN > 0
    800              if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
    801                  return (OS_ERR_PRIO_INVALID);
    802              }
    803          #endif
    804              OS_ENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       OS_CPU_SR_Save
    805              ptcb = OSTCBPrioTbl[prio];
   \   00000008   0x....             LDR.N    R1,??DataTable10
   \   0000000A   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
    806              if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD103             BNE.N    ??OSTaskResume_0
    807                  OS_EXIT_CRITICAL();
   \   00000012   0x.... 0x....      BL       OS_CPU_SR_Restore
    808                  return (OS_ERR_TASK_RESUME_PRIO);
   \   00000016   0x2046             MOVS     R0,#+70
   \   00000018   0xBD10             POP      {R4,PC}
    809              }
    810              if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
   \                     ??OSTaskResume_0: (+1)
   \   0000001A   0x2901             CMP      R1,#+1
   \   0000001C   0xD103             BNE.N    ??OSTaskResume_1
    811                  OS_EXIT_CRITICAL();
   \   0000001E   0x.... 0x....      BL       OS_CPU_SR_Restore
    812                  return (OS_ERR_TASK_NOT_EXIST);
   \   00000022   0x2043             MOVS     R0,#+67
   \   00000024   0xBD10             POP      {R4,PC}
    813              }
    814              if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
   \                     ??OSTaskResume_1: (+1)
   \   00000026   0x312E             ADDS     R1,R1,#+46
   \   00000028   0x788A             LDRB     R2,[R1, #+2]
   \   0000002A   0x0713             LSLS     R3,R2,#+28
   \   0000002C   0xD51E             BPL.N    ??OSTaskResume_2
    815                  ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
   \   0000002E   0xF012 0x02F7      ANDS     R2,R2,#0xF7
   \   00000032   0x708A             STRB     R2,[R1, #+2]
    816                  if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
   \   00000034   0xD116             BNE.N    ??OSTaskResume_3
    817                      if (ptcb->OSTCBDly == 0) {
   \   00000036   0x880A             LDRH     R2,[R1, #+0]
   \   00000038   0x2A00             CMP      R2,#+0
   \   0000003A   0xD113             BNE.N    ??OSTaskResume_3
    818                          OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
   \   0000003C   0x....             LDR.N    R2,??DataTable10_3
   \   0000003E   0x7813             LDRB     R3,[R2, #+0]
   \   00000040   0x7A0C             LDRB     R4,[R1, #+8]
   \   00000042   0x4323             ORRS     R3,R4,R3
   \   00000044   0x7013             STRB     R3,[R2, #+0]
   \   00000046   0x798A             LDRB     R2,[R1, #+6]
   \   00000048   0x....             LDR.N    R3,??DataTable10_2
   \   0000004A   0x5CD4             LDRB     R4,[R2, R3]
   \   0000004C   0x79C9             LDRB     R1,[R1, #+7]
   \   0000004E   0x4321             ORRS     R1,R1,R4
   \   00000050   0x54D1             STRB     R1,[R2, R3]
    819                          OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
    820                          OS_EXIT_CRITICAL();
   \   00000052   0x.... 0x....      BL       OS_CPU_SR_Restore
    821                          if (OSRunning == OS_TRUE) {
   \   00000056   0x....             LDR.N    R0,??DataTable10_4
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x2801             CMP      R0,#+1
   \   0000005C   0xD104             BNE.N    ??OSTaskResume_4
    822                              OS_Sched();                               /* Find new highest priority task        */
   \   0000005E   0x.... 0x....      BL       OS_Sched
   \   00000062   0xE001             B.N      ??OSTaskResume_4
    823                          }
    824                      } else {
    825                          OS_EXIT_CRITICAL();
    826                      }
    827                  } else {                                              /* Must be pending on event              */
    828                      OS_EXIT_CRITICAL();
   \                     ??OSTaskResume_3: (+1)
   \   00000064   0x.... 0x....      BL       OS_CPU_SR_Restore
    829                  }
    830                  return (OS_ERR_NONE);
   \                     ??OSTaskResume_4: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xBD10             POP      {R4,PC}
    831              }
    832              OS_EXIT_CRITICAL();
   \                     ??OSTaskResume_2: (+1)
   \   0000006C   0x.... 0x....      BL       OS_CPU_SR_Restore
    833              return (OS_ERR_TASK_NOT_SUSPENDED);
   \   00000070   0x2044             MOVS     R0,#+68
   \   00000072   0xBD10             POP      {R4,PC}          ;; return
    834          }
    835          #endif
    836          /*$PAGE*/
    837          /*
    838          *********************************************************************************************************
    839          *                                             STACK CHECKING
    840          *
    841          * Description: This function is called to check the amount of free memory left on the specified task's
    842          *              stack.
    843          *
    844          * Arguments  : prio          is the task priority
    845          *
    846          *              p_stk_data    is a pointer to a data structure of type OS_STK_DATA.
    847          *
    848          * Returns    : OS_ERR_NONE            upon success
    849          *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
    850          *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
    851          *              OS_ERR_TASK_NOT_EXIST  if the desired task has not been created or is assigned to a Mutex PIP
    852          *              OS_ERR_TASK_OPT        if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
    853          *              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
    854          *********************************************************************************************************
    855          */
    856          #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)

   \                                 In section .text, align 2, keep-with-next
    857          INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
    858          {
   \                     OSTaskStkChk: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
    859              OS_TCB    *ptcb;
    860              OS_STK    *pchk;
    861              INT32U     nfree;
    862              INT32U     size;
    863          #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    864              OS_CPU_SR  cpu_sr = 0;
    865          #endif
    866          
    867          
    868          
    869          #if OS_ARG_CHK_EN > 0
    870              if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
    871                  if (prio != OS_PRIO_SELF) {
    872                      return (OS_ERR_PRIO_INVALID);
    873                  }
    874              }
    875              if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
    876                  return (OS_ERR_PDATA_NULL);
    877              }
    878          #endif
    879              p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x6020             STR      R0,[R4, #+0]
    880              p_stk_data->OSUsed = 0;
   \   0000000A   0x6060             STR      R0,[R4, #+4]
    881              OS_ENTER_CRITICAL();
   \   0000000C   0x.... 0x....      BL       OS_CPU_SR_Save
    882              if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
   \   00000010   0x2DFF             CMP      R5,#+255
   \   00000012   0xD103             BNE.N    ??OSTaskStkChk_0
    883                  prio = OSTCBCur->OSTCBPrio;
   \   00000014   0x....             LDR.N    R1,??DataTable10_1
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0xF891 0x5032      LDRB     R5,[R1, #+50]
    884              }
    885              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskStkChk_0: (+1)
   \   0000001C   0x....             LDR.N    R1,??DataTable10
   \   0000001E   0xF851 0x1025      LDR      R1,[R1, R5, LSL #+2]
    886              if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xD001             BEQ.N    ??OSTaskStkChk_1
    887                  OS_EXIT_CRITICAL();
    888                  return (OS_ERR_TASK_NOT_EXIST);
    889              }
    890              if (ptcb == OS_TCB_RESERVED) {
   \   00000026   0x2901             CMP      R1,#+1
   \   00000028   0xD103             BNE.N    ??OSTaskStkChk_2
    891                  OS_EXIT_CRITICAL();
   \                     ??OSTaskStkChk_1: (+1)
   \   0000002A   0x.... 0x....      BL       OS_CPU_SR_Restore
    892                  return (OS_ERR_TASK_NOT_EXIST);
   \   0000002E   0x2043             MOVS     R0,#+67
   \   00000030   0xBDF2             POP      {R1,R4-R7,PC}
    893              }
    894              if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
   \                     ??OSTaskStkChk_2: (+1)
   \   00000032   0x7C0A             LDRB     R2,[R1, #+16]
   \   00000034   0x07D2             LSLS     R2,R2,#+31
   \   00000036   0xD403             BMI.N    ??OSTaskStkChk_3
    895                  OS_EXIT_CRITICAL();
   \   00000038   0x.... 0x....      BL       OS_CPU_SR_Restore
    896                  return (OS_ERR_TASK_OPT);
   \   0000003C   0x2045             MOVS     R0,#+69
   \   0000003E   0xBDF2             POP      {R1,R4-R7,PC}
    897              }
    898              nfree = 0;
   \                     ??OSTaskStkChk_3: (+1)
   \   00000040   0x2500             MOVS     R5,#+0
    899              size  = ptcb->OSTCBStkSize;
   \   00000042   0x68CE             LDR      R6,[R1, #+12]
    900              pchk  = ptcb->OSTCBStkBottom;
   \   00000044   0x688F             LDR      R7,[R1, #+8]
    901              OS_EXIT_CRITICAL();
   \   00000046   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   0000004A   0xE000             B.N      ??OSTaskStkChk_4
    902          #if OS_STK_GROWTH == 1
    903              while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
    904                  nfree++;
   \                     ??OSTaskStkChk_5: (+1)
   \   0000004C   0x1C6D             ADDS     R5,R5,#+1
    905              }
   \                     ??OSTaskStkChk_4: (+1)
   \   0000004E   0xF857 0x0B04      LDR      R0,[R7], #+4
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD0FA             BEQ.N    ??OSTaskStkChk_5
    906          #else
    907              while (*pchk-- == (OS_STK)0) {
    908                  nfree++;
    909              }
    910          #endif
    911              p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
   \   00000056   0x00A8             LSLS     R0,R5,#+2
   \   00000058   0x6020             STR      R0,[R4, #+0]
    912              p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
   \   0000005A   0x1B70             SUBS     R0,R6,R5
   \   0000005C   0x0080             LSLS     R0,R0,#+2
   \   0000005E   0x6060             STR      R0,[R4, #+4]
    913              return (OS_ERR_NONE);
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    914          }
    915          #endif
    916          /*$PAGE*/
    917          /*
    918          *********************************************************************************************************
    919          *                                            SUSPEND A TASK
    920          *
    921          * Description: This function is called to suspend a task.  The task can be the calling task if the
    922          *              priority passed to OSTaskSuspend() is the priority of the calling task or OS_PRIO_SELF.
    923          *
    924          * Arguments  : prio     is the priority of the task to suspend.  If you specify OS_PRIO_SELF, the
    925          *                       calling task will suspend itself and rescheduling will occur.
    926          *
    927          * Returns    : OS_ERR_NONE               if the requested task is suspended
    928          *              OS_ERR_TASK_SUSPEND_IDLE  if you attempted to suspend the idle task which is not allowed.
    929          *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
    930          *                                        (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
    931          *              OS_ERR_TASK_SUSPEND_PRIO  if the task to suspend does not exist
    932          *              OS_ERR_TASK_NOT_EXITS     if the task is assigned to a Mutex PIP
    933          *
    934          * Note       : You should use this function with great care.  If you suspend a task that is waiting for
    935          *              an event (i.e. a message, a semaphore, a queue ...) you will prevent this task from
    936          *              running when the event arrives.
    937          *********************************************************************************************************
    938          */
    939          
    940          #if OS_TASK_SUSPEND_EN > 0

   \                                 In section .text, align 2, keep-with-next
    941          INT8U  OSTaskSuspend (INT8U prio)
    942          {
   \                     OSTaskSuspend: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
    943              BOOLEAN    self;
    944              OS_TCB    *ptcb;
    945              INT8U      y;
    946          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    947              OS_CPU_SR  cpu_sr = 0;
    948          #endif
    949          
    950          
    951          
    952          #if OS_ARG_CHK_EN > 0
    953              if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
    954                  return (OS_ERR_TASK_SUSPEND_IDLE);
    955              }
    956              if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
    957                  if (prio != OS_PRIO_SELF) {
    958                      return (OS_ERR_PRIO_INVALID);
    959                  }
    960              }
    961          #endif
    962              OS_ENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000008   0x....             LDR.N    R1,??DataTable10_1
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0xF891 0x1032      LDRB     R1,[R1, #+50]
   \   00000010   0x2DFF             CMP      R5,#+255
   \   00000012   0xD102             BNE.N    ??OSTaskSuspend_0
    963              if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
    964                  prio = OSTCBCur->OSTCBPrio;
   \   00000014   0x460D             MOV      R5,R1
    965                  self = OS_TRUE;
   \   00000016   0x2401             MOVS     R4,#+1
   \   00000018   0xE004             B.N      ??OSTaskSuspend_1
    966              } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
   \                     ??OSTaskSuspend_0: (+1)
   \   0000001A   0x428D             CMP      R5,R1
   \   0000001C   0xD101             BNE.N    ??OSTaskSuspend_2
    967                  self = OS_TRUE;
   \   0000001E   0x2401             MOVS     R4,#+1
   \   00000020   0xE000             B.N      ??OSTaskSuspend_1
    968              } else {
    969                  self = OS_FALSE;                                        /* No suspending another task          */
   \                     ??OSTaskSuspend_2: (+1)
   \   00000022   0x2400             MOVS     R4,#+0
    970              }
    971              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskSuspend_1: (+1)
   \   00000024   0x....             LDR.N    R1,??DataTable10
   \   00000026   0xF851 0x1025      LDR      R1,[R1, R5, LSL #+2]
    972              if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
   \   0000002A   0x2900             CMP      R1,#+0
   \   0000002C   0xD103             BNE.N    ??OSTaskSuspend_3
    973                  OS_EXIT_CRITICAL();
   \   0000002E   0x.... 0x....      BL       OS_CPU_SR_Restore
    974                  return (OS_ERR_TASK_SUSPEND_PRIO);
   \   00000032   0x2048             MOVS     R0,#+72
   \   00000034   0xBD70             POP      {R4-R6,PC}
    975              }
    976              if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
   \                     ??OSTaskSuspend_3: (+1)
   \   00000036   0x2901             CMP      R1,#+1
   \   00000038   0xD103             BNE.N    ??OSTaskSuspend_4
    977                  OS_EXIT_CRITICAL();
   \   0000003A   0x.... 0x....      BL       OS_CPU_SR_Restore
    978                  return (OS_ERR_TASK_NOT_EXIST);
   \   0000003E   0x2043             MOVS     R0,#+67
   \   00000040   0xBD70             POP      {R4-R6,PC}
    979              }
    980              y            = ptcb->OSTCBY;
   \                     ??OSTaskSuspend_4: (+1)
   \   00000042   0x3130             ADDS     R1,R1,#+48
   \   00000044   0x790A             LDRB     R2,[R1, #+4]
    981              OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
   \   00000046   0x....             LDR.N    R3,??DataTable10_2
   \   00000048   0x5CD5             LDRB     R5,[R2, R3]
   \   0000004A   0x794E             LDRB     R6,[R1, #+5]
   \   0000004C   0x43B5             BICS     R5,R5,R6
   \   0000004E   0x54D5             STRB     R5,[R2, R3]
    982              if (OSRdyTbl[y] == 0) {
   \   00000050   0xD104             BNE.N    ??OSTaskSuspend_5
    983                  OSRdyGrp &= ~ptcb->OSTCBBitY;
   \   00000052   0x....             LDR.N    R2,??DataTable10_3
   \   00000054   0x7813             LDRB     R3,[R2, #+0]
   \   00000056   0x798D             LDRB     R5,[R1, #+6]
   \   00000058   0x43AB             BICS     R3,R3,R5
   \   0000005A   0x7013             STRB     R3,[R2, #+0]
    984              }
    985              ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
   \                     ??OSTaskSuspend_5: (+1)
   \   0000005C   0x780A             LDRB     R2,[R1, #+0]
   \   0000005E   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000062   0x700A             STRB     R2,[R1, #+0]
    986              OS_EXIT_CRITICAL();
   \   00000064   0x.... 0x....      BL       OS_CPU_SR_Restore
    987              if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
   \   00000068   0x2C01             CMP      R4,#+1
   \   0000006A   0xD101             BNE.N    ??OSTaskSuspend_6
    988                  OS_Sched();                                             /* Find new highest priority task      */
   \   0000006C   0x.... 0x....      BL       OS_Sched
    989              }
    990              return (OS_ERR_NONE);
   \                     ??OSTaskSuspend_6: (+1)
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xBD70             POP      {R4-R6,PC}       ;; return
    991          }
    992          #endif
    993          /*$PAGE*/
    994          /*
    995          *********************************************************************************************************
    996          *                                            QUERY A TASK
    997          *
    998          * Description: This function is called to obtain a copy of the desired task's TCB.
    999          *
   1000          * Arguments  : prio         is the priority of the task to obtain information from.
   1001          *
   1002          *              p_task_data  is a pointer to where the desired task's OS_TCB will be stored.
   1003          *
   1004          * Returns    : OS_ERR_NONE            if the requested task is suspended
   1005          *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
   1006          *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
   1007          *              OS_ERR_PRIO            if the desired task has not been created
   1008          *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP
   1009          *              OS_ERR_PDATA_NULL      if 'p_task_data' is a NULL pointer
   1010          *********************************************************************************************************
   1011          */
   1012          
   1013          #if OS_TASK_QUERY_EN > 0

   \                                 In section .text, align 2, keep-with-next
   1014          INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
   1015          {
   \                     OSTaskQuery: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1016              OS_TCB    *ptcb;
   1017          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
   1018              OS_CPU_SR  cpu_sr = 0;
   1019          #endif
   1020          
   1021          
   1022          
   1023          #if OS_ARG_CHK_EN > 0
   1024              if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
   1025                  if (prio != OS_PRIO_SELF) {
   1026                      return (OS_ERR_PRIO_INVALID);
   1027                  }
   1028              }
   1029              if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
   1030                  return (OS_ERR_PDATA_NULL);
   1031              }
   1032          #endif
   1033              OS_ENTER_CRITICAL();
   \   00000006   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000000A   0x4606             MOV      R6,R0
   1034              if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
   \   0000000C   0x2CFF             CMP      R4,#+255
   \   0000000E   0xD103             BNE.N    ??OSTaskQuery_0
   1035                  prio = OSTCBCur->OSTCBPrio;
   \   00000010   0x....             LDR.N    R0,??DataTable10_1
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF890 0x4032      LDRB     R4,[R0, #+50]
   1036              }
   1037              ptcb = OSTCBPrioTbl[prio];
   \                     ??OSTaskQuery_0: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable10
   \   0000001A   0xF850 0x1024      LDR      R1,[R0, R4, LSL #+2]
   1038              if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD104             BNE.N    ??OSTaskQuery_1
   1039                  OS_EXIT_CRITICAL();
   \   00000022   0x4630             MOV      R0,R6
   \   00000024   0x.... 0x....      BL       OS_CPU_SR_Restore
   1040                  return (OS_ERR_PRIO);
   \   00000028   0x2029             MOVS     R0,#+41
   \   0000002A   0xBD70             POP      {R4-R6,PC}
   1041              }
   1042              if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
   \                     ??OSTaskQuery_1: (+1)
   \   0000002C   0x2901             CMP      R1,#+1
   \   0000002E   0xD104             BNE.N    ??OSTaskQuery_2
   1043                  OS_EXIT_CRITICAL();
   \   00000030   0x4630             MOV      R0,R6
   \   00000032   0x.... 0x....      BL       OS_CPU_SR_Restore
   1044                  return (OS_ERR_TASK_NOT_EXIST);
   \   00000036   0x2043             MOVS     R0,#+67
   \   00000038   0xBD70             POP      {R4-R6,PC}
   1045              }
   1046                                                           /* Copy TCB into user storage area                    */
   1047              OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
   \                     ??OSTaskQuery_2: (+1)
   \   0000003A   0x225C             MOVS     R2,#+92
   \   0000003C   0x4628             MOV      R0,R5
   \   0000003E   0x.... 0x....      BL       OS_MemCopy
   1048              OS_EXIT_CRITICAL();
   \   00000042   0x4630             MOV      R0,R6
   \   00000044   0x.... 0x....      BL       OS_CPU_SR_Restore
   1049              return (OS_ERR_NONE);
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBD70             POP      {R4-R6,PC}       ;; return
   1050          }
   1051          #endif
   1052          /*$PAGE*/
   1053          /*
   1054          *********************************************************************************************************
   1055          *                                        CLEAR TASK STACK
   1056          *
   1057          * Description: This function is used to clear the stack of a task (i.e. write all zeros)
   1058          *
   1059          * Arguments  : pbos     is a pointer to the task's bottom of stack.  If the configuration constant
   1060          *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
   1061          *                       memory to low memory).  'pbos' will thus point to the lowest (valid) memory
   1062          *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
   1063          *                       highest memory location of the stack and the stack will grow with increasing
   1064          *                       memory locations.  'pbos' MUST point to a valid 'free' data item.
   1065          *
   1066          *              size     is the number of 'stack elements' to clear.
   1067          *
   1068          *              opt      contains additional information (or options) about the behavior of the task.  The
   1069          *                       LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
   1070          *                       specific.  See OS_TASK_OPT_??? in uCOS-II.H.
   1071          *
   1072          * Returns    : none
   1073          *********************************************************************************************************
   1074          */
   1075          #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)

   \                                 In section .text, align 2, keep-with-next
   1076          void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
   1077          {
   1078              if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
   \                     OS_TaskStkClr: (+1)
   \   00000000   0xF002 0x0203      AND      R2,R2,#0x3
   \   00000004   0x2A03             CMP      R2,#+3
   \   00000006   0xD106             BNE.N    ??OS_TaskStkClr_0
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xE002             B.N      ??OS_TaskStkClr_1
   1079                  if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
   1080          #if OS_STK_GROWTH == 1
   1081                      while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
   1082                          size--;
   \                     ??OS_TaskStkClr_2: (+1)
   \   0000000E   0x1E49             SUBS     R1,R1,#+1
   1083                          *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
   \   00000010   0xF840 0x2B04      STR      R2,[R0], #+4
   1084                      }
   \                     ??OS_TaskStkClr_1: (+1)
   \   00000014   0xD1FB             BNE.N    ??OS_TaskStkClr_2
   1085          #else
   1086                      while (size > 0) {                         /* Stack grows from LOW to HIGH memory          */
   1087                          size--;
   1088                          *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
   1089                      }
   1090          #endif
   1091                  }
   1092              }
   1093          }
   \                     ??OS_TaskStkClr_0: (+1)
   \   00000016   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     OSTCBPrioTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     OSTCBCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     OSRdyTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     OSRdyGrp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     OSLockNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     OSTaskCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     OSTCBList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     OSTCBFreeList
   1094          
   1095          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   OSTaskChangePrio
        40   -> OS_CPU_SR_Restore
        40   -> OS_CPU_SR_Save
        40   -> OS_Sched
      40   OSTaskCreate
        40   -> OSTaskStkInit
        40   -> OS_CPU_SR_Restore
        40   -> OS_CPU_SR_Save
        40   -> OS_Sched
        40   -> OS_TCBInit
      56   OSTaskCreateExt
        56   -> OSTaskStkInit
        56   -> OS_CPU_SR_Restore
        56   -> OS_CPU_SR_Save
        56   -> OS_Sched
        56   -> OS_TCBInit
        56   -> OS_TaskStkClr
      32   OSTaskDel
        32   -> OSTaskDelHook
        32   -> OS_CPU_SR_Restore
        32   -> OS_CPU_SR_Save
        32   -> OS_Dummy
        32   -> OS_EventTaskRemove
        32   -> OS_EventTaskRemoveMulti
        32   -> OS_FlagUnlink
        32   -> OS_Sched
       8   OSTaskDelReq
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
      24   OSTaskNameGet
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_StrCopy
      24   OSTaskNameSet
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
        24   -> OS_StrCopy
        24   -> OS_StrLen
      16   OSTaskQuery
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> OS_MemCopy
       8   OSTaskResume
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
         8   -> OS_Sched
      24   OSTaskStkChk
        24   -> OS_CPU_SR_Restore
        24   -> OS_CPU_SR_Save
      16   OSTaskSuspend
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> OS_Sched
       0   OS_TaskStkClr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
     398  OSTaskChangePrio
     138  OSTaskCreate
     162  OSTaskCreateExt
     304  OSTaskDel
      84  OSTaskDelReq
      96  OSTaskNameGet
     110  OSTaskNameSet
      76  OSTaskQuery
     116  OSTaskResume
     100  OSTaskStkChk
     116  OSTaskSuspend
      24  OS_TaskStkClr

 
 1 764 bytes in section .text
 
 1 764 bytes of CODE memory

Errors: none
Warnings: none
