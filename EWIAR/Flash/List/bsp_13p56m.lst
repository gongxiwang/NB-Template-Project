###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        12/Jul/2019  09:14:39
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\USER\BSP\bsp_13p56m.c
#    Command line =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\USER\BSP\bsp_13p56m.c
#        -D LORA_MODULE -lCN
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\List\ -o
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\Softwares\IAR7.40\arm\INC\c\DLib_Config_Full.h -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\CPU\inc\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-CPU\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-CPU\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-LIB\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-OSII\Ports\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-OSII\Source\
#        -I E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\USER\BSP\
#        -I E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\USER\APP\
#        -Om --use_c++_inline
#    List file    =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\List\bsp_13p56m.lst
#    Object file  =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\Obj\bsp_13p56m.o
#
###############################################################################

E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\USER\BSP\bsp_13p56m.c
      1          /** Copyright(c) 2015, XunFang Tech Limited. All rights reserved.
      2            * @file		RF13P56M_Driver.c
      3            * @author		qyz
      4            * @version	V1.0.0
      5            * @date		07/21/2015
      6            * @brief		RF13P56M_Driver驱动函数。
      7            */ 
      8          
      9          
     10          /**
     11            * @包含头文件
     12            */
     13          #include "bsp.h"
     14          #include "bsp_13p56m.h"
     15          #include "stdio.h"
     16          #include "string.h"
     17          
     18          /**
     19            * @变量定义
     20            */
     21          
     22          

   \                                 In section .bss, align 4
     23          static u8 RF13P56M_rev_buff[RF13P56M_BUFFSIZE];
   \                     RF13P56M_rev_buff:
   \   00000000                      DS8 200

   \                                 In section .bss, align 2
     24          static u16 RF13P56M_rev_buff_cnt = 0;
     25          static u16 RF13P56M_rev_timeout;
     26          static u8 RF13P56M_rev_finish = 0;
   \                     RF13P56M_rev_finish:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 2
   \   00000004                      DS8 2
     27          
     28          
     29          static int PN532_WakeUp(void);
     30          static void CleanBuffer(u16 num);
     31          static void ClearFlag(void);
     32          static void SendData(u8 *data,u8 len);
     33          
     34          /**
     35            * @brief		PN532初始化函数
     36            * @details	
     37            * @param 	baud	串口波特率
     38            * @retval 	NULL	无
     39            */

   \                                 In section .text, align 2, keep-with-next
     40          void PN532_init(void)
     41          {
   \                     PN532_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     42              RF13P56M_Tim2_Init();
   \   00000002   0x.... 0x....      BL       RF13P56M_Tim2_Init
     43              PN532_WakeUp();
   \   00000006   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000A   0x....             B.N      PN532_WakeUp
     44          }
     45          
     46          /**
     47            * @brief		tim2初始化函数
     48            * @details	定时器2初始化，配置10ms中断
     49            * @param 	NULL	无
     50            * @retval 	NULL	无
     51            */

   \                                 In section .text, align 2, keep-with-next
     52          static void RF13P56M_Tim2_Init(void)
     53          {															
   \                     RF13P56M_Tim2_Init: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
     54             	TIM_TimeBaseInitTypeDef  time;
     55              NVIC_InitTypeDef nvic; 
     56          
     57              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2 , ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x4608             MOV      R0,R1
   \   00000008   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
     58          	TIM_DeInit(TIM2);
   \   0000000C   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000010   0x.... 0x....      BL       TIM_DeInit
     59          
     60              time.TIM_Period = 10000;		 				/* 10ms 自动重装载寄存器周期的值(计数值) */
   \   00000014   0xF242 0x7010      MOVW     R0,#+10000
   \   00000018   0xF8AD 0x0008      STRH     R0,[SP, #+8]
     61              											    /* 累计 TIM_Period个频率后产生一个更新或者中断 */
     62              time.TIM_Prescaler= (72 - 1);				    /* 时钟预分频数 72M/72 */
   \   0000001C   0x2047             MOVS     R0,#+71
   \   0000001E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
     63              time.TIM_ClockDivision=TIM_CKD_DIV1; 			/* 采样分频 */
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xF8AD 0x000A      STRH     R0,[SP, #+10]
     64              time.TIM_CounterMode=TIM_CounterMode_Up; 		/* 向上计数模式 */
   \   00000028   0xF8AD 0x0006      STRH     R0,[SP, #+6]
     65              TIM_TimeBaseInit(TIM2, &time);
   \   0000002C   0xA901             ADD      R1,SP,#+4
   \   0000002E   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000032   0x.... 0x....      BL       TIM_TimeBaseInit
     66              TIM_ClearFlag(TIM2, TIM_FLAG_Update);			/* 清除溢出中断标志 */
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0xF04F 0x4080      MOV      R0,#+1073741824
   \   0000003C   0x.... 0x....      BL       TIM_ClearFlag
     67              TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);		
   \   00000040   0x2201             MOVS     R2,#+1
   \   00000042   0x4611             MOV      R1,R2
   \   00000044   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000048   0x.... 0x....      BL       TIM_ITConfig
     68              
     69          	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);												
   \   0000004C   0xF44F 0x60C0      MOV      R0,#+1536
   \   00000050   0x.... 0x....      BL       NVIC_PriorityGroupConfig
     70              nvic.NVIC_IRQChannel = TIM2_IRQChannel;	  
   \   00000054   0x201C             MOVS     R0,#+28
   \   00000056   0xF88D 0x0000      STRB     R0,[SP, #+0]
     71              nvic.NVIC_IRQChannelPreemptionPriority =1;
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0xF88D 0x0001      STRB     R0,[SP, #+1]
     72              nvic.NVIC_IRQChannelSubPriority = 2;	
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0xF88D 0x0002      STRB     R0,[SP, #+2]
     73              nvic.NVIC_IRQChannelCmd = ENABLE;
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xF88D 0x0003      STRB     R0,[SP, #+3]
     74              NVIC_Init(&nvic);
   \   0000006C   0xA800             ADD      R0,SP,#+0
   \   0000006E   0x.... 0x....      BL       NVIC_Init
     75          	BSP_IntVectSet(BSP_INT_ID_TIM2, BSP_IntHandlerTIM2); 				//设置串口1的中断向量，必须要有的
   \   00000072   0x.... 0x....      ADR.W    R1,BSP_IntHandlerTIM2
   \   00000076   0x201C             MOVS     R0,#+28
   \   00000078   0x.... 0x....      BL       BSP_IntVectSet
     76          	BSP_IntEn(BSP_INT_ID_TIM2);
   \   0000007C   0x201C             MOVS     R0,#+28
   \   0000007E   0x.... 0x....      BL       BSP_IntEn
     77          }
   \   00000082   0xB005             ADD      SP,SP,#+20
   \   00000084   0xBD00             POP      {PC}             ;; return
     78          
     79          
     80          /**
     81            * @brief		tim2中断函数
     82            * @details	
     83            * @param 	NULL	无
     84            * @retval 	NULL	无
     85            */

   \                                 In section .text, align 4, keep-with-next
     86          void BSP_IntHandlerTIM2(void)
     87          {
   \                     BSP_IntHandlerTIM2: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     88          	OS_CPU_SR  cpu_sr; 
     89          	OS_ENTER_CRITICAL();
   \   00000002   0x.... 0x....      BL       OS_CPU_SR_Save
     90              OSIntNesting++;
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable10
   \   0000000A   0x780A             LDRB     R2,[R1, #+0]
   \   0000000C   0x1C52             ADDS     R2,R2,#+1
   \   0000000E   0x700A             STRB     R2,[R1, #+0]
     91              OS_EXIT_CRITICAL();
   \   00000010   0x.... 0x....      BL       OS_CPU_SR_Restore
     92          	if( TIM_GetITStatus(TIM2 , TIM_IT_Update) != RESET ) 
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0xF04F 0x4080      MOV      R0,#+1073741824
   \   0000001A   0x.... 0x....      BL       TIM_GetITStatus
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD016             BEQ.N    ??BSP_IntHandlerTIM2_0
     93          	{	
     94          		if(RF13P56M_rev_buff_cnt != 0)
   \   00000022   0x.... 0x....      LDR.W    R4,??DataTable10_1
   \   00000026   0x8860             LDRH     R0,[R4, #+2]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD002             BEQ.N    ??BSP_IntHandlerTIM2_1
     95          			RF13P56M_rev_timeout++;
   \   0000002C   0x88A0             LDRH     R0,[R4, #+4]
   \   0000002E   0x1C40             ADDS     R0,R0,#+1
   \   00000030   0x80A0             STRH     R0,[R4, #+4]
     96          		if(RF13P56M_rev_timeout == 25)  /*接收超时时间200ms*/
   \                     ??BSP_IntHandlerTIM2_1: (+1)
   \   00000032   0x88A0             LDRH     R0,[R4, #+4]
   \   00000034   0x2819             CMP      R0,#+25
   \   00000036   0xD106             BNE.N    ??BSP_IntHandlerTIM2_2
     97          		{
     98          			TIM_Cmd(TIM2, DISABLE);	   /*超过200ms没有接收到数据，认为接收完成*/
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0xF04F 0x4080      MOV      R0,#+1073741824
   \   0000003E   0x.... 0x....      BL       TIM_Cmd
     99          		 	RF13P56M_rev_finish = 1;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x7020             STRB     R0,[R4, #+0]
    100          		}
    101          		TIM_ClearITPendingBit(TIM2 , TIM_FLAG_Update); 	  
   \                     ??BSP_IntHandlerTIM2_2: (+1)
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0xF04F 0x4080      MOV      R0,#+1073741824
   \   0000004C   0x.... 0x....      BL       TIM_ClearITPendingBit
    102          	}
    103              OSIntExit();
   \                     ??BSP_IntHandlerTIM2_0: (+1)
   \   00000050   0xE8BD 0x4010      POP      {R4,LR}
   \   00000054   0x.... 0x....      B.W      OSIntExit
    104          }	
    105          
    106          /**
    107            * @brief		PN532_WakeUp
    108            * @details	唤醒PN532模块，此条命令特殊：55 55 00 00 00 00 00 00 00 00 00 00 00 00 00 00 FF 03 FD D4 14 01 17 00
    109            * @param 	NULL	无
    110            * @retval 	返回0为成功，返回1为失败
    111            */ 

   \                                 In section .text, align 2, keep-with-next
    112          static int PN532_WakeUp(void)
    113          {
   \                     PN532_WakeUp: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    114              u8 data[24];
    115              u8 i,time = 5;
   \   00000004   0x2505             MOVS     R5,#+5
    116              u8 CheckCode=0; /*数据校验码 */
    117              u8 temp=0;
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0xE002             B.N      ??PN532_WakeUp_0
    118              
    119              while(time--)
    120              { 
    121                  data[0]=0x55;
    122                  data[1]=0x55;
    123                  data[2]=0x00;
    124                  data[3]=0x00;
    125                  data[4]=0x00;
    126                  data[5]=0x00;
    127                  data[6]=0x00;
    128                  data[7]=0x00;
    129                  data[8]=0x00;
    130                  data[9]=0x00;
    131                  data[10]=0x00;
    132                  data[11]=0x00;
    133                  data[12]=0x00;
    134                  data[13]=0x00;
    135                  data[14]=0x00;
    136                  data[15]=0x00;       
    137                  data[16]=0xFF;
    138                  data[17]=0x03; /*包 长度 */
    139                  data[18]=0xFD; /*包 长度 校验  0x100-data[3] */
    140                  data[19]=0xD4; /*命令标识码*/
    141                  data[20]=0x14; /*命令标识码 */
    142                  data[21]=0x01;
    143                  data[22]=0x17; /*数据 校验   0x100- */
    144                  data[23]=0x00;
    145                  
    146                  SendData(data, 24);/*发送 length长度的数据data*/
    147          
    148                  while(!RF13P56M_rev_finish)
    149                      delay_ms(10);
    150                  
    151                  ClearFlag();      
    152          
    153                  for(i = 11;i < 13; i ++)
    154                  {
    155                      temp += RF13P56M_rev_buff[i];
    156                  }
    157                  CheckCode = 0x100 - temp;
    158                  if(CheckCode == RF13P56M_rev_buff[13])
    159                  {
    160                      CheckCode = 0x100 - temp;
    161                      CleanBuffer(40);                /* 清除 串口接收缓冲区前30 个字节数据 */
    162                      return 0;
    163                  }
    164          		delay_ms(50);
   \                     ??PN532_WakeUp_1: (+1)
   \   0000000A   0x2032             MOVS     R0,#+50
   \   0000000C   0x.... 0x....      BL       delay_ms
   \                     ??PN532_WakeUp_0: (+1)
   \   00000010   0x4628             MOV      R0,R5
   \   00000012   0x1E45             SUBS     R5,R0,#+1
   \   00000014   0xB2C0             UXTB     R0,R0
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD046             BEQ.N    ??PN532_WakeUp_2
   \   0000001A   0x2055             MOVS     R0,#+85
   \   0000001C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000020   0xA800             ADD      R0,SP,#+0
   \   00000022   0x2155             MOVS     R1,#+85
   \   00000024   0x7041             STRB     R1,[R0, #+1]
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0xF8AD 0x1002      STRH     R1,[SP, #+2]
   \   0000002C   0x9101             STR      R1,[SP, #+4]
   \   0000002E   0x9102             STR      R1,[SP, #+8]
   \   00000030   0x9103             STR      R1,[SP, #+12]
   \   00000032   0x21FF             MOVS     R1,#+255
   \   00000034   0xF88D 0x1010      STRB     R1,[SP, #+16]
   \   00000038   0x2103             MOVS     R1,#+3
   \   0000003A   0xF88D 0x1011      STRB     R1,[SP, #+17]
   \   0000003E   0x21FD             MOVS     R1,#+253
   \   00000040   0xF88D 0x1012      STRB     R1,[SP, #+18]
   \   00000044   0x21D4             MOVS     R1,#+212
   \   00000046   0xF88D 0x1013      STRB     R1,[SP, #+19]
   \   0000004A   0x2114             MOVS     R1,#+20
   \   0000004C   0x7501             STRB     R1,[R0, #+20]
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0xF88D 0x1015      STRB     R1,[SP, #+21]
   \   00000054   0x2117             MOVS     R1,#+23
   \   00000056   0xF88D 0x1016      STRB     R1,[SP, #+22]
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0x75C1             STRB     R1,[R0, #+23]
   \   0000005E   0x2118             MOVS     R1,#+24
   \   00000060   0x.... 0x....      BL       SendData
   \   00000064   0xE002             B.N      ??PN532_WakeUp_3
   \                     ??PN532_WakeUp_4: (+1)
   \   00000066   0x200A             MOVS     R0,#+10
   \   00000068   0x.... 0x....      BL       delay_ms
   \                     ??PN532_WakeUp_3: (+1)
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD0F7             BEQ.N    ??PN532_WakeUp_4
   \   00000076   0x.... 0x....      BL       ClearFlag
   \   0000007A   0x200B             MOVS     R0,#+11
   \   0000007C   0xE003             B.N      ??PN532_WakeUp_5
   \                     ??PN532_WakeUp_6: (+1)
   \   0000007E   0x5C51             LDRB     R1,[R2, R1]
   \   00000080   0x190C             ADDS     R4,R1,R4
   \   00000082   0xB2E4             UXTB     R4,R4
   \   00000084   0x1C40             ADDS     R0,R0,#+1
   \                     ??PN532_WakeUp_5: (+1)
   \   00000086   0xB2C0             UXTB     R0,R0
   \   00000088   0x4602             MOV      R2,R0
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   0000008E   0x2A0D             CMP      R2,#+13
   \   00000090   0xDBF5             BLT.N    ??PN532_WakeUp_6
   \   00000092   0x4620             MOV      R0,R4
   \   00000094   0x4240             RSBS     R0,R0,#+0
   \   00000096   0x7B49             LDRB     R1,[R1, #+13]
   \   00000098   0xB2C0             UXTB     R0,R0
   \   0000009A   0x4288             CMP      R0,R1
   \   0000009C   0xD1B5             BNE.N    ??PN532_WakeUp_1
   \   0000009E   0x2028             MOVS     R0,#+40
   \   000000A0   0x.... 0x....      BL       CleanBuffer
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xE001             B.N      ??PN532_WakeUp_7
    165              }
    166              return -1;
   \                     ??PN532_WakeUp_2: (+1)
   \   000000A8   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??PN532_WakeUp_7: (+1)
   \   000000AC   0xB007             ADD      SP,SP,#+28
   \   000000AE   0xBD30             POP      {R4,R5,PC}       ;; return
    167          }
    168          
    169          
    170          /**
    171            * @brief		PN532_InListPassiveTarget
    172            * @details	寻卡
    173            * @param 	uid 存储卡号
    174            * @retval 	返回0为成功，返回1为失败
    175            */

   \                                 In section .text, align 2, keep-with-next
    176          int PN532_InListPassiveTarget(u8 *uid)
    177          {
   \                     PN532_InListPassiveTarget: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
    178              u8 data[11];
    179              u8 i;
    180              u8 CheckCode=0; /*数据校验码	*/
    181              u8 temp=0;
    182          	u8 chekdata[4] = {0};
   \   00000006   0xA803             ADD      R0,SP,#+12
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    183              u16 wait_flag = 0;
   \   0000000C   0x460D             MOV      R5,R1
   \   0000000E   0xE002             B.N      ??PN532_InListPassiveTarget_0
    184              while(1)
    185              {   
    186                  data[0]=0x00;
    187                  data[1]=0x00;
    188                  data[2]=0xFF;
    189                  data[3]=0x04; /*包 长度	*/
    190                  data[4]=0xFC; /*包 长度 校验  0x100-data[3]*/
    191                  data[5]=0xD4; /*命令标识码 */
    192                  data[6]=0x4A; /*命令标识码	*/
    193                  data[7]=0x01;
    194                  data[8]=0x00;
    195                  data[9]=0xE1; /*数据 校验   0x100-*/
    196                  data[10]=0x00;
    197                  SendData(data,11);
    198                  while(!RF13P56M_rev_finish)
    199                      delay_ms(10);
    200                  
    201                  ClearFlag();       		  
    202                  temp=0;
    203               
    204                  for(i=11; i < 23; i ++)
    205                  {
    206                      temp += RF13P56M_rev_buff[i];
    207                  }
    208                  CheckCode = 0x100 - temp;
    209                  if(CheckCode == RF13P56M_rev_buff[23])
    210                  {
    211                      memcpy(uid, &RF13P56M_rev_buff[19], 4);
    212                      if(memcmp(uid, chekdata, 4) != 0)/*检测是否寻到卡*/
    213                      {  
    214                          CleanBuffer(40);			 /*清除 串口接收缓冲区前40 个字节数据 */
    215                         return 0;
    216                      }
    217                      else
    218                      {
    219                          wait_flag ++;
    220                          delay_ms(50);
    221                          if(wait_flag == 50)
    222                          {
    223                              wait_flag = 0;                    
    224                              break;
    225                          }
    226                      }
    227                   }            
    228          		 delay_ms(50);
   \                     ??PN532_InListPassiveTarget_1: (+1)
   \   00000010   0x2032             MOVS     R0,#+50
   \   00000012   0x.... 0x....      BL       delay_ms
   \                     ??PN532_InListPassiveTarget_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   0000001C   0xA800             ADD      R0,SP,#+0
   \   0000001E   0x21FF             MOVS     R1,#+255
   \   00000020   0xF88D 0x1002      STRB     R1,[SP, #+2]
   \   00000024   0x2104             MOVS     R1,#+4
   \   00000026   0xF88D 0x1003      STRB     R1,[SP, #+3]
   \   0000002A   0x21FC             MOVS     R1,#+252
   \   0000002C   0x7101             STRB     R1,[R0, #+4]
   \   0000002E   0x21D4             MOVS     R1,#+212
   \   00000030   0xF88D 0x1005      STRB     R1,[SP, #+5]
   \   00000034   0x214A             MOVS     R1,#+74
   \   00000036   0xF88D 0x1006      STRB     R1,[SP, #+6]
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0xF88D 0x1007      STRB     R1,[SP, #+7]
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0xF88D 0x1008      STRB     R1,[SP, #+8]
   \   00000046   0x21E1             MOVS     R1,#+225
   \   00000048   0xF88D 0x1009      STRB     R1,[SP, #+9]
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x7281             STRB     R1,[R0, #+10]
   \   00000050   0x210B             MOVS     R1,#+11
   \   00000052   0x.... 0x....      BL       SendData
   \   00000056   0xE002             B.N      ??PN532_InListPassiveTarget_2
   \                     ??PN532_InListPassiveTarget_3: (+1)
   \   00000058   0x200A             MOVS     R0,#+10
   \   0000005A   0x.... 0x....      BL       delay_ms
   \                     ??PN532_InListPassiveTarget_2: (+1)
   \   0000005E   0x....             LDR.N    R0,??DataTable10_1
   \   00000060   0x7800             LDRB     R0,[R0, #+0]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD0F8             BEQ.N    ??PN532_InListPassiveTarget_3
   \   00000066   0x.... 0x....      BL       ClearFlag
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x210B             MOVS     R1,#+11
   \   0000006E   0x....             LDR.N    R3,??DataTable10_2
   \   00000070   0xE003             B.N      ??PN532_InListPassiveTarget_4
   \                     ??PN532_InListPassiveTarget_5: (+1)
   \   00000072   0x5CD2             LDRB     R2,[R2, R3]
   \   00000074   0x1810             ADDS     R0,R2,R0
   \   00000076   0xB2C0             UXTB     R0,R0
   \   00000078   0x1C49             ADDS     R1,R1,#+1
   \                     ??PN532_InListPassiveTarget_4: (+1)
   \   0000007A   0xB2C9             UXTB     R1,R1
   \   0000007C   0x460A             MOV      R2,R1
   \   0000007E   0x2A17             CMP      R2,#+23
   \   00000080   0xDBF7             BLT.N    ??PN532_InListPassiveTarget_5
   \   00000082   0x4240             RSBS     R0,R0,#+0
   \   00000084   0x7DD9             LDRB     R1,[R3, #+23]
   \   00000086   0xB2C0             UXTB     R0,R0
   \   00000088   0x4288             CMP      R0,R1
   \   0000008A   0xD1C1             BNE.N    ??PN532_InListPassiveTarget_1
   \   0000008C   0x2204             MOVS     R2,#+4
   \   0000008E   0xF103 0x0113      ADD      R1,R3,#+19
   \   00000092   0x4620             MOV      R0,R4
   \   00000094   0x.... 0x....      BL       __aeabi_memcpy
   \   00000098   0x2204             MOVS     R2,#+4
   \   0000009A   0xA903             ADD      R1,SP,#+12
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0x.... 0x....      BL       memcmp
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD004             BEQ.N    ??PN532_InListPassiveTarget_6
   \   000000A6   0x2028             MOVS     R0,#+40
   \   000000A8   0x.... 0x....      BL       CleanBuffer
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0xE008             B.N      ??PN532_InListPassiveTarget_7
   \                     ??PN532_InListPassiveTarget_6: (+1)
   \   000000B0   0x1C6D             ADDS     R5,R5,#+1
   \   000000B2   0x2032             MOVS     R0,#+50
   \   000000B4   0x.... 0x....      BL       delay_ms
   \   000000B8   0xB2AD             UXTH     R5,R5
   \   000000BA   0x2D32             CMP      R5,#+50
   \   000000BC   0xD1A8             BNE.N    ??PN532_InListPassiveTarget_1
    229              }
    230              return -1;
   \   000000BE   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??PN532_InListPassiveTarget_7: (+1)
   \   000000C2   0xB005             ADD      SP,SP,#+20
   \   000000C4   0xBD30             POP      {R4,R5,PC}       ;; return
    231          }
    232          
    233          
    234          /**
    235            * @brief		PN532_PsdVerifyKeyA
    236            * @details	密码授权，验证KeyA 
    237            *             00 00 FF 0F F1 D4 40 01 60 03 FF FF FF FF FF FF UID1 UID2 UID3 UID4 2A 00
    238            *             00 00 FF 0F F1 D4 40 01 60 03 FF FF FF FF FF FF 94 8A 3B 0B 2A 00
    239            * @param 	block	块号
    240            * @param 	uid	卡号
    241            * @retval 	返回0为成功，返回1为失败
    242            */

   \                                 In section .text, align 2, keep-with-next
    243          int PN532_PsdVerifyKeyA(u8 block,u8 *uid)
    244          {
   \                     PN532_PsdVerifyKeyA: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    245              u8 data[22];
    246              u8 temp=0; 
   \   00000004   0x2400             MOVS     R4,#+0
    247              u8 i;
    248              u8 CheckCode=0; /*数据校验码*/
    249              data[0]=0x00;
   \   00000006   0x4622             MOV      R2,R4
   \   00000008   0xF8AD 0x2000      STRH     R2,[SP, #+0]
    250              data[1]=0x00;
   \   0000000C   0xAD00             ADD      R5,SP,#+0
    251              data[2]=0xFF;
   \   0000000E   0x22FF             MOVS     R2,#+255
   \   00000010   0xF88D 0x2002      STRB     R2,[SP, #+2]
    252              
    253              data[3]=0x0F; /*包 长度 */
   \   00000014   0x230F             MOVS     R3,#+15
   \   00000016   0xF88D 0x3003      STRB     R3,[SP, #+3]
    254              data[4]=0xF1; /*包 长度 校验  0x100-data[3] */
   \   0000001A   0x23F1             MOVS     R3,#+241
   \   0000001C   0x712B             STRB     R3,[R5, #+4]
    255              
    256              data[5]=0xD4; /*命令标识码 */
   \   0000001E   0x23D4             MOVS     R3,#+212
   \   00000020   0x716B             STRB     R3,[R5, #+5]
    257              data[6]=0x40; /*命令标识码 */
   \   00000022   0x2340             MOVS     R3,#+64
   \   00000024   0xF88D 0x3006      STRB     R3,[SP, #+6]
    258              
    259              data[7]=0x01;
   \   00000028   0x2301             MOVS     R3,#+1
   \   0000002A   0xF88D 0x3007      STRB     R3,[SP, #+7]
    260              data[8]=0x60;
   \   0000002E   0x2360             MOVS     R3,#+96
   \   00000030   0xF88D 0x3008      STRB     R3,[SP, #+8]
    261              data[9]=block; 
   \   00000034   0xF88D 0x0009      STRB     R0,[SP, #+9]
    262              
    263              data[10]=0xFF;                    /*KEY A 密码 FF FF FF FF FF FF*/
   \   00000038   0x72AA             STRB     R2,[R5, #+10]
    264              data[11]=0xFF;
   \   0000003A   0x72EA             STRB     R2,[R5, #+11]
    265              data[12]=0xFF;
   \   0000003C   0xF88D 0x200C      STRB     R2,[SP, #+12]
    266              data[13]=0xFF;
   \   00000040   0x736A             STRB     R2,[R5, #+13]
    267              data[14]=0xFF;
   \   00000042   0x73AA             STRB     R2,[R5, #+14]
    268              data[15]=0xFF;
   \   00000044   0x73EA             STRB     R2,[R5, #+15]
    269              memcpy(&data[16],uid,4);
   \   00000046   0x2204             MOVS     R2,#+4
   \   00000048   0xA804             ADD      R0,SP,#+16
   \   0000004A   0x.... 0x....      BL       __aeabi_memcpy
    270              
    271              for(i=5;i<20;i++)
   \   0000004E   0x2005             MOVS     R0,#+5
   \   00000050   0xE003             B.N      ??PN532_PsdVerifyKeyA_0
    272              {
    273                  temp+=data[i];
   \                     ??PN532_PsdVerifyKeyA_1: (+1)
   \   00000052   0x5D49             LDRB     R1,[R1, R5]
   \   00000054   0x190C             ADDS     R4,R1,R4
   \   00000056   0xB2E4             UXTB     R4,R4
    274              }
   \   00000058   0x1C40             ADDS     R0,R0,#+1
   \                     ??PN532_PsdVerifyKeyA_0: (+1)
   \   0000005A   0xB2C0             UXTB     R0,R0
   \   0000005C   0x4601             MOV      R1,R0
   \   0000005E   0x2914             CMP      R1,#+20
   \   00000060   0xDBF7             BLT.N    ??PN532_PsdVerifyKeyA_1
    275          
    276              data[20]=0x100-temp;                /*数据 校验   0x100- */
   \   00000062   0x4260             RSBS     R0,R4,#+0
   \   00000064   0x7528             STRB     R0,[R5, #+20]
    277              
    278              data[21]=0x00;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xF88D 0x0015      STRB     R0,[SP, #+21]
    279              
    280              SendData(data,22);                  /*往USART2，发送 length长度的数据data */
   \   0000006C   0x2116             MOVS     R1,#+22
   \   0000006E   0xA800             ADD      R0,SP,#+0
   \   00000070   0x.... 0x....      BL       SendData
   \   00000074   0xE002             B.N      ??PN532_PsdVerifyKeyA_2
    281              while(!RF13P56M_rev_finish)
    282                  delay_ms(10);
   \                     ??PN532_PsdVerifyKeyA_3: (+1)
   \   00000076   0x200A             MOVS     R0,#+10
   \   00000078   0x.... 0x....      BL       delay_ms
   \                     ??PN532_PsdVerifyKeyA_2: (+1)
   \   0000007C   0x....             LDR.N    R0,??DataTable10_1
   \   0000007E   0x7800             LDRB     R0,[R0, #+0]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD0F8             BEQ.N    ??PN532_PsdVerifyKeyA_3
    283              
    284              ClearFlag();       
   \   00000084   0x.... 0x....      BL       ClearFlag
    285          	  
    286              temp=0;
   \   00000088   0x2000             MOVS     R0,#+0
    287              for(i = 11; i < 14; i ++)
   \   0000008A   0x210B             MOVS     R1,#+11
   \   0000008C   0xE003             B.N      ??PN532_PsdVerifyKeyA_4
    288              {
    289                  temp += RF13P56M_rev_buff[i];
   \                     ??PN532_PsdVerifyKeyA_5: (+1)
   \   0000008E   0x5C9A             LDRB     R2,[R3, R2]
   \   00000090   0x1810             ADDS     R0,R2,R0
   \   00000092   0xB2C0             UXTB     R0,R0
    290              }
   \   00000094   0x1C49             ADDS     R1,R1,#+1
   \                     ??PN532_PsdVerifyKeyA_4: (+1)
   \   00000096   0xB2C9             UXTB     R1,R1
   \   00000098   0x460B             MOV      R3,R1
   \   0000009A   0x....             LDR.N    R2,??DataTable10_2
   \   0000009C   0x2B0E             CMP      R3,#+14
   \   0000009E   0xDBF6             BLT.N    ??PN532_PsdVerifyKeyA_5
    291              CheckCode=0x100-temp;
    292              if(CheckCode == RF13P56M_rev_buff[14])
   \   000000A0   0x4240             RSBS     R0,R0,#+0
   \   000000A2   0x7B91             LDRB     R1,[R2, #+14]
   \   000000A4   0xB2C0             UXTB     R0,R0
   \   000000A6   0x4288             CMP      R0,R1
   \   000000A8   0xD107             BNE.N    ??PN532_PsdVerifyKeyA_6
    293              {
    294                 if(RF13P56M_rev_buff[13]==0x00)
   \   000000AA   0x7B50             LDRB     R0,[R2, #+13]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD104             BNE.N    ??PN532_PsdVerifyKeyA_6
    295                 {
    296                   CleanBuffer(40);              /*清除 串口接收缓冲区前40 个字节数据*/
   \   000000B0   0x2028             MOVS     R0,#+40
   \   000000B2   0x.... 0x....      BL       CleanBuffer
    297          		 return 0; /*验证密钥成功*/
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0xE001             B.N      ??PN532_PsdVerifyKeyA_7
    298                 }
    299          	   
    300              } 
    301          	return -1;	   /*验证密钥失败*/
   \                     ??PN532_PsdVerifyKeyA_6: (+1)
   \   000000BA   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??PN532_PsdVerifyKeyA_7: (+1)
   \   000000BE   0xB007             ADD      SP,SP,#+28
   \   000000C0   0xBD30             POP      {R4,R5,PC}       ;; return
    302          }
    303          
    304          
    305          /**
    306            * @brief		PN532_read
    307            * @details	block 读取扇区00 00 FF 05 FB D4 40 01 30 02 B9 00
    308            * @param 	block	块号
    309            * @param 	block_data	数据
    310            * @retval 	返回0为成功，返回1为失败
    311            */

   \                                 In section .text, align 2, keep-with-next
    312          int PN532_read(u8 block,u8 *block_data)
    313          {
   \                     PN532_read: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x460C             MOV      R4,R1
    314              u8 data[12];
    315              u8 temp=0; 
    316              u8 i;
    317              u8 CheckCode=0; /*数据校验码*/
    318          
    319              data[0]=0x00;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0xF8AD 0x1000      STRH     R1,[SP, #+0]
    320              data[1]=0x00;
   \   0000000C   0xA900             ADD      R1,SP,#+0
    321              data[2]=0xFF;
   \   0000000E   0x22FF             MOVS     R2,#+255
   \   00000010   0xF88D 0x2002      STRB     R2,[SP, #+2]
    322              
    323              data[3]=0x05; /*包 长度 */
   \   00000014   0x2205             MOVS     R2,#+5
   \   00000016   0xF88D 0x2003      STRB     R2,[SP, #+3]
    324              data[4]=0xFB; /*包 长度 校验  0x100-data[3]*/
   \   0000001A   0x22FB             MOVS     R2,#+251
   \   0000001C   0xF88D 0x2004      STRB     R2,[SP, #+4]
    325              
    326              data[5]=0xD4; /*命令标识码 */
   \   00000020   0x22D4             MOVS     R2,#+212
   \   00000022   0x714A             STRB     R2,[R1, #+5]
    327              data[6]=0x40; /*命令标识码  */
   \   00000024   0x2240             MOVS     R2,#+64
   \   00000026   0xF88D 0x2006      STRB     R2,[SP, #+6]
    328              
    329              data[7]=0x01;
   \   0000002A   0x2201             MOVS     R2,#+1
   \   0000002C   0xF88D 0x2007      STRB     R2,[SP, #+7]
    330              data[8]=0x30;
   \   00000030   0x2230             MOVS     R2,#+48
   \   00000032   0xF88D 0x2008      STRB     R2,[SP, #+8]
    331              data[9]=block; /*读16字节数据*/ 
   \   00000036   0xF88D 0x0009      STRB     R0,[SP, #+9]
    332              temp=0;
   \   0000003A   0x2000             MOVS     R0,#+0
    333              for(i=5;i<10;i++)
   \   0000003C   0x2205             MOVS     R2,#+5
   \   0000003E   0xE003             B.N      ??PN532_read_0
    334              {
    335                  temp+=data[i];
   \                     ??PN532_read_1: (+1)
   \   00000040   0x5C5B             LDRB     R3,[R3, R1]
   \   00000042   0x1818             ADDS     R0,R3,R0
   \   00000044   0xB2C0             UXTB     R0,R0
    336              }    
   \   00000046   0x1C52             ADDS     R2,R2,#+1
   \                     ??PN532_read_0: (+1)
   \   00000048   0xB2D2             UXTB     R2,R2
   \   0000004A   0x4613             MOV      R3,R2
   \   0000004C   0x2B0A             CMP      R3,#+10
   \   0000004E   0xDBF7             BLT.N    ??PN532_read_1
    337              data[10]=0x100-temp; /*数据校验	*/
   \   00000050   0x4240             RSBS     R0,R0,#+0
   \   00000052   0x7288             STRB     R0,[R1, #+10]
    338              data[11]=0x00;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x72C8             STRB     R0,[R1, #+11]
    339          
    340              SendData(data,12);
   \   00000058   0x210C             MOVS     R1,#+12
   \   0000005A   0xA800             ADD      R0,SP,#+0
   \   0000005C   0x.... 0x....      BL       SendData
   \   00000060   0xE002             B.N      ??PN532_read_2
    341              while(! RF13P56M_rev_finish)
    342                  delay_ms(10);
   \                     ??PN532_read_3: (+1)
   \   00000062   0x200A             MOVS     R0,#+10
   \   00000064   0x.... 0x....      BL       delay_ms
   \                     ??PN532_read_2: (+1)
   \   00000068   0x....             LDR.N    R0,??DataTable10_1
   \   0000006A   0x7800             LDRB     R0,[R0, #+0]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD0F8             BEQ.N    ??PN532_read_3
    343              
    344              ClearFlag();      
   \   00000070   0x.... 0x....      BL       ClearFlag
    345          	  
    346              temp=0;
   \   00000074   0x2000             MOVS     R0,#+0
    347              for(i = 11; i < 30; i ++)
   \   00000076   0x210B             MOVS     R1,#+11
   \   00000078   0x....             LDR.N    R3,??DataTable10_2
   \   0000007A   0xE003             B.N      ??PN532_read_4
    348              {
    349                  temp += RF13P56M_rev_buff[i];
   \                     ??PN532_read_5: (+1)
   \   0000007C   0x5CD2             LDRB     R2,[R2, R3]
   \   0000007E   0x1810             ADDS     R0,R2,R0
   \   00000080   0xB2C0             UXTB     R0,R0
    350              }
   \   00000082   0x1C49             ADDS     R1,R1,#+1
   \                     ??PN532_read_4: (+1)
   \   00000084   0xB2C9             UXTB     R1,R1
   \   00000086   0x460A             MOV      R2,R1
   \   00000088   0x2A1E             CMP      R2,#+30
   \   0000008A   0xDBF7             BLT.N    ??PN532_read_5
    351              CheckCode = 0x100 - temp;
    352              if(CheckCode == RF13P56M_rev_buff[30])
   \   0000008C   0x4240             RSBS     R0,R0,#+0
   \   0000008E   0x7F99             LDRB     R1,[R3, #+30]
   \   00000090   0xB2C0             UXTB     R0,R0
   \   00000092   0x4288             CMP      R0,R1
   \   00000094   0xD10A             BNE.N    ??PN532_read_6
    353              {
    354                  memcpy(block_data, &RF13P56M_rev_buff[14],16);
   \   00000096   0x2210             MOVS     R2,#+16
   \   00000098   0xF103 0x010E      ADD      R1,R3,#+14
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0x.... 0x....      BL       __aeabi_memcpy
    355                  CleanBuffer(40);/*清除 串口接收缓冲区前40 个字节数据*/
   \   000000A2   0x2028             MOVS     R0,#+40
   \   000000A4   0x.... 0x....      BL       CleanBuffer
    356                  return 0;     /*读卡数据成功*/
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xE004             B.N      ??PN532_read_7
    357              }
    358          	else
    359                  CleanBuffer(40);
   \                     ??PN532_read_6: (+1)
   \   000000AC   0x2028             MOVS     R0,#+40
   \   000000AE   0x.... 0x....      BL       CleanBuffer
    360          	return -1;
   \   000000B2   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??PN532_read_7: (+1)
   \   000000B6   0xB004             ADD      SP,SP,#+16
   \   000000B8   0xBD10             POP      {R4,PC}          ;; return
    361          }
    362          
    363          
    364          /**
    365            * @brief		PN532_write
    366            * @details	默认往 02区写16个字节
    367            * @param 	block	00 00 FF 15 EB D4 40 01 A0 02 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F D1 00
    368            * @param 	block_data	数据
    369            * @retval 	返回0为成功，返回1为失败
    370            */

   \                                 In section .text, align 2, keep-with-next
    371          int PN532_write(u8 block,u8 *block_data)
    372          {
   \                     PN532_write: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    373              u8 data[28];
    374              u8 temp=0;
   \   00000004   0x2400             MOVS     R4,#+0
    375              u8 i;
    376              u8 CheckCode=0;
    377              
    378              data[0]=0x00;
   \   00000006   0x4622             MOV      R2,R4
   \   00000008   0xF8AD 0x2000      STRH     R2,[SP, #+0]
    379              data[1]=0x00;
   \   0000000C   0xAD00             ADD      R5,SP,#+0
    380              data[2]=0xFF;
   \   0000000E   0x22FF             MOVS     R2,#+255
   \   00000010   0xF88D 0x2002      STRB     R2,[SP, #+2]
    381              
    382              data[3]=0x15; /*包 长度 */
   \   00000014   0x2215             MOVS     R2,#+21
   \   00000016   0xF88D 0x2003      STRB     R2,[SP, #+3]
    383              data[4]=0xEB; /*包 长度 校验  0x100-data[3]*/
   \   0000001A   0x22EB             MOVS     R2,#+235
   \   0000001C   0xF88D 0x2004      STRB     R2,[SP, #+4]
    384              
    385              data[5]=0xD4; /*命令标识码 */
   \   00000020   0x22D4             MOVS     R2,#+212
   \   00000022   0x716A             STRB     R2,[R5, #+5]
    386              data[6]=0x40; /*命令标识码*/
   \   00000024   0x2240             MOVS     R2,#+64
   \   00000026   0xF88D 0x2006      STRB     R2,[SP, #+6]
    387              
    388              data[7]=0x01; /*读写大于6字节 就置1，看手册*/
   \   0000002A   0x2201             MOVS     R2,#+1
   \   0000002C   0xF88D 0x2007      STRB     R2,[SP, #+7]
    389              data[8]=0xA0; /*写*/
   \   00000030   0x22A0             MOVS     R2,#+160
   \   00000032   0xF88D 0x2008      STRB     R2,[SP, #+8]
    390              data[9]=block; /*写16字节数据*/ 
   \   00000036   0xF88D 0x0009      STRB     R0,[SP, #+9]
    391              
    392              memcpy(&data[10],block_data,16);
   \   0000003A   0x2210             MOVS     R2,#+16
   \   0000003C   0xF10D 0x000A      ADD      R0,SP,#+10
   \   00000040   0x.... 0x....      BL       __aeabi_memcpy
    393          
    394              for(i=5;i<26;i++)
   \   00000044   0x2005             MOVS     R0,#+5
   \   00000046   0xE003             B.N      ??PN532_write_0
    395              {
    396                  temp+=data[i];
   \                     ??PN532_write_1: (+1)
   \   00000048   0x5D49             LDRB     R1,[R1, R5]
   \   0000004A   0x190C             ADDS     R4,R1,R4
   \   0000004C   0xB2E4             UXTB     R4,R4
    397              }
   \   0000004E   0x1C40             ADDS     R0,R0,#+1
   \                     ??PN532_write_0: (+1)
   \   00000050   0xB2C0             UXTB     R0,R0
   \   00000052   0x4601             MOV      R1,R0
   \   00000054   0x291A             CMP      R1,#+26
   \   00000056   0xDBF7             BLT.N    ??PN532_write_1
    398              data[26]=0x100-temp; /*数据 校验码*/
   \   00000058   0x4260             RSBS     R0,R4,#+0
   \   0000005A   0x76A8             STRB     R0,[R5, #+26]
    399              data[27]=0x00;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xF88D 0x001B      STRB     R0,[SP, #+27]
    400          
    401              SendData(data, 28);
   \   00000062   0x211C             MOVS     R1,#+28
   \   00000064   0xA800             ADD      R0,SP,#+0
   \   00000066   0x.... 0x....      BL       SendData
   \   0000006A   0xE002             B.N      ??PN532_write_2
    402              while(!RF13P56M_rev_finish)
    403                  delay_ms(10);
   \                     ??PN532_write_3: (+1)
   \   0000006C   0x200A             MOVS     R0,#+10
   \   0000006E   0x.... 0x....      BL       delay_ms
   \                     ??PN532_write_2: (+1)
   \   00000072   0x....             LDR.N    R0,??DataTable10_1
   \   00000074   0x7800             LDRB     R0,[R0, #+0]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD0F8             BEQ.N    ??PN532_write_3
    404              
    405              ClearFlag();   
   \   0000007A   0x.... 0x....      BL       ClearFlag
    406          	     
    407              /*返回00 00 FF 00 FF 00 00 00 FF 03 FD D5 41 00 EA 00 */
    408              temp=0;
   \   0000007E   0x2000             MOVS     R0,#+0
    409              for(i = 11; i < 14; i ++)
   \   00000080   0x210B             MOVS     R1,#+11
   \   00000082   0x....             LDR.N    R3,??DataTable10_2
   \   00000084   0xE003             B.N      ??PN532_write_4
    410              {
    411                  temp += RF13P56M_rev_buff[i];
   \                     ??PN532_write_5: (+1)
   \   00000086   0x5CD2             LDRB     R2,[R2, R3]
   \   00000088   0x1810             ADDS     R0,R2,R0
   \   0000008A   0xB2C0             UXTB     R0,R0
    412              }
   \   0000008C   0x1C49             ADDS     R1,R1,#+1
   \                     ??PN532_write_4: (+1)
   \   0000008E   0xB2C9             UXTB     R1,R1
   \   00000090   0x460A             MOV      R2,R1
   \   00000092   0x2A0E             CMP      R2,#+14
   \   00000094   0xDBF7             BLT.N    ??PN532_write_5
    413              CheckCode=0x100-temp;
    414              if(CheckCode==0xEA)
   \   00000096   0x4240             RSBS     R0,R0,#+0
   \   00000098   0xB2C0             UXTB     R0,R0
   \   0000009A   0x28EA             CMP      R0,#+234
   \   0000009C   0xD104             BNE.N    ??PN532_write_6
    415              {
    416                  CleanBuffer(40);/*清除 串口接收缓冲区前40 个字节数据	*/
   \   0000009E   0x2028             MOVS     R0,#+40
   \   000000A0   0x.... 0x....      BL       CleanBuffer
    417                  return 0;/*写卡数据成功*/  
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xE004             B.N      ??PN532_write_7
    418              }
    419          	else
    420          		CleanBuffer(40);	
   \                     ??PN532_write_6: (+1)
   \   000000A8   0x2028             MOVS     R0,#+40
   \   000000AA   0x.... 0x....      BL       CleanBuffer
    421              return -1;
   \   000000AE   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??PN532_write_7: (+1)
   \   000000B2   0xB007             ADD      SP,SP,#+28
   \   000000B4   0xBD30             POP      {R4,R5,PC}       ;; return
    422          }
    423          
    424          /**
    425            * @brief		串口2数据发送函数
    426            * @details	
    427            * @param Data	数据缓存
    428            * @param len	数据长度
    429            * @retval 	无
    430            */

   \                                 In section .text, align 2, keep-with-next
    431          static void SendData(u8 *data,u8 len)
    432          {
   \                     SendData: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    433          	u16 i;
    434          	for(i=0;i<len;i++)
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x....             LDR.N    R7,??DataTable10_3  ;; 0x40013800
   \   0000000A   0xE00A             B.N      ??SendData_0
    435          	{
    436          		USART_SendData(USART1, data[i]);
   \                     ??SendData_1: (+1)
   \   0000000C   0x5D31             LDRB     R1,[R6, R4]
   \   0000000E   0x4638             MOV      R0,R7
   \   00000010   0x.... 0x....      BL       USART_SendData
    437          		/* Loop until the end of transmission */
    438          		while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
   \                     ??SendData_2: (+1)
   \   00000014   0x2180             MOVS     R1,#+128
   \   00000016   0x4638             MOV      R0,R7
   \   00000018   0x.... 0x....      BL       USART_GetFlagStatus
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD0F9             BEQ.N    ??SendData_2
    439          	}
   \   00000020   0x1C76             ADDS     R6,R6,#+1
   \                     ??SendData_0: (+1)
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0xB2B6             UXTH     R6,R6
   \   00000026   0x4286             CMP      R6,R0
   \   00000028   0xD3F0             BCC.N    ??SendData_1
    440          }
   \   0000002A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    441          
    442          
    443          /**
    444            * @brief		CleanBuffer
    445            * @details	清零前多少个字节的数据
    446            * @param 	num 字节数
    447            * @retval 	NULL 无
    448            */

   \                                 In section .text, align 2, keep-with-next
    449          static void CleanBuffer(u16 num)
    450          {
    451          	memset(RF13P56M_rev_buff,0,num);
   \                     CleanBuffer: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x4601             MOV      R1,R0
   \   00000004   0x....             LDR.N    R0,??DataTable10_2
   \   00000006   0x.... 0x....      B.W      __aeabi_memset4
    452          }
    453          
    454          
    455          /**
    456            * @brief		ClearFlag
    457            * @details	清除标志位
    458            * @param 	NULL 无
    459            * @retval 	NULL 无
    460            */

   \                                 In section .text, align 2, keep-with-next
    461          static void ClearFlag(void)
    462          {
    463          	RF13P56M_rev_finish = 0;
   \                     ClearFlag: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_1
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x7001             STRB     R1,[R0, #+0]
    464          	RF13P56M_rev_buff_cnt = 0;
   \   00000006   0x8041             STRH     R1,[R0, #+2]
    465          	RF13P56M_rev_timeout = 0;        
   \   00000008   0x8081             STRH     R1,[R0, #+4]
    466          }
   \   0000000A   0x4770             BX       LR               ;; return
    467          
    468          /**
    469            * @brief		delay_ms
    470            * @details	系统延时
    471            * @param 	uint32_t ms
    472            * @retval 	NULL 无
    473            */

   \                                 In section .text, align 2, keep-with-next
    474          void delay_ms(u32 ms)
    475          {
    476          	OSTimeDly(ms);
   \                     delay_ms: (+1)
   \   00000000   0xB280             UXTH     R0,R0
   \   00000002   0x.... 0x....      B.W      OSTimeDly
    477          }
    478          
    479          /**
    480            * @brief   13.56M串口接收数据
    481            * @param   packet 数据包
    482            * @retval  寻标签结果
    483           */

   \                                 In section .text, align 2, keep-with-next
    484          void RF3P56MRecvData(void)
    485          {
   \                     RF3P56MRecvData: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    486          	TIM_Cmd(TIM2, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000008   0x.... 0x....      BL       TIM_Cmd
    487          	RF13P56M_rev_timeout = 0;
   \   0000000C   0x....             LDR.N    R4,??DataTable10_1
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x80A0             STRH     R0,[R4, #+4]
    488          	USART_ClearITPendingBit(USART1, USART_IT_RXNE);
   \   00000012   0x....             LDR.N    R5,??DataTable10_3  ;; 0x40013800
   \   00000014   0xF240 0x5125      MOVW     R1,#+1317
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x.... 0x....      BL       USART_ClearITPendingBit
    489          	RF13P56M_rev_buff[RF13P56M_rev_buff_cnt % RF13P56M_BUFFSIZE] = USART_ReceiveData(USART1);
   \   0000001E   0x8860             LDRH     R0,[R4, #+2]
   \   00000020   0x21C8             MOVS     R1,#+200
   \   00000022   0xFB90 0xF1F1      SDIV     R1,R0,R1
   \   00000026   0x22C8             MOVS     R2,#+200
   \   00000028   0xFB02 0x0611      MLS      R6,R2,R1,R0
   \   0000002C   0x....             LDR.N    R7,??DataTable10_2
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0x.... 0x....      BL       USART_ReceiveData
   \   00000034   0x55F0             STRB     R0,[R6, R7]
    490          	RF13P56M_rev_buff_cnt++; 
   \   00000036   0x8860             LDRH     R0,[R4, #+2]
   \   00000038   0x1C40             ADDS     R0,R0,#+1
   \   0000003A   0x8060             STRH     R0,[R4, #+2]
    491          }
   \   0000003C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     RF13P56M_rev_finish

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     RF13P56M_rev_buff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x40013800         DC32     0x40013800

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   BSP_IntHandlerTIM2
         0   -> OSIntExit
         8   -> OS_CPU_SR_Restore
         8   -> OS_CPU_SR_Save
         8   -> TIM_ClearITPendingBit
         8   -> TIM_Cmd
         8   -> TIM_GetITStatus
       0   CleanBuffer
         0   -> __aeabi_memset4
       0   ClearFlag
      32   PN532_InListPassiveTarget
        32   -> CleanBuffer
        32   -> ClearFlag
        32   -> SendData
        32   -> __aeabi_memcpy
        32   -> delay_ms
        32   -> memcmp
      40   PN532_PsdVerifyKeyA
        40   -> CleanBuffer
        40   -> ClearFlag
        40   -> SendData
        40   -> __aeabi_memcpy
        40   -> delay_ms
      40   PN532_WakeUp
        40   -> CleanBuffer
        40   -> ClearFlag
        40   -> SendData
        40   -> delay_ms
       8   PN532_init
         0   -> PN532_WakeUp
         8   -> RF13P56M_Tim2_Init
      24   PN532_read
        24   -> CleanBuffer
        24   -> ClearFlag
        24   -> SendData
        24   -> __aeabi_memcpy
        24   -> delay_ms
      40   PN532_write
        40   -> CleanBuffer
        40   -> ClearFlag
        40   -> SendData
        40   -> __aeabi_memcpy
        40   -> delay_ms
      24   RF13P56M_Tim2_Init
        24   -> BSP_IntEn
        24   -> BSP_IntVectSet
        24   -> NVIC_Init
        24   -> NVIC_PriorityGroupConfig
        24   -> RCC_APB1PeriphClockCmd
        24   -> TIM_ClearFlag
        24   -> TIM_DeInit
        24   -> TIM_ITConfig
        24   -> TIM_TimeBaseInit
      24   RF3P56MRecvData
        24   -> TIM_Cmd
        24   -> USART_ClearITPendingBit
        24   -> USART_ReceiveData
      24   SendData
        24   -> USART_GetFlagStatus
        24   -> USART_SendData
       0   delay_ms
         0   -> OSTimeDly


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ?_0
      88  BSP_IntHandlerTIM2
      10  CleanBuffer
      12  ClearFlag
     198  PN532_InListPassiveTarget
     194  PN532_PsdVerifyKeyA
     176  PN532_WakeUp
      12  PN532_init
     186  PN532_read
     182  PN532_write
     134  RF13P56M_Tim2_Init
     200  RF13P56M_rev_buff
       6  RF13P56M_rev_finish
          RF13P56M_rev_buff_cnt
          RF13P56M_rev_timeout
      62  RF3P56MRecvData
      44  SendData
       6  delay_ms

 
   206 bytes in section .bss
     4 bytes in section .rodata
 1 320 bytes in section .text
 
 1 320 bytes of CODE  memory
     4 bytes of CONST memory
   206 bytes of DATA  memory

Errors: none
Warnings: none
