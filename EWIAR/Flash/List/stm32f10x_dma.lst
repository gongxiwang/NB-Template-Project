###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        12/Jul/2019  09:14:41
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\UCOS-II\CPU\src\stm32f10x_dma.c
#    Command line =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\UCOS-II\CPU\src\stm32f10x_dma.c
#        -D LORA_MODULE -lCN
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\List\ -o
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\Softwares\IAR7.40\arm\INC\c\DLib_Config_Full.h -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\CPU\inc\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-CPU\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-CPU\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-LIB\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-OSII\Ports\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-OSII\Source\
#        -I E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\USER\BSP\
#        -I E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\USER\APP\
#        -Om --use_c++_inline
#    List file    =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\List\stm32f10x_dma.lst
#    Object file  =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\Obj\stm32f10x_dma.o
#
###############################################################################

E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\UCOS-II\CPU\src\stm32f10x_dma.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : stm32f10x_dma.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.0
      5          * Date               : 05/23/2008
      6          * Description        : This file provides all the DMA firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
     15          * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     16          *******************************************************************************/
     17          
     18          /* Includes ------------------------------------------------------------------*/
     19          #include "stm32f10x_dma.h"
     20          #include "stm32f10x_rcc.h"
     21          
     22          /* Private typedef -----------------------------------------------------------*/
     23          /* Private define ------------------------------------------------------------*/
     24          /* DMA ENABLE mask */
     25          #define CCR_ENABLE_Set          ((u32)0x00000001)
     26          #define CCR_ENABLE_Reset        ((u32)0xFFFFFFFE)
     27          
     28          /* DMA1 Channelx interrupt pending bit masks */
     29          #define DMA1_Channel1_IT_Mask    ((u32)0x0000000F)
     30          #define DMA1_Channel2_IT_Mask    ((u32)0x000000F0)
     31          #define DMA1_Channel3_IT_Mask    ((u32)0x00000F00)
     32          #define DMA1_Channel4_IT_Mask    ((u32)0x0000F000)
     33          #define DMA1_Channel5_IT_Mask    ((u32)0x000F0000)
     34          #define DMA1_Channel6_IT_Mask    ((u32)0x00F00000)
     35          #define DMA1_Channel7_IT_Mask    ((u32)0x0F000000)
     36          
     37          /* DMA2 Channelx interrupt pending bit masks */
     38          #define DMA2_Channel1_IT_Mask    ((u32)0x0000000F)
     39          #define DMA2_Channel2_IT_Mask    ((u32)0x000000F0)
     40          #define DMA2_Channel3_IT_Mask    ((u32)0x00000F00)
     41          #define DMA2_Channel4_IT_Mask    ((u32)0x0000F000)
     42          #define DMA2_Channel5_IT_Mask    ((u32)0x000F0000)
     43          
     44          /* DMA2 FLAG mask */
     45          #define FLAG_Mask                ((u32)0x10000000)
     46          
     47          /* DMA registers Masks */
     48          #define CCR_CLEAR_Mask           ((u32)0xFFFF800F)
     49          
     50          /* Private macro -------------------------------------------------------------*/
     51          /* Private variables ---------------------------------------------------------*/
     52          /* Private function prototypes -----------------------------------------------*/
     53          /* Private functions ---------------------------------------------------------*/
     54          
     55          /*******************************************************************************
     56          * Function Name  : DMA_DeInit
     57          * Description    : Deinitializes the DMAy Channelx registers to their default reset
     58          *                  values.
     59          * Input          : - DMAy_Channelx: where y can be 1 or 2 to select the DMA and
     60          *                    x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the 
     61          *                    DMA Channel.
     62          * Output         : None
     63          * Return         : None
     64          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     65          void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx)
     66          {
     67            /* Check the parameters */
     68            assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
     69          
     70            /* Disable the selected DMAy Channelx */
     71            DMAy_Channelx->CCR &= CCR_ENABLE_Reset;
   \                     DMA_DeInit: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x0849             LSRS     R1,R1,#+1
   \   00000004   0x0049             LSLS     R1,R1,#+1
   \   00000006   0x6001             STR      R1,[R0, #+0]
     72          
     73            /* Reset DMAy Channelx control register */
     74            DMAy_Channelx->CCR  = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6001             STR      R1,[R0, #+0]
     75            
     76            /* Reset DMAy Channelx remaining bytes register */
     77            DMAy_Channelx->CNDTR = 0;
   \   0000000C   0x6041             STR      R1,[R0, #+4]
     78            
     79            /* Reset DMAy Channelx peripheral address register */
     80            DMAy_Channelx->CPAR  = 0;
   \   0000000E   0x6081             STR      R1,[R0, #+8]
     81            
     82            /* Reset DMAy Channelx memory address register */
     83            DMAy_Channelx->CMAR = 0;
   \   00000010   0x60C1             STR      R1,[R0, #+12]
     84          
     85            switch (*(u32*)&DMAy_Channelx)
   \   00000012   0x....             LDR.N    R1,??DataTable4  ;; 0x40020008
   \   00000014   0x1A40             SUBS     R0,R0,R1
   \   00000016   0xD018             BEQ.N    ??DMA_DeInit_0
   \   00000018   0x3814             SUBS     R0,R0,#+20
   \   0000001A   0xD01C             BEQ.N    ??DMA_DeInit_1
   \   0000001C   0x3814             SUBS     R0,R0,#+20
   \   0000001E   0xD020             BEQ.N    ??DMA_DeInit_2
   \   00000020   0x3814             SUBS     R0,R0,#+20
   \   00000022   0xD024             BEQ.N    ??DMA_DeInit_3
   \   00000024   0x3814             SUBS     R0,R0,#+20
   \   00000026   0xD028             BEQ.N    ??DMA_DeInit_4
   \   00000028   0x3814             SUBS     R0,R0,#+20
   \   0000002A   0xD02C             BEQ.N    ??DMA_DeInit_5
   \   0000002C   0x3814             SUBS     R0,R0,#+20
   \   0000002E   0xD030             BEQ.N    ??DMA_DeInit_6
   \   00000030   0xF44F 0x7162      MOV      R1,#+904
   \   00000034   0x1A40             SUBS     R0,R0,R1
   \   00000036   0xD032             BEQ.N    ??DMA_DeInit_7
   \   00000038   0x3814             SUBS     R0,R0,#+20
   \   0000003A   0xD036             BEQ.N    ??DMA_DeInit_8
   \   0000003C   0x3814             SUBS     R0,R0,#+20
   \   0000003E   0xD03A             BEQ.N    ??DMA_DeInit_9
   \   00000040   0x3814             SUBS     R0,R0,#+20
   \   00000042   0xD03E             BEQ.N    ??DMA_DeInit_10
   \   00000044   0x3814             SUBS     R0,R0,#+20
   \   00000046   0xD042             BEQ.N    ??DMA_DeInit_11
   \   00000048   0x4770             BX       LR
     86            {
     87              case DMA1_Channel1_BASE:
     88                /* Reset interrupt pending bits for DMA1 Channel1 */
     89                DMA1->IFCR |= DMA1_Channel1_IT_Mask;
   \                     ??DMA_DeInit_0: (+1)
   \   0000004A   0x....             LDR.N    R0,??DataTable4_1  ;; 0x40020004
   \   0000004C   0x6801             LDR      R1,[R0, #+0]
   \   0000004E   0xF041 0x010F      ORR      R1,R1,#0xF
   \   00000052   0x6001             STR      R1,[R0, #+0]
     90                break;
   \   00000054   0x4770             BX       LR
     91          
     92              case DMA1_Channel2_BASE:
     93                /* Reset interrupt pending bits for DMA1 Channel2 */
     94                DMA1->IFCR |= DMA1_Channel2_IT_Mask;
   \                     ??DMA_DeInit_1: (+1)
   \   00000056   0x....             LDR.N    R0,??DataTable4_1  ;; 0x40020004
   \   00000058   0x6801             LDR      R1,[R0, #+0]
   \   0000005A   0xF041 0x01F0      ORR      R1,R1,#0xF0
   \   0000005E   0x6001             STR      R1,[R0, #+0]
     95                break;
   \   00000060   0x4770             BX       LR
     96          
     97              case DMA1_Channel3_BASE:
     98                /* Reset interrupt pending bits for DMA1 Channel3 */
     99                DMA1->IFCR |= DMA1_Channel3_IT_Mask;
   \                     ??DMA_DeInit_2: (+1)
   \   00000062   0x....             LDR.N    R0,??DataTable4_1  ;; 0x40020004
   \   00000064   0x6801             LDR      R1,[R0, #+0]
   \   00000066   0xF441 0x6170      ORR      R1,R1,#0xF00
   \   0000006A   0x6001             STR      R1,[R0, #+0]
    100                break;
   \   0000006C   0x4770             BX       LR
    101          
    102              case DMA1_Channel4_BASE:
    103                /* Reset interrupt pending bits for DMA1 Channel4 */
    104                DMA1->IFCR |= DMA1_Channel4_IT_Mask;
   \                     ??DMA_DeInit_3: (+1)
   \   0000006E   0x....             LDR.N    R0,??DataTable4_1  ;; 0x40020004
   \   00000070   0x6801             LDR      R1,[R0, #+0]
   \   00000072   0xF441 0x4170      ORR      R1,R1,#0xF000
   \   00000076   0x6001             STR      R1,[R0, #+0]
    105                break;
   \   00000078   0x4770             BX       LR
    106          
    107              case DMA1_Channel5_BASE:
    108                /* Reset interrupt pending bits for DMA1 Channel5 */
    109                DMA1->IFCR |= DMA1_Channel5_IT_Mask;
   \                     ??DMA_DeInit_4: (+1)
   \   0000007A   0x....             LDR.N    R0,??DataTable4_1  ;; 0x40020004
   \   0000007C   0x6801             LDR      R1,[R0, #+0]
   \   0000007E   0xF441 0x2170      ORR      R1,R1,#0xF0000
   \   00000082   0x6001             STR      R1,[R0, #+0]
    110                break;
   \   00000084   0x4770             BX       LR
    111          
    112              case DMA1_Channel6_BASE:
    113                /* Reset interrupt pending bits for DMA1 Channel6 */
    114                DMA1->IFCR |= DMA1_Channel6_IT_Mask;
   \                     ??DMA_DeInit_5: (+1)
   \   00000086   0x....             LDR.N    R0,??DataTable4_1  ;; 0x40020004
   \   00000088   0x6801             LDR      R1,[R0, #+0]
   \   0000008A   0xF441 0x0170      ORR      R1,R1,#0xF00000
   \   0000008E   0x6001             STR      R1,[R0, #+0]
    115                break;
   \   00000090   0x4770             BX       LR
    116          
    117              case DMA1_Channel7_BASE:
    118                /* Reset interrupt pending bits for DMA1 Channel7 */
    119                DMA1->IFCR |= DMA1_Channel7_IT_Mask;
   \                     ??DMA_DeInit_6: (+1)
   \   00000092   0x....             LDR.N    R0,??DataTable4_1  ;; 0x40020004
   \   00000094   0x6801             LDR      R1,[R0, #+0]
   \   00000096   0xF041 0x6170      ORR      R1,R1,#0xF000000
   \   0000009A   0x6001             STR      R1,[R0, #+0]
    120                break;
   \   0000009C   0x4770             BX       LR
    121          
    122              case DMA2_Channel1_BASE:
    123                /* Reset interrupt pending bits for DMA2 Channel1 */
    124                DMA2->IFCR |= DMA2_Channel1_IT_Mask;
   \                     ??DMA_DeInit_7: (+1)
   \   0000009E   0x....             LDR.N    R0,??DataTable4_2  ;; 0x40020404
   \   000000A0   0x6801             LDR      R1,[R0, #+0]
   \   000000A2   0xF041 0x010F      ORR      R1,R1,#0xF
   \   000000A6   0x6001             STR      R1,[R0, #+0]
    125                break;
   \   000000A8   0x4770             BX       LR
    126          
    127              case DMA2_Channel2_BASE:
    128                /* Reset interrupt pending bits for DMA2 Channel2 */
    129                DMA2->IFCR |= DMA2_Channel2_IT_Mask;
   \                     ??DMA_DeInit_8: (+1)
   \   000000AA   0x....             LDR.N    R0,??DataTable4_2  ;; 0x40020404
   \   000000AC   0x6801             LDR      R1,[R0, #+0]
   \   000000AE   0xF041 0x01F0      ORR      R1,R1,#0xF0
   \   000000B2   0x6001             STR      R1,[R0, #+0]
    130                break;
   \   000000B4   0x4770             BX       LR
    131          
    132              case DMA2_Channel3_BASE:
    133                /* Reset interrupt pending bits for DMA2 Channel3 */
    134                DMA2->IFCR |= DMA2_Channel3_IT_Mask;
   \                     ??DMA_DeInit_9: (+1)
   \   000000B6   0x....             LDR.N    R0,??DataTable4_2  ;; 0x40020404
   \   000000B8   0x6801             LDR      R1,[R0, #+0]
   \   000000BA   0xF441 0x6170      ORR      R1,R1,#0xF00
   \   000000BE   0x6001             STR      R1,[R0, #+0]
    135                break;
   \   000000C0   0x4770             BX       LR
    136          
    137              case DMA2_Channel4_BASE:
    138                /* Reset interrupt pending bits for DMA2 Channel4 */
    139                DMA2->IFCR |= DMA2_Channel4_IT_Mask;
   \                     ??DMA_DeInit_10: (+1)
   \   000000C2   0x....             LDR.N    R0,??DataTable4_2  ;; 0x40020404
   \   000000C4   0x6801             LDR      R1,[R0, #+0]
   \   000000C6   0xF441 0x4170      ORR      R1,R1,#0xF000
   \   000000CA   0x6001             STR      R1,[R0, #+0]
    140                break;
   \   000000CC   0x4770             BX       LR
    141          
    142              case DMA2_Channel5_BASE:
    143                /* Reset interrupt pending bits for DMA2 Channel5 */
    144                DMA2->IFCR |= DMA2_Channel5_IT_Mask;
   \                     ??DMA_DeInit_11: (+1)
   \   000000CE   0x....             LDR.N    R0,??DataTable4_2  ;; 0x40020404
   \   000000D0   0x6801             LDR      R1,[R0, #+0]
   \   000000D2   0xF441 0x2170      ORR      R1,R1,#0xF0000
   \   000000D6   0x6001             STR      R1,[R0, #+0]
    145                break;
    146                
    147              default:
    148                break;
    149            }
    150          }
   \   000000D8   0x4770             BX       LR               ;; return
    151          
    152          /*******************************************************************************
    153          * Function Name  : DMA_Init
    154          * Description    : Initializes the DMAy Channelx according to the specified
    155          *                  parameters in the DMA_InitStruct.
    156          * Input          : - DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
    157          *                    x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the 
    158          *                    DMA Channel.
    159          *                  - DMA_InitStruct: pointer to a DMA_InitTypeDef structure that
    160          *                    contains the configuration information for the specified
    161          *                    DMA Channel.
    162          * Output         : None
    163          * Return         : None
    164          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    165          void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)
    166          {
    167            u32 tmpreg = 0;
    168          
    169            /* Check the parameters */
    170            assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
    171            assert_param(IS_DMA_DIR(DMA_InitStruct->DMA_DIR));
    172            assert_param(IS_DMA_BUFFER_SIZE(DMA_InitStruct->DMA_BufferSize));
    173            assert_param(IS_DMA_PERIPHERAL_INC_STATE(DMA_InitStruct->DMA_PeripheralInc));
    174            assert_param(IS_DMA_MEMORY_INC_STATE(DMA_InitStruct->DMA_MemoryInc));   
    175            assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(DMA_InitStruct->DMA_PeripheralDataSize));
    176            assert_param(IS_DMA_MEMORY_DATA_SIZE(DMA_InitStruct->DMA_MemoryDataSize));
    177            assert_param(IS_DMA_MODE(DMA_InitStruct->DMA_Mode));
    178            assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
    179            assert_param(IS_DMA_M2M_STATE(DMA_InitStruct->DMA_M2M));
    180          
    181          /*--------------------------- DMAy Channelx CCR Configuration -----------------*/
    182            /* Get the DMAy_Channelx CCR value */
    183            tmpreg = DMAy_Channelx->CCR;
   \                     DMA_Init: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
    184            /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
    185            tmpreg &= CCR_CLEAR_Mask;
    186            /* Configure DMAy Channelx: data transfer, data size, priority level and mode */
    187            /* Set DIR bit according to DMA_DIR value */
    188            /* Set CIRC bit according to DMA_Mode value */
    189            /* Set PINC bit according to DMA_PeripheralInc value */
    190            /* Set MINC bit according to DMA_MemoryInc value */
    191            /* Set PSIZE bits according to DMA_PeripheralDataSize value */
    192            /* Set MSIZE bits according to DMA_MemoryDataSize value */
    193            /* Set PL bits according to DMA_Priority value */
    194            /* Set the MEM2MEM bit according to DMA_M2M value */
    195            tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
    196                      DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
    197                      DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
    198                      DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
    199            /* Write to DMAy Channelx CCR */
    200            DMAy_Channelx->CCR = tmpreg;
   \   00000002   0xF36F 0x120E      BFC      R2,#+4,#+11
   \   00000006   0x688B             LDR      R3,[R1, #+8]
   \   00000008   0x431A             ORRS     R2,R3,R2
   \   0000000A   0x6A0B             LDR      R3,[R1, #+32]
   \   0000000C   0x431A             ORRS     R2,R3,R2
   \   0000000E   0x690B             LDR      R3,[R1, #+16]
   \   00000010   0x431A             ORRS     R2,R3,R2
   \   00000012   0x694B             LDR      R3,[R1, #+20]
   \   00000014   0x431A             ORRS     R2,R3,R2
   \   00000016   0x698B             LDR      R3,[R1, #+24]
   \   00000018   0x431A             ORRS     R2,R3,R2
   \   0000001A   0x69CB             LDR      R3,[R1, #+28]
   \   0000001C   0x431A             ORRS     R2,R3,R2
   \   0000001E   0x6A4B             LDR      R3,[R1, #+36]
   \   00000020   0x431A             ORRS     R2,R3,R2
   \   00000022   0x6A8B             LDR      R3,[R1, #+40]
   \   00000024   0x431A             ORRS     R2,R3,R2
   \   00000026   0x6002             STR      R2,[R0, #+0]
    201          
    202          /*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
    203            /* Write to DMAy Channelx CNDTR */
    204            DMAy_Channelx->CNDTR = DMA_InitStruct->DMA_BufferSize;
   \   00000028   0x68CA             LDR      R2,[R1, #+12]
   \   0000002A   0x6042             STR      R2,[R0, #+4]
    205          
    206          /*--------------------------- DMAy Channelx CPAR Configuration ----------------*/
    207            /* Write to DMAy Channelx CPAR */
    208            DMAy_Channelx->CPAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
   \   0000002C   0x680A             LDR      R2,[R1, #+0]
   \   0000002E   0x6082             STR      R2,[R0, #+8]
    209          
    210          /*--------------------------- DMAy Channelx CMAR Configuration ----------------*/
    211            /* Write to DMAy Channelx CMAR */
    212            DMAy_Channelx->CMAR = DMA_InitStruct->DMA_MemoryBaseAddr;
   \   00000030   0x6849             LDR      R1,[R1, #+4]
   \   00000032   0x60C1             STR      R1,[R0, #+12]
    213          }
   \   00000034   0x4770             BX       LR               ;; return
    214          
    215          /*******************************************************************************
    216          * Function Name  : DMA_StructInit
    217          * Description    : Fills each DMA_InitStruct member with its default value.
    218          * Input          : - DMA_InitStruct : pointer to a DMA_InitTypeDef structure
    219          *                    which will be initialized.
    220          * Output         : None
    221          * Return         : None
    222          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    223          void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
    224          {
    225          /*-------------- Reset DMA init structure parameters values ------------------*/
    226            /* Initialize the DMA_PeripheralBaseAddr member */
    227            DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
   \                     DMA_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    228          
    229            /* Initialize the DMA_MemoryBaseAddr member */
    230            DMA_InitStruct->DMA_MemoryBaseAddr = 0;
   \   00000004   0x6041             STR      R1,[R0, #+4]
    231          
    232            /* Initialize the DMA_DIR member */
    233            DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralSRC;
   \   00000006   0x6081             STR      R1,[R0, #+8]
    234          
    235            /* Initialize the DMA_BufferSize member */
    236            DMA_InitStruct->DMA_BufferSize = 0;
   \   00000008   0x60C1             STR      R1,[R0, #+12]
    237          
    238            /* Initialize the DMA_PeripheralInc member */
    239            DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
   \   0000000A   0x6101             STR      R1,[R0, #+16]
    240          
    241            /* Initialize the DMA_MemoryInc member */
    242            DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
   \   0000000C   0x6141             STR      R1,[R0, #+20]
    243          
    244            /* Initialize the DMA_PeripheralDataSize member */
    245            DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
   \   0000000E   0x6181             STR      R1,[R0, #+24]
    246          
    247            /* Initialize the DMA_MemoryDataSize member */
    248            DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
   \   00000010   0x61C1             STR      R1,[R0, #+28]
    249          
    250            /* Initialize the DMA_Mode member */
    251            DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
   \   00000012   0x6201             STR      R1,[R0, #+32]
    252          
    253            /* Initialize the DMA_Priority member */
    254            DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
   \   00000014   0x6241             STR      R1,[R0, #+36]
    255          
    256            /* Initialize the DMA_M2M member */
    257            DMA_InitStruct->DMA_M2M = DMA_M2M_Disable;
   \   00000016   0x6281             STR      R1,[R0, #+40]
    258          }
   \   00000018   0x4770             BX       LR               ;; return
    259          
    260          /*******************************************************************************
    261          * Function Name  : DMA_Cmd
    262          * Description    : Enables or disables the specified DMAy Channelx.
    263          * Input          : - DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
    264          *                    x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the 
    265          *                    DMA Channel.
    266          *                  - NewState: new state of the DMAy Channelx. 
    267          *                    This parameter can be: ENABLE or DISABLE.
    268          * Output         : None
    269          * Return         : None
    270          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    271          void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)
    272          {
    273            /* Check the parameters */
    274            assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
    275            assert_param(IS_FUNCTIONAL_STATE(NewState));
    276          
    277            if (NewState != DISABLE)
   \                     DMA_Cmd: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xD003             BEQ.N    ??DMA_Cmd_0
    278            {
    279              /* Enable the selected DMAy Channelx */
    280              DMAy_Channelx->CCR |= CCR_ENABLE_Set;
   \   00000006   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0x4770             BX       LR
    281            }
    282            else
    283            {
    284              /* Disable the selected DMAy Channelx */
    285              DMAy_Channelx->CCR &= CCR_ENABLE_Reset;
   \                     ??DMA_Cmd_0: (+1)
   \   0000000E   0x0849             LSRS     R1,R1,#+1
   \   00000010   0x0049             LSLS     R1,R1,#+1
   \   00000012   0x6001             STR      R1,[R0, #+0]
    286            }
    287          }
   \   00000014   0x4770             BX       LR               ;; return
    288          
    289          /*******************************************************************************
    290          * Function Name  : DMA_ITConfig
    291          * Description    : Enables or disables the specified DMAy Channelx interrupts.
    292          * Input          : - DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
    293          *                    x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the 
    294          *                    DMA Channel.
    295          *                  - DMA_IT: specifies the DMA interrupts sources to be enabled
    296          *                    or disabled. 
    297          *                    This parameter can be any combination of the following values:
    298          *                       - DMA_IT_TC:  Transfer complete interrupt mask
    299          *                       - DMA_IT_HT:  Half transfer interrupt mask
    300          *                       - DMA_IT_TE:  Transfer error interrupt mask
    301          *                  - NewState: new state of the specified DMA interrupts.
    302          *                    This parameter can be: ENABLE or DISABLE.
    303          * Output         : None
    304          * Return         : None
    305          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    306          void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, u32 DMA_IT, FunctionalState NewState)
    307          {
    308            /* Check the parameters */
    309            assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
    310            assert_param(IS_DMA_CONFIG_IT(DMA_IT));
    311            assert_param(IS_FUNCTIONAL_STATE(NewState));
    312          
    313            if (NewState != DISABLE)
   \                     DMA_ITConfig: (+1)
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   \   00000004   0xD002             BEQ.N    ??DMA_ITConfig_0
    314            {
    315              /* Enable the selected DMA interrupts */
    316              DMAy_Channelx->CCR |= DMA_IT;
   \   00000006   0x4311             ORRS     R1,R1,R2
   \   00000008   0x6001             STR      R1,[R0, #+0]
   \   0000000A   0x4770             BX       LR
    317            }
    318            else
    319            {
    320              /* Disable the selected DMA interrupts */
    321              DMAy_Channelx->CCR &= ~DMA_IT;
   \                     ??DMA_ITConfig_0: (+1)
   \   0000000C   0xEA22 0x0101      BIC      R1,R2,R1
   \   00000010   0x6001             STR      R1,[R0, #+0]
    322            }
    323          }
   \   00000012   0x4770             BX       LR               ;; return
    324          /**
    325            * @brief  Sets the number of data units in the current DMAy Channelx transfer.
    326            * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
    327            *         x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
    328            * @param  DataNumber: The number of data units in the current DMAy Channelx
    329            *         transfer.   
    330            * @note   This function can only be used when the DMAy_Channelx is disabled.                 
    331            * @retval None.
    332            */

   \                                 In section .text, align 2, keep-with-next
    333          void DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx, u16 DataNumber)
    334          {
    335            /* Check the parameters */
    336            assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
    337            
    338          /*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
    339            /* Write to DMAy Channelx CNDTR */
    340            DMAy_Channelx->CNDTR = DataNumber;  
   \                     DMA_SetCurrDataCounter: (+1)
   \   00000000   0x6041             STR      R1,[R0, #+4]
    341          }
   \   00000002   0x4770             BX       LR               ;; return
    342          
    343          /*******************************************************************************
    344          * Function Name  : DMA_GetCurrDataCounter
    345          * Description    : Returns the number of remaining data units in the current
    346          *                  DMAy Channelx transfer.
    347          * Input          : - DMAy_Channelx: where y can be 1 or 2 to select the DMA and 
    348          *                    x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the 
    349          *                    DMA Channel.
    350          * Output         : None
    351          * Return         : The number of remaining data units in the current DMAy Channelx
    352          *                  transfer.
    353          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    354          u16 DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx)
    355          {
    356            /* Check the parameters */
    357            assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
    358          
    359            /* Return the number of remaining data units for DMAy Channelx */
    360            return ((u16)(DMAy_Channelx->CNDTR));
   \                     DMA_GetCurrDataCounter: (+1)
   \   00000000   0x6840             LDR      R0,[R0, #+4]
   \   00000002   0xB280             UXTH     R0,R0
   \   00000004   0x4770             BX       LR               ;; return
    361          }
    362          
    363          /*******************************************************************************
    364          * Function Name  : DMA_GetFlagStatus
    365          * Description    : Checks whether the specified DMAy Channelx flag is set or not.
    366          * Input          : - DMA_FLAG: specifies the flag to check.
    367          *                    This parameter can be one of the following values:
    368          *                       - DMA1_FLAG_GL1: DMA1 Channel1 global flag.
    369          *                       - DMA1_FLAG_TC1: DMA1 Channel1 transfer complete flag.
    370          *                       - DMA1_FLAG_HT1: DMA1 Channel1 half transfer flag.
    371          *                       - DMA1_FLAG_TE1: DMA1 Channel1 transfer error flag.
    372          *                       - DMA1_FLAG_GL2: DMA1 Channel2 global flag.
    373          *                       - DMA1_FLAG_TC2: DMA1 Channel2 transfer complete flag.
    374          *                       - DMA1_FLAG_HT2: DMA1 Channel2 half transfer flag.
    375          *                       - DMA1_FLAG_TE2: DMA1 Channel2 transfer error flag.
    376          *                       - DMA1_FLAG_GL3: DMA1 Channel3 global flag.
    377          *                       - DMA1_FLAG_TC3: DMA1 Channel3 transfer complete flag.
    378          *                       - DMA1_FLAG_HT3: DMA1 Channel3 half transfer flag.
    379          *                       - DMA1_FLAG_TE3: DMA1 Channel3 transfer error flag.
    380          *                       - DMA1_FLAG_GL4: DMA1 Channel4 global flag.
    381          *                       - DMA1_FLAG_TC4: DMA1 Channel4 transfer complete flag.
    382          *                       - DMA1_FLAG_HT4: DMA1 Channel4 half transfer flag.
    383          *                       - DMA1_FLAG_TE4: DMA1 Channel4 transfer error flag.
    384          *                       - DMA1_FLAG_GL5: DMA1 Channel5 global flag.
    385          *                       - DMA1_FLAG_TC5: DMA1 Channel5 transfer complete flag.
    386          *                       - DMA1_FLAG_HT5: DMA1 Channel5 half transfer flag.
    387          *                       - DMA1_FLAG_TE5: DMA1 Channel5 transfer error flag.
    388          *                       - DMA1_FLAG_GL6: DMA1 Channel6 global flag.
    389          *                       - DMA1_FLAG_TC6: DMA1 Channel6 transfer complete flag.
    390          *                       - DMA1_FLAG_HT6: DMA1 Channel6 half transfer flag.
    391          *                       - DMA1_FLAG_TE6: DMA1 Channel6 transfer error flag.
    392          *                       - DMA1_FLAG_GL7: DMA1 Channel7 global flag.
    393          *                       - DMA1_FLAG_TC7: DMA1 Channel7 transfer complete flag.
    394          *                       - DMA1_FLAG_HT7: DMA1 Channel7 half transfer flag.
    395          *                       - DMA1_FLAG_TE7: DMA1 Channel7 transfer error flag.
    396          *                       - DMA2_FLAG_GL1: DMA2 Channel1 global flag.
    397          *                       - DMA2_FLAG_TC1: DMA2 Channel1 transfer complete flag.
    398          *                       - DMA2_FLAG_HT1: DMA2 Channel1 half transfer flag.
    399          *                       - DMA2_FLAG_TE1: DMA2 Channel1 transfer error flag.
    400          *                       - DMA2_FLAG_GL2: DMA2 Channel2 global flag.
    401          *                       - DMA2_FLAG_TC2: DMA2 Channel2 transfer complete flag.
    402          *                       - DMA2_FLAG_HT2: DMA2 Channel2 half transfer flag.
    403          *                       - DMA2_FLAG_TE2: DMA2 Channel2 transfer error flag.
    404          *                       - DMA2_FLAG_GL3: DMA2 Channel3 global flag.
    405          *                       - DMA2_FLAG_TC3: DMA2 Channel3 transfer complete flag.
    406          *                       - DMA2_FLAG_HT3: DMA2 Channel3 half transfer flag.
    407          *                       - DMA2_FLAG_TE3: DMA2 Channel3 transfer error flag.
    408          *                       - DMA2_FLAG_GL4: DMA2 Channel4 global flag.
    409          *                       - DMA2_FLAG_TC4: DMA2 Channel4 transfer complete flag.
    410          *                       - DMA2_FLAG_HT4: DMA2 Channel4 half transfer flag.
    411          *                       - DMA2_FLAG_TE4: DMA2 Channel4 transfer error flag.
    412          *                       - DMA2_FLAG_GL5: DMA2 Channel5 global flag.
    413          *                       - DMA2_FLAG_TC5: DMA2 Channel5 transfer complete flag.
    414          *                       - DMA2_FLAG_HT5: DMA2 Channel5 half transfer flag.
    415          *                       - DMA2_FLAG_TE5: DMA2 Channel5 transfer error flag.
    416          * Output         : None
    417          * Return         : The new state of DMA_FLAG (SET or RESET).
    418          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    419          FlagStatus DMA_GetFlagStatus(u32 DMA_FLAG)
    420          {
    421            FlagStatus bitstatus = RESET;
   \                     DMA_GetFlagStatus: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    422            u32 tmpreg = 0;
    423          
    424            /* Check the parameters */
    425            assert_param(IS_DMA_GET_FLAG(DMA_FLAG));
    426          
    427            /* Calculate the used DMA */
    428            if ((DMA_FLAG & FLAG_Mask) != (u32)RESET)
   \   00000002   0x00C2             LSLS     R2,R0,#+3
   \   00000004   0xD502             BPL.N    ??DMA_GetFlagStatus_0
    429            {
    430              /* Get DMA2 ISR register value */
    431              tmpreg = DMA2->ISR ;
   \   00000006   0x....             LDR.N    R2,??DataTable4_3  ;; 0x40020400
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0xE001             B.N      ??DMA_GetFlagStatus_1
    432            }
    433            else
    434            {
    435              /* Get DMA1 ISR register value */
    436              tmpreg = DMA1->ISR ;
   \                     ??DMA_GetFlagStatus_0: (+1)
   \   0000000C   0x....             LDR.N    R2,??DataTable4_4  ;; 0x40020000
   \   0000000E   0x6812             LDR      R2,[R2, #+0]
    437            }
    438          
    439            /* Check the status of the specified DMA flag */
    440            if ((tmpreg & DMA_FLAG) != (u32)RESET)
   \                     ??DMA_GetFlagStatus_1: (+1)
   \   00000010   0x4202             TST      R2,R0
   \   00000012   0xD000             BEQ.N    ??DMA_GetFlagStatus_2
    441            {
    442              /* DMA_FLAG is set */
    443              bitstatus = SET;
   \   00000014   0x2101             MOVS     R1,#+1
    444            }
    445            else
    446            {
    447              /* DMA_FLAG is reset */
    448              bitstatus = RESET;
    449            }
    450            
    451            /* Return the DMA_FLAG status */
    452            return  bitstatus;
   \                     ??DMA_GetFlagStatus_2: (+1)
   \   00000016   0x4608             MOV      R0,R1
   \   00000018   0x4770             BX       LR               ;; return
    453          }
    454          
    455          /*******************************************************************************
    456          * Function Name  : DMA_ClearFlag
    457          * Description    : Clears the DMAy Channelx's pending flags.
    458          * Input          : - DMA_FLAG: specifies the flag to clear.
    459          *                    This parameter can be any combination (for the same DMA) of 
    460          *                    the following values:
    461          *                       - DMA1_FLAG_GL1: DMA1 Channel1 global flag.
    462          *                       - DMA1_FLAG_TC1: DMA1 Channel1 transfer complete flag.
    463          *                       - DMA1_FLAG_HT1: DMA1 Channel1 half transfer flag.
    464          *                       - DMA1_FLAG_TE1: DMA1 Channel1 transfer error flag.
    465          *                       - DMA1_FLAG_GL2: DMA1 Channel2 global flag.
    466          *                       - DMA1_FLAG_TC2: DMA1 Channel2 transfer complete flag.
    467          *                       - DMA1_FLAG_HT2: DMA1 Channel2 half transfer flag.
    468          *                       - DMA1_FLAG_TE2: DMA1 Channel2 transfer error flag.
    469          *                       - DMA1_FLAG_GL3: DMA1 Channel3 global flag.
    470          *                       - DMA1_FLAG_TC3: DMA1 Channel3 transfer complete flag.
    471          *                       - DMA1_FLAG_HT3: DMA1 Channel3 half transfer flag.
    472          *                       - DMA1_FLAG_TE3: DMA1 Channel3 transfer error flag.
    473          *                       - DMA1_FLAG_GL4: DMA1 Channel4 global flag.
    474          *                       - DMA1_FLAG_TC4: DMA1 Channel4 transfer complete flag.
    475          *                       - DMA1_FLAG_HT4: DMA1 Channel4 half transfer flag.
    476          *                       - DMA1_FLAG_TE4: DMA1 Channel4 transfer error flag.
    477          *                       - DMA1_FLAG_GL5: DMA1 Channel5 global flag.
    478          *                       - DMA1_FLAG_TC5: DMA1 Channel5 transfer complete flag.
    479          *                       - DMA1_FLAG_HT5: DMA1 Channel5 half transfer flag.
    480          *                       - DMA1_FLAG_TE5: DMA1 Channel5 transfer error flag.
    481          *                       - DMA1_FLAG_GL6: DMA1 Channel6 global flag.
    482          *                       - DMA1_FLAG_TC6: DMA1 Channel6 transfer complete flag.
    483          *                       - DMA1_FLAG_HT6: DMA1 Channel6 half transfer flag.
    484          *                       - DMA1_FLAG_TE6: DMA1 Channel6 transfer error flag.
    485          *                       - DMA1_FLAG_GL7: DMA1 Channel7 global flag.
    486          *                       - DMA1_FLAG_TC7: DMA1 Channel7 transfer complete flag.
    487          *                       - DMA1_FLAG_HT7: DMA1 Channel7 half transfer flag.
    488          *                       - DMA1_FLAG_TE7: DMA1 Channel7 transfer error flag.
    489          *                       - DMA2_FLAG_GL1: DMA2 Channel1 global flag.
    490          *                       - DMA2_FLAG_TC1: DMA2 Channel1 transfer complete flag.
    491          *                       - DMA2_FLAG_HT1: DMA2 Channel1 half transfer flag.
    492          *                       - DMA2_FLAG_TE1: DMA2 Channel1 transfer error flag.
    493          *                       - DMA2_FLAG_GL2: DMA2 Channel2 global flag.
    494          *                       - DMA2_FLAG_TC2: DMA2 Channel2 transfer complete flag.
    495          *                       - DMA2_FLAG_HT2: DMA2 Channel2 half transfer flag.
    496          *                       - DMA2_FLAG_TE2: DMA2 Channel2 transfer error flag.
    497          *                       - DMA2_FLAG_GL3: DMA2 Channel3 global flag.
    498          *                       - DMA2_FLAG_TC3: DMA2 Channel3 transfer complete flag.
    499          *                       - DMA2_FLAG_HT3: DMA2 Channel3 half transfer flag.
    500          *                       - DMA2_FLAG_TE3: DMA2 Channel3 transfer error flag.
    501          *                       - DMA2_FLAG_GL4: DMA2 Channel4 global flag.
    502          *                       - DMA2_FLAG_TC4: DMA2 Channel4 transfer complete flag.
    503          *                       - DMA2_FLAG_HT4: DMA2 Channel4 half transfer flag.
    504          *                       - DMA2_FLAG_TE4: DMA2 Channel4 transfer error flag.
    505          *                       - DMA2_FLAG_GL5: DMA2 Channel5 global flag.
    506          *                       - DMA2_FLAG_TC5: DMA2 Channel5 transfer complete flag.
    507          *                       - DMA2_FLAG_HT5: DMA2 Channel5 half transfer flag.
    508          *                       - DMA2_FLAG_TE5: DMA2 Channel5 transfer error flag.
    509          * Output         : None
    510          * Return         : None
    511          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    512          void DMA_ClearFlag(u32 DMA_FLAG)
    513          {
    514            /* Check the parameters */
    515            assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));
    516          
    517            /* Calculate the used DMA */
    518            if ((DMA_FLAG & FLAG_Mask) != (u32)RESET)
   \                     DMA_ClearFlag: (+1)
   \   00000000   0x00C1             LSLS     R1,R0,#+3
   \   00000002   0xD502             BPL.N    ??DMA_ClearFlag_0
    519            {
    520              /* Clear the selected DMA flags */
    521              DMA2->IFCR = DMA_FLAG;
   \   00000004   0x....             LDR.N    R1,??DataTable4_2  ;; 0x40020404
   \   00000006   0x6008             STR      R0,[R1, #+0]
   \   00000008   0x4770             BX       LR
    522            }
    523            else
    524            {
    525              /* Clear the selected DMA flags */
    526              DMA1->IFCR = DMA_FLAG;
   \                     ??DMA_ClearFlag_0: (+1)
   \   0000000A   0x....             LDR.N    R1,??DataTable4_1  ;; 0x40020004
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    527            }
    528          }
   \   0000000E   0x4770             BX       LR               ;; return
    529          
    530          /*******************************************************************************
    531          * Function Name  : DMA_GetITStatus
    532          * Description    : Checks whether the specified DMAy Channelx interrupt has 
    533          *                  occurred or not.
    534          * Input          : - DMA_IT: specifies the DMA interrupt source to check. 
    535          *                    This parameter can be one of the following values:
    536          *                       - DMA1_IT_GL1: DMA1 Channel1 global interrupt.
    537          *                       - DMA1_IT_TC1: DMA1 Channel1 transfer complete interrupt.
    538          *                       - DMA1_IT_HT1: DMA1 Channel1 half transfer interrupt.
    539          *                       - DMA1_IT_TE1: DMA1 Channel1 transfer error interrupt.
    540          *                       - DMA1_IT_GL2: DMA1 Channel2 global interrupt.
    541          *                       - DMA1_IT_TC2: DMA1 Channel2 transfer complete interrupt.
    542          *                       - DMA1_IT_HT2: DMA1 Channel2 half transfer interrupt.
    543          *                       - DMA1_IT_TE2: DMA1 Channel2 transfer error interrupt.
    544          *                       - DMA1_IT_GL3: DMA1 Channel3 global interrupt.
    545          *                       - DMA1_IT_TC3: DMA1 Channel3 transfer complete interrupt.
    546          *                       - DMA1_IT_HT3: DMA1 Channel3 half transfer interrupt.
    547          *                       - DMA1_IT_TE3: DMA1 Channel3 transfer error interrupt.
    548          *                       - DMA1_IT_GL4: DMA1 Channel4 global interrupt.
    549          *                       - DMA1_IT_TC4: DMA1 Channel4 transfer complete interrupt.
    550          *                       - DMA1_IT_HT4: DMA1 Channel4 half transfer interrupt.
    551          *                       - DMA1_IT_TE4: DMA1 Channel4 transfer error interrupt.
    552          *                       - DMA1_IT_GL5: DMA1 Channel5 global interrupt.
    553          *                       - DMA1_IT_TC5: DMA1 Channel5 transfer complete interrupt.
    554          *                       - DMA1_IT_HT5: DMA1 Channel5 half transfer interrupt.
    555          *                       - DMA1_IT_TE5: DMA1 Channel5 transfer error interrupt.
    556          *                       - DMA1_IT_GL6: DMA1 Channel6 global interrupt.
    557          *                       - DMA1_IT_TC6: DMA1 Channel6 transfer complete interrupt.
    558          *                       - DMA1_IT_HT6: DMA1 Channel6 half transfer interrupt.
    559          *                       - DMA1_IT_TE6: DMA1 Channel6 transfer error interrupt.
    560          *                       - DMA1_IT_GL7: DMA1 Channel7 global interrupt.
    561          *                       - DMA1_IT_TC7: DMA1 Channel7 transfer complete interrupt.
    562          *                       - DMA1_IT_HT7: DMA1 Channel7 half transfer interrupt.
    563          *                       - DMA1_IT_TE7: DMA1 Channel7 transfer error interrupt.
    564          *                       - DMA2_IT_GL1: DMA2 Channel1 global interrupt.
    565          *                       - DMA2_IT_TC1: DMA2 Channel1 transfer complete interrupt.
    566          *                       - DMA2_IT_HT1: DMA2 Channel1 half transfer interrupt.
    567          *                       - DMA2_IT_TE1: DMA2 Channel1 transfer error interrupt.
    568          *                       - DMA2_IT_GL2: DMA2 Channel2 global interrupt.
    569          *                       - DMA2_IT_TC2: DMA2 Channel2 transfer complete interrupt.
    570          *                       - DMA2_IT_HT2: DMA2 Channel2 half transfer interrupt.
    571          *                       - DMA2_IT_TE2: DMA2 Channel2 transfer error interrupt.
    572          *                       - DMA2_IT_GL3: DMA2 Channel3 global interrupt.
    573          *                       - DMA2_IT_TC3: DMA2 Channel3 transfer complete interrupt.
    574          *                       - DMA2_IT_HT3: DMA2 Channel3 half transfer interrupt.
    575          *                       - DMA2_IT_TE3: DMA2 Channel3 transfer error interrupt.
    576          *                       - DMA2_IT_GL4: DMA2 Channel4 global interrupt.
    577          *                       - DMA2_IT_TC4: DMA2 Channel4 transfer complete interrupt.
    578          *                       - DMA2_IT_HT4: DMA2 Channel4 half transfer interrupt.
    579          *                       - DMA2_IT_TE4: DMA2 Channel4 transfer error interrupt.
    580          *                       - DMA2_IT_GL5: DMA2 Channel5 global interrupt.
    581          *                       - DMA2_IT_TC5: DMA2 Channel5 transfer complete interrupt.
    582          *                       - DMA2_IT_HT5: DMA2 Channel5 half transfer interrupt.
    583          *                       - DMA2_IT_TE5: DMA2 Channel5 transfer error interrupt.
    584          * Output         : None
    585          * Return         : The new state of DMA_IT (SET or RESET).
    586          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    587          ITStatus DMA_GetITStatus(u32 DMA_IT)
    588          {
    589            ITStatus bitstatus = RESET;
   \                     DMA_GetITStatus: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    590            u32 tmpreg = 0;
    591          
    592            /* Check the parameters */
    593            assert_param(IS_DMA_GET_IT(DMA_IT));
    594          
    595            /* Calculate the used DMA */
    596            if ((DMA_IT & FLAG_Mask) != (u32)RESET)
   \   00000002   0x00C2             LSLS     R2,R0,#+3
   \   00000004   0xD502             BPL.N    ??DMA_GetITStatus_0
    597            {
    598              /* Get DMA2 ISR register value */
    599              tmpreg = DMA2->ISR ;
   \   00000006   0x....             LDR.N    R2,??DataTable4_3  ;; 0x40020400
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0xE001             B.N      ??DMA_GetITStatus_1
    600            }
    601            else
    602            {
    603              /* Get DMA1 ISR register value */
    604              tmpreg = DMA1->ISR ;
   \                     ??DMA_GetITStatus_0: (+1)
   \   0000000C   0x....             LDR.N    R2,??DataTable4_4  ;; 0x40020000
   \   0000000E   0x6812             LDR      R2,[R2, #+0]
    605            }
    606          
    607            /* Check the status of the specified DMA interrupt */
    608            if ((tmpreg & DMA_IT) != (u32)RESET)
   \                     ??DMA_GetITStatus_1: (+1)
   \   00000010   0x4202             TST      R2,R0
   \   00000012   0xD000             BEQ.N    ??DMA_GetITStatus_2
    609            {
    610              /* DMA_IT is set */
    611              bitstatus = SET;
   \   00000014   0x2101             MOVS     R1,#+1
    612            }
    613            else
    614            {
    615              /* DMA_IT is reset */
    616              bitstatus = RESET;
    617            }
    618            /* Return the DMA_IT status */
    619            return  bitstatus;
   \                     ??DMA_GetITStatus_2: (+1)
   \   00000016   0x4608             MOV      R0,R1
   \   00000018   0x4770             BX       LR               ;; return
    620          }
    621          
    622          /*******************************************************************************
    623          * Function Name  : DMA_ClearITPendingBit
    624          * Description    : Clears the DMAy Channelxs interrupt pending bits.
    625          * Input          : - DMA_IT: specifies the DMA interrupt pending bit to clear.
    626          *                    This parameter can be any combination (for the same DMA) of
    627          *                    the following values:
    628          *                       - DMA1_IT_GL1: DMA1 Channel1 global interrupt.
    629          *                       - DMA1_IT_TC1: DMA1 Channel1 transfer complete interrupt.
    630          *                       - DMA1_IT_HT1: DMA1 Channel1 half transfer interrupt.
    631          *                       - DMA1_IT_TE1: DMA1 Channel1 transfer error interrupt.
    632          *                       - DMA1_IT_GL2: DMA1 Channel2 global interrupt.
    633          *                       - DMA1_IT_TC2: DMA1 Channel2 transfer complete interrupt.
    634          *                       - DMA1_IT_HT2: DMA1 Channel2 half transfer interrupt.
    635          *                       - DMA1_IT_TE2: DMA1 Channel2 transfer error interrupt.
    636          *                       - DMA1_IT_GL3: DMA1 Channel3 global interrupt.
    637          *                       - DMA1_IT_TC3: DMA1 Channel3 transfer complete interrupt.
    638          *                       - DMA1_IT_HT3: DMA1 Channel3 half transfer interrupt.
    639          *                       - DMA1_IT_TE3: DMA1 Channel3 transfer error interrupt.
    640          *                       - DMA1_IT_GL4: DMA1 Channel4 global interrupt.
    641          *                       - DMA1_IT_TC4: DMA1 Channel4 transfer complete interrupt.
    642          *                       - DMA1_IT_HT4: DMA1 Channel4 half transfer interrupt.
    643          *                       - DMA1_IT_TE4: DMA1 Channel4 transfer error interrupt.
    644          *                       - DMA1_IT_GL5: DMA1 Channel5 global interrupt.
    645          *                       - DMA1_IT_TC5: DMA1 Channel5 transfer complete interrupt.
    646          *                       - DMA1_IT_HT5: DMA1 Channel5 half transfer interrupt.
    647          *                       - DMA1_IT_TE5: DMA1 Channel5 transfer error interrupt.
    648          *                       - DMA1_IT_GL6: DMA1 Channel6 global interrupt.
    649          *                       - DMA1_IT_TC6: DMA1 Channel6 transfer complete interrupt.
    650          *                       - DMA1_IT_HT6: DMA1 Channel6 half transfer interrupt.
    651          *                       - DMA1_IT_TE6: DMA1 Channel6 transfer error interrupt.
    652          *                       - DMA1_IT_GL7: DMA1 Channel7 global interrupt.
    653          *                       - DMA1_IT_TC7: DMA1 Channel7 transfer complete interrupt.
    654          *                       - DMA1_IT_HT7: DMA1 Channel7 half transfer interrupt.
    655          *                       - DMA1_IT_TE7: DMA1 Channel7 transfer error interrupt.
    656          *                       - DMA2_IT_GL1: DMA2 Channel1 global interrupt.
    657          *                       - DMA2_IT_TC1: DMA2 Channel1 transfer complete interrupt.
    658          *                       - DMA2_IT_HT1: DMA2 Channel1 half transfer interrupt.
    659          *                       - DMA2_IT_TE1: DMA2 Channel1 transfer error interrupt.
    660          *                       - DMA2_IT_GL2: DMA2 Channel2 global interrupt.
    661          *                       - DMA2_IT_TC2: DMA2 Channel2 transfer complete interrupt.
    662          *                       - DMA2_IT_HT2: DMA2 Channel2 half transfer interrupt.
    663          *                       - DMA2_IT_TE2: DMA2 Channel2 transfer error interrupt.
    664          *                       - DMA2_IT_GL3: DMA2 Channel3 global interrupt.
    665          *                       - DMA2_IT_TC3: DMA2 Channel3 transfer complete interrupt.
    666          *                       - DMA2_IT_HT3: DMA2 Channel3 half transfer interrupt.
    667          *                       - DMA2_IT_TE3: DMA2 Channel3 transfer error interrupt.
    668          *                       - DMA2_IT_GL4: DMA2 Channel4 global interrupt.
    669          *                       - DMA2_IT_TC4: DMA2 Channel4 transfer complete interrupt.
    670          *                       - DMA2_IT_HT4: DMA2 Channel4 half transfer interrupt.
    671          *                       - DMA2_IT_TE4: DMA2 Channel4 transfer error interrupt.
    672          *                       - DMA2_IT_GL5: DMA2 Channel5 global interrupt.
    673          *                       - DMA2_IT_TC5: DMA2 Channel5 transfer complete interrupt.
    674          *                       - DMA2_IT_HT5: DMA2 Channel5 half transfer interrupt.
    675          *                       - DMA2_IT_TE5: DMA2 Channel5 transfer error interrupt.
    676          * Output         : None
    677          * Return         : None
    678          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    679          void DMA_ClearITPendingBit(u32 DMA_IT)
    680          {
    681            /* Check the parameters */
    682            assert_param(IS_DMA_CLEAR_IT(DMA_IT));
    683          
    684            /* Calculate the used DMA */
    685            if ((DMA_IT & FLAG_Mask) != (u32)RESET)
   \                     DMA_ClearITPendingBit: (+1)
   \   00000000   0x00C1             LSLS     R1,R0,#+3
   \   00000002   0xD502             BPL.N    ??DMA_ClearITPendingBit_0
    686            {
    687              /* Clear the selected DMA interrupt pending bits */
    688              DMA2->IFCR = DMA_IT;
   \   00000004   0x....             LDR.N    R1,??DataTable4_2  ;; 0x40020404
   \   00000006   0x6008             STR      R0,[R1, #+0]
   \   00000008   0x4770             BX       LR
    689            }
    690            else
    691            {
    692              /* Clear the selected DMA interrupt pending bits */
    693              DMA1->IFCR = DMA_IT;
   \                     ??DMA_ClearITPendingBit_0: (+1)
   \   0000000A   0x....             LDR.N    R1,??DataTable4_1  ;; 0x40020004
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    694            }
    695          }
   \   0000000E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x40020008         DC32     0x40020008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x40020004         DC32     0x40020004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x40020404         DC32     0x40020404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x40020000         DC32     0x40020000
    696          
    697          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
    698          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DMA_ClearFlag
       0   DMA_ClearITPendingBit
       0   DMA_Cmd
       0   DMA_DeInit
       0   DMA_GetCurrDataCounter
       0   DMA_GetFlagStatus
       0   DMA_GetITStatus
       0   DMA_ITConfig
       0   DMA_Init
       0   DMA_SetCurrDataCounter
       0   DMA_StructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
      16  DMA_ClearFlag
      16  DMA_ClearITPendingBit
      22  DMA_Cmd
     218  DMA_DeInit
       6  DMA_GetCurrDataCounter
      26  DMA_GetFlagStatus
      26  DMA_GetITStatus
      20  DMA_ITConfig
      54  DMA_Init
       4  DMA_SetCurrDataCounter
      26  DMA_StructInit

 
 454 bytes in section .text
 
 454 bytes of CODE memory

Errors: none
Warnings: none
