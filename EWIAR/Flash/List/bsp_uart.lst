###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        12/Jul/2019  09:14:40
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\USER\BSP\bsp_uart.c
#    Command line =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\USER\BSP\bsp_uart.c -D
#        LORA_MODULE -lCN
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\List\ -o
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\Softwares\IAR7.40\arm\INC\c\DLib_Config_Full.h -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\CPU\inc\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-CPU\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-CPU\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-LIB\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-OSII\Ports\
#        -I
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\UCOS-II\uC-OSII\Source\
#        -I E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\USER\BSP\
#        -I E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\..\USER\APP\
#        -Om --use_c++_inline
#    List file    =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\List\bsp_uart.lst
#    Object file  =  
#        E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\EWIAR\Flash\Obj\bsp_uart.o
#
###############################################################################

E:\MYWorkPlace\SVNData\zhouwanli\XF-SXT-N-V1.0\USER\BSP\bsp_uart.c
      1          /** @copyright XunFang Communication Tech Limited. All rights reserved. 2019.
      2            * @file  bsp_uart.c
      3            * @author  walle
      4            * @version  V1.0.0
      5            * @date  28/05/2019
      6            * @brief  uart驱动文件
      7            */ 
      8          
      9          /* 头文件---------------------------------------------------------------------------*/
     10          #include "stdio.h"
     11          #include "string.h"
     12          #include "bsp_uart.h"
     13          #include "app_uart.h"
     14          #include "stm32f10x_usart.h"
     15          #include <bsp.h>
     16          #include "ringbuf.h"
     17          
     18          /** 
     19            * @brief串口收发结构体    
     20            */
     21          static ST_USART_DATA  g_stUsart1Data = {0};
     22          static ST_USART_DATA g_stUsart2Data = {0};
     23          ST_PACK_DATA   g_stRecvData = {0};

   \                                 In section .data, align 1
     24          static EN_USART_MODE USART_MODE = EN_USART_UNDEF;				/* 串口工作模式 */
   \                     USART_MODE:
   \   00000000   0x03               DC8 3
     25          
     26          
     27            
     28          
     29          
     30          
     31          
     32          /** 
     33            * @brief BC35串口信息结构体    
     34            */
     35          static ST_UART_INFO st_bc35_uart_info = 
     36          {
     37          	USART2, 				//串口号
     38          	GPIOA, 				    //串口GPIO
     39          	GPIO_Pin_2, 		    //发送引脚
     40          	GPIO_Pin_3, 		    //接收引脚
     41          	9600,					//波特率
     42          	BSP_INT_ID_USART2,
     43          	USART2_IRQChannel,	    //中断通道
     44          	BSP_IntHandlerUSART2,
     45          };
     46          
     47          /** 
     48            * @brief LORA串口信息结构体    
     49            */

   \                                 In section .data, align 4
     50          static ST_UART_INFO st_lora_uart_info = 
   \                     st_lora_uart_info:
   \   00000000   0x40004400         DC32 40004400H, 40010800H, 4, 8, 115200
   \              0x40010800   
   \              0x00000004   
   \              0x00000008   
   \              0x0001C200   
   \   00000014   0x26 0x26          DC8 38, 38, 0, 0
   \              0x00 0x00    
   \   00000018   0x........         DC32 BSP_IntHandlerUSART2
   \   0000001C   0x40004800         DC32 40004800H, 40011000H, 1024, 2048, 115200
   \              0x40011000   
   \              0x00000400   
   \              0x00000800   
   \              0x0001C200   
   \   00000030   0x27 0x27          DC8 39, 39, 0, 0
   \              0x00 0x00    
   \   00000034   0x........         DC32 BSP_IntHandlerUSART3
   \   00000038   0x40013800         DC32 40013800H, 40010800H, 512, 1024, 115200
   \              0x40010800   
   \              0x00000200   
   \              0x00000400   
   \              0x0001C200   
   \   0000004C   0x25 0x25          DC8 37, 37, 0, 0
   \              0x00 0x00    
   \   00000050   0x........         DC32 BSP_IntHandlerUSART1
     51          {
     52          	USART2, 				//串口号
     53          	GPIOA, 				    //串口GPIO
     54          	GPIO_Pin_2, 		    //发送引脚
     55          	GPIO_Pin_3, 		    //接收引脚
     56          	115200,					//波特率
     57          	BSP_INT_ID_USART2,
     58          	USART2_IRQChannel,	    //中断通道
     59          	BSP_IntHandlerUSART2,
     60          };
     61          
     62          /** 
     63            * @brief USART3信息结构体    
     64            */
     65          static ST_UART_INFO st_uart3_info = 
     66          {
     67          	USART3, 				//串口号
     68          	GPIOC, 				    //串口GPIO
     69          	GPIO_Pin_10, 		    //发送引脚
     70          	GPIO_Pin_11, 		    //接收引脚
     71          	115200,					//波特率
     72          	BSP_INT_ID_USART3,
     73          	USART3_IRQChannel,	    //中断通道
     74          	BSP_IntHandlerUSART3,
     75          };
     76          
     77          /** 
     78            * @brief USART1信息结构体    
     79            */
     80          static ST_UART_INFO st_uart1_info = 
     81          {
     82          	USART1, 				//串口号
     83          	GPIOA, 				    //串口GPIO
     84          	GPIO_Pin_9, 		    //发送引脚
     85          	GPIO_Pin_10, 		    //接收引脚
     86          	115200,					//波特率
     87          	BSP_INT_ID_USART1,
     88          	USART1_IRQChannel,	    //中断通道
     89          	BSP_IntHandlerUSART1,
     90          };
     91          
     92          /**
     93            * @}
     94            */
     95          
     96          
     97          /** 
     98            * 函数功能：
     99            * 参数说明：
    100            * 返回说明：
    101            * 调用范围：
    102            * 完成时间：
    103            * 修改时间：
    104            * 修改原因：
    105            */

   \                                 In section .text, align 2, keep-with-next
    106          void SetUSART_MODE(EN_USART_MODE en_MODE)
    107          {
    108          	USART_MODE = en_MODE;	/* 模式赋值 */
   \                     SetUSART_MODE: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable18_1
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    109          }
   \   00000006   0x4770             BX       LR               ;; return
    110          
    111          /** 
    112            * 函数功能：
    113            * 参数说明：
    114            * 返回说明：
    115            * 调用范围：
    116            * 完成时间：
    117            * 修改时间：
    118            * 修改原因：
    119            */

   \                                 In section .text, align 2, keep-with-next
    120          EN_USART_MODE GETUSART_MODE(void)
    121          {
    122          	return USART_MODE;	/* 模式值返回 */
   \                     GETUSART_MODE: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
    123          }
    124          
    125          
    126          
    127          /** 
    128            * 函数功能：
    129            * 参数说明：
    130            * 返回说明：
    131            * 调用范围：
    132            * 完成时间：
    133            * 修改时间：
    134            * 修改原因：
    135            */

   \                                 In section .text, align 2, keep-with-next
    136          static void Stm32UsartGPIOConfigInit (PST_UART_INFO pst_uart_info)
    137          {
   \                     Stm32UsartGPIOConfigInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    138              GPIO_InitTypeDef 	GPIO_InitStructure;						/* GPIO参数 */
    139          	if(pst_uart_info->USARTx == USART3)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable18_2  ;; 0x40004800
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD104             BNE.N    ??Stm32UsartGPIOConfigInit_0
    140          	{
    141          		GPIO_PinRemapConfig(GPIO_PartialRemap_USART3, ENABLE);
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x140010
   \   00000014   0x.... 0x....      BL       GPIO_PinRemapConfig
    142          	}
    143          	GPIO_InitStructure.GPIO_Pin = pst_uart_info->GPIO_Pin_tx;	//端口tx					
   \                     ??Stm32UsartGPIOConfigInit_0: (+1)
   \   00000018   0x68A0             LDR      R0,[R4, #+8]
   \   0000001A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    144          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;			    //复用推挽输出模式
   \   0000001E   0x2018             MOVS     R0,#+24
   \   00000020   0xF88D 0x0003      STRB     R0,[SP, #+3]
    145          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;			//速率2MHz
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0xF88D 0x0002      STRB     R0,[SP, #+2]
    146          	GPIO_Init(pst_uart_info->GPIOx, &GPIO_InitStructure);
   \   0000002A   0xA900             ADD      R1,SP,#+0
   \   0000002C   0x6860             LDR      R0,[R4, #+4]
   \   0000002E   0x.... 0x....      BL       GPIO_Init
    147          	
    148          	GPIO_InitStructure.GPIO_Pin = pst_uart_info->GPIO_Pin_rx;	//端口rx
   \   00000032   0x68E0             LDR      R0,[R4, #+12]
   \   00000034   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    149          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;		//浮空输入模式
   \   00000038   0x2004             MOVS     R0,#+4
   \   0000003A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    150          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;			//速率2MHz
   \   0000003E   0x2003             MOVS     R0,#+3
   \   00000040   0xF88D 0x0002      STRB     R0,[SP, #+2]
    151          	GPIO_Init(pst_uart_info->GPIOx, &GPIO_InitStructure);
   \   00000044   0xA900             ADD      R1,SP,#+0
   \   00000046   0x6860             LDR      R0,[R4, #+4]
   \   00000048   0x.... 0x....      BL       GPIO_Init
    152          
    153          	/* 初始化USART1所在的RS485和RS232控制端口 */
    154          	if(pst_uart_info->USARTx == USART1)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable18_4  ;; 0x40013800
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD13B             BNE.N    ??Stm32UsartGPIOConfigInit_1
    155          	{
    156          		GPIO_InitStructure.GPIO_Pin = CTRL_485PINx;
   \   00000056   0x2040             MOVS     R0,#+64
   \   00000058   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    157          		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;		//输出模式
   \   0000005C   0x2010             MOVS     R0,#+16
   \   0000005E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    158          		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		//速率50MHz
   \   00000062   0x2003             MOVS     R0,#+3
   \   00000064   0xF88D 0x0002      STRB     R0,[SP, #+2]
    159          		GPIO_Init(CTRL_485GPIOx, &GPIO_InitStructure);
   \   00000068   0x.... 0x....      LDR.W    R4,??DataTable18_5  ;; 0x40010c00
   \   0000006C   0xA900             ADD      R1,SP,#+0
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x.... 0x....      BL       GPIO_Init
    160          
    161          		GPIO_InitStructure.GPIO_Pin = CTRL_232PINx;
   \   00000074   0x2020             MOVS     R0,#+32
   \   00000076   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    162          		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;		//输出模式
   \   0000007A   0x2010             MOVS     R0,#+16
   \   0000007C   0xF88D 0x0003      STRB     R0,[SP, #+3]
    163          		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		//速率50MHz
   \   00000080   0x2003             MOVS     R0,#+3
   \   00000082   0xF88D 0x0002      STRB     R0,[SP, #+2]
    164          		GPIO_Init(CTRL_232GPIOx, &GPIO_InitStructure);	
   \   00000086   0xA900             ADD      R1,SP,#+0
   \   00000088   0x4620             MOV      R0,R4
   \   0000008A   0x.... 0x....      BL       GPIO_Init
    165          		
    166          		GPIO_InitStructure.GPIO_Pin = EN_RS485PINx;
   \   0000008E   0xF44F 0x7080      MOV      R0,#+256
   \   00000092   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    167          		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;		//输出模式
   \   00000096   0x2010             MOVS     R0,#+16
   \   00000098   0xF88D 0x0003      STRB     R0,[SP, #+3]
    168          		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		//速率50MHz
   \   0000009C   0x2003             MOVS     R0,#+3
   \   0000009E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    169          		GPIO_Init(EN_RS485GPIOx, &GPIO_InitStructure);
   \   000000A2   0x.... 0x....      LDR.W    R5,??DataTable18_6  ;; 0x40010800
   \   000000A6   0xA900             ADD      R1,SP,#+0
   \   000000A8   0x4628             MOV      R0,R5
   \   000000AA   0x.... 0x....      BL       GPIO_Init
    170          		GPIO_SetBits(EN_RS485GPIOx, EN_RS485PINx);
   \   000000AE   0xF44F 0x7180      MOV      R1,#+256
   \   000000B2   0x4628             MOV      R0,R5
   \   000000B4   0x.... 0x....      BL       GPIO_SetBits
    171          		OPENRS_232;
   \   000000B8   0x2140             MOVS     R1,#+64
   \   000000BA   0x4620             MOV      R0,R4
   \   000000BC   0x.... 0x....      BL       GPIO_ResetBits
   \   000000C0   0x2120             MOVS     R1,#+32
   \   000000C2   0x4620             MOV      R0,R4
   \   000000C4   0x.... 0x....      BL       GPIO_SetBits
   \   000000C8   0x2001             MOVS     R0,#+1
   \   000000CA   0x.... 0x....      BL       SetUSART_MODE
    172          		//GPIO_ResetBits(EN_RS485GPIOx, EN_RS485PINx);
    173          	}
    174          }
   \                     ??Stm32UsartGPIOConfigInit_1: (+1)
   \   000000CE   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    175          
    176          /** 
    177            * 函数功能：
    178            * 参数说明：
    179            * 返回说明：
    180            * 调用范围：
    181            * 完成时间：
    182            * 修改时间：
    183            * 修改原因：
    184            */

   \                                 In section .text, align 2, keep-with-next
    185          static void Stm32UsartParamConfigInit(PST_UART_INFO pst_uart_info)
    186          {
   \                     Stm32UsartParamConfigInit: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    187              USART_InitTypeDef	USART_InitStructure;			
    188              USART_InitStructure.USART_BaudRate = pst_uart_info->ulBaudRate;			
   \   00000004   0x6901             LDR      R1,[R0, #+16]
   \   00000006   0x9100             STR      R1,[SP, #+0]
    189          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;	
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xF8AD 0x100C      STRH     R1,[SP, #+12]
    190          	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	
   \   0000000E   0x210C             MOVS     R1,#+12
   \   00000010   0xF8AD 0x100A      STRH     R1,[SP, #+10]
    191          	USART_InitStructure.USART_Parity = USART_Parity_No;		
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0xF8AD 0x1008      STRH     R1,[SP, #+8]
    192          	USART_InitStructure.USART_StopBits = USART_StopBits_1;		
    193          	USART_InitStructure.USART_WordLength = USART_WordLength_8b;	
   \   0000001A   0x9101             STR      R1,[SP, #+4]
    194          	USART_Init(pst_uart_info->USARTx, &USART_InitStructure);
   \   0000001C   0xA900             ADD      R1,SP,#+0
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x.... 0x....      BL       USART_Init
    195          }
   \   00000024   0xB005             ADD      SP,SP,#+20
   \   00000026   0xBD00             POP      {PC}             ;; return
    196          
    197          
    198          /** 
    199            * 函数功能：
    200            * 参数说明：
    201            * 返回说明：
    202            * 调用范围：
    203            * 完成时间：
    204            * 修改时间：
    205            * 修改原因：
    206            */

   \                                 In section .text, align 2, keep-with-next
    207          static void Stm32UsartIntCfgInit(PST_UART_INFO pst_uart_info)
    208          {
   \                     Stm32UsartIntCfgInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    209            	static int Proiority = 0;
    210          	NVIC_InitTypeDef 	NVIC_InitStructure;									//中断类型参数
    211          	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
   \   00000006   0xF44F 0x60A0      MOV      R0,#+1280
   \   0000000A   0x.... 0x....      BL       NVIC_PriorityGroupConfig
    212          	NVIC_InitStructure.NVIC_IRQChannel = pst_uart_info->NVIC_IRQChannel;	//中断通道为USART1中断
   \   0000000E   0x7D60             LDRB     R0,[R4, #+21]
   \   00000010   0xF88D 0x0000      STRB     R0,[SP, #+0]
    213          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = Proiority++;		//抢占优先级
   \   00000014   0x....             LDR.N    R0,??DataTable18_7
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0x460A             MOV      R2,R1
   \   0000001A   0xF88D 0x2001      STRB     R2,[SP, #+1]
   \   0000001E   0x1C49             ADDS     R1,R1,#+1
   \   00000020   0x6001             STR      R1,[R0, #+0]
    214          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = Proiority++;			//响应优先级
   \   00000022   0x460A             MOV      R2,R1
   \   00000024   0xF88D 0x2002      STRB     R2,[SP, #+2]
   \   00000028   0x1C49             ADDS     R1,R1,#+1
   \   0000002A   0x6001             STR      R1,[R0, #+0]
    215          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;							//中断功能使能
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    216          	NVIC_Init(&NVIC_InitStructure);											//初始化中断配置	
   \   00000032   0xA800             ADD      R0,SP,#+0
   \   00000034   0x.... 0x....      BL       NVIC_Init
    217          	USART_ITConfig(pst_uart_info->USARTx, USART_IT_RXNE, ENABLE);
   \   00000038   0x2201             MOVS     R2,#+1
   \   0000003A   0xF240 0x5125      MOVW     R1,#+1317
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x.... 0x....      BL       USART_ITConfig
    218          #if 0
    219          	if(pst_uart_info->USARTx == USART1)
    220          	{
    221            		USART_ITConfig(pst_uart_info->USARTx, USART_IT_TC, ENABLE);				//发送完成中断	
    222          		USART_ITConfig(pst_uart_info->USARTx, USART_IT_IDLE, ENABLE);			//总线空闲中断
    223          	}
    224          #endif
    225          	BSP_IntVectSet(pst_uart_info->ucBSP_INT_ID, pst_uart_info->INT_Service_name); 				//设置串口的中断向量，必须要有的
   \   00000044   0x69A1             LDR      R1,[R4, #+24]
   \   00000046   0x7D20             LDRB     R0,[R4, #+20]
   \   00000048   0x.... 0x....      BL       BSP_IntVectSet
    226          	BSP_IntEn(pst_uart_info->ucBSP_INT_ID);
   \   0000004C   0x7D20             LDRB     R0,[R4, #+20]
   \   0000004E   0x.... 0x....      BL       BSP_IntEn
    227          	USART_Cmd(pst_uart_info->USARTx, ENABLE);
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x.... 0x....      BL       USART_Cmd
    228          	USART_ClearFlag(pst_uart_info->USARTx, USART_FLAG_TC); 
   \   0000005A   0x2140             MOVS     R1,#+64
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x.... 0x....      BL       USART_ClearFlag
    229          }
   \   00000062   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    230          
    231          /** 
    232            * 函数功能：
    233            * 参数说明：
    234            * 返回说明：
    235            * 调用范围：
    236            * 完成时间：
    237            * 修改时间：
    238            * 修改原因：
    239            */

   \                                 In section .text, align 2, keep-with-next
    240          static void Stm32UsartQueueInit(void)
    241          {
   \                     Stm32UsartQueueInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    242          	/* 串口1队列初始化 */
    243          	RingBufInit(&g_stUsart1Data.stUartBufRecv, g_stUsart1Data.aucBufRecv, sizeof (g_stUsart1Data.aucBufRecv));
   \   00000002   0x....             LDR.N    R4,??DataTable18_8
   \   00000004   0xF44F 0x7280      MOV      R2,#+256
   \   00000008   0xF104 0x010C      ADD      R1,R4,#+12
   \   0000000C   0xF504 0x7086      ADD      R0,R4,#+268
   \   00000010   0x.... 0x....      BL       RingBufInit
    244          
    245          	/* 串口2队列初始化 */
    246          	RingBufInit(&g_stUsart2Data.stUartBufRecv, g_stUsart2Data.aucBufRecv, sizeof (g_stUsart2Data.aucBufRecv));
   \   00000014   0xF44F 0x7280      MOV      R2,#+256
   \   00000018   0xF504 0x7190      ADD      R1,R4,#+288
   \   0000001C   0xF504 0x7008      ADD      R0,R4,#+544
   \   00000020   0xE8BD 0x4010      POP      {R4,LR}
   \   00000024   0x.... 0x....      B.W      RingBufInit
    247          
    248          }
    249          
    250          
    251          /** 
    252            * 函数功能：
    253            * 参数说明：
    254            * 返回说明：
    255            * 调用范围：
    256            * 完成时间：
    257            * 修改时间：
    258            * 修改原因：
    259            */

   \                                 In section .text, align 2, keep-with-next
    260          static void Stm32UsartConfigInit(PST_UART_INFO pst_uart_info)
    261          {
   \                     Stm32UsartConfigInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    262              Stm32UsartGPIOConfigInit(pst_uart_info);    	//串口所在的GPIO端口初始化函数
   \   00000004   0x.... 0x....      BL       Stm32UsartGPIOConfigInit
    263              Stm32UsartParamConfigInit(pst_uart_info);		//串口参数信息配置初始化函数
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       Stm32UsartParamConfigInit
    264              Stm32UsartIntCfgInit(pst_uart_info);         	//串口中断配置初始化函数
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0xE8BD 0x4010      POP      {R4,LR}
   \   00000014   0x....             B.N      Stm32UsartIntCfgInit
    265          }
    266          
    267          /** 
    268            * 函数功能：
    269            * 参数说明：
    270            * 返回说明：
    271            * 调用范围：
    272            * 完成时间：
    273            * 修改时间：
    274            * 修改原因：
    275            */

   \                                 In section .text, align 2, keep-with-next
    276          void BSP_UART_Init(void)
    277          {
   \                     BSP_UART_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    278          #if defined (NBIOT_MODULE)
    279            	Stm32UsartConfigInit(&st_bc35_uart_info);
    280          #else
    281            	Stm32UsartConfigInit(&st_lora_uart_info);
   \   00000002   0x....             LDR.N    R4,??DataTable18_9
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0x.... 0x....      BL       Stm32UsartConfigInit
    282          #endif
    283          	Stm32UsartConfigInit(&st_uart1_info);
   \   0000000A   0xF104 0x0038      ADD      R0,R4,#+56
   \   0000000E   0x.... 0x....      BL       Stm32UsartConfigInit
    284          	Stm32UsartConfigInit(&st_uart3_info);
   \   00000012   0xF104 0x001C      ADD      R0,R4,#+28
   \   00000016   0x.... 0x....      BL       Stm32UsartConfigInit
    285          	Stm32UsartQueueInit();
   \   0000001A   0x.... 0x....      BL       Stm32UsartQueueInit
    286          //	OPENRS_232;
    287          	InitDebugPrintf();			/* 初始化Debug打印 */
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x.... 0x....      B.W      InitDebugPrintf
    288          }
    289          
    290          /** 
    291            * 函数功能：
    292            * 参数说明：
    293            * 返回说明：
    294            * 调用范围：
    295            * 完成时间：
    296            * 修改时间：
    297            * 修改原因：
    298            */

   \                                 In section .text, align 2, keep-with-next
    299          static void UartDataReceiveStorage(USART_TypeDef* USARTx, PST_USART_DATA pstUsartData)
    300          {        
   \                     UartDataReceiveStorage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0xF505 0x7680      ADD      R6,R5,#+256
    301              for(;;)
    302          	{
    303          		if(RingBufFree(&pstUsartData->stUartBufRecv) > 0)
   \                     ??UartDataReceiveStorage_0: (+1)
   \   0000000A   0x4630             MOV      R0,R6
   \   0000000C   0x.... 0x....      BL       RingBufFree
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xD007             BEQ.N    ??UartDataReceiveStorage_1
    304          		{
    305                      RingBufWriteOne(&pstUsartData->stUartBufRecv, USART_ReceiveData(USARTx));
   \   00000016   0x.... 0x....      BL       USART_ReceiveData
   \   0000001A   0x4601             MOV      R1,R0
   \   0000001C   0xB2C9             UXTB     R1,R1
   \   0000001E   0x4630             MOV      R0,R6
   \   00000020   0x.... 0x....      BL       RingBufWriteOne
   \   00000024   0xE001             B.N      ??UartDataReceiveStorage_2
    306          		}
    307          		else
    308          		{	
    309          			unsigned char ucReceiveData = USART_ReceiveData(USARTx);	/* 接收数据、抛弃 */
   \                     ??UartDataReceiveStorage_1: (+1)
   \   00000026   0x.... 0x....      BL       USART_ReceiveData
    310          		}
    311          		if(USART_GetFlagStatus(USARTx, USART_FLAG_RXNE) == RESET)		/* 读取数据寄存器为空 */
   \                     ??UartDataReceiveStorage_2: (+1)
   \   0000002A   0x2120             MOVS     R1,#+32
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       USART_GetFlagStatus
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD1E9             BNE.N    ??UartDataReceiveStorage_0
    312          			break;
    313          	}
    314          }
   \   00000036   0xBD70             POP      {R4-R6,PC}       ;; return
    315          
    316          /** 
    317            * 函数功能：
    318            * 参数说明：
    319            * 返回说明：
    320            * 调用范围：
    321            * 完成时间：
    322            * 修改时间：
    323            * 修改原因：
    324            */

   \                                 In section .text, align 2, keep-with-next
    325          void Stm32UsartSendData(USART_TypeDef *USARTx,unsigned char *pucDataAddr,unsigned short usDataLen)
    326          {
   \                     Stm32UsartSendData: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    327          	unsigned short usi = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    328          	for(usi = 0; usi < usDataLen; usi ++)
   \   0000000A   0xE00A             B.N      ??Stm32UsartSendData_0
    329          	{
    330          		while(RESET == USART_GetFlagStatus(USARTx, USART_FLAG_TXE))
   \                     ??Stm32UsartSendData_1: (+1)
   \   0000000C   0x2180             MOVS     R1,#+128
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       USART_GetFlagStatus
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD0F9             BEQ.N    ??Stm32UsartSendData_1
    331          			;
    332          		USART_SendData(USARTx, pucDataAddr[usi]);
   \   00000018   0x5D79             LDRB     R1,[R7, R5]
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       USART_SendData
    333          	}
   \   00000020   0x1C7F             ADDS     R7,R7,#+1
   \                     ??Stm32UsartSendData_0: (+1)
   \   00000022   0xB2BF             UXTH     R7,R7
   \   00000024   0x42B7             CMP      R7,R6
   \   00000026   0xD3F1             BCC.N    ??Stm32UsartSendData_1
    334          }
   \   00000028   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    335          
    336          /** 
    337            * 函数功能：
    338            * 参数说明：
    339            * 返回说明：
    340            * 调用范围：
    341            * 完成时间：
    342            * 修改时间：
    343            * 修改原因：
    344            */

   \                                 In section .text, align 2, keep-with-next
    345          int Module_SendMessage(int len, const void* src)
    346          {
   \                     Module_SendMessage: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    347          	if ((len > 0) && (0!=src))
   \   00000002   0x2801             CMP      R0,#+1
   \   00000004   0xDB08             BLT.N    ??Module_SendMessage_0
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD006             BEQ.N    ??Module_SendMessage_0
    348          	{
    349          		Stm32UsartSendData(USART2, (unsigned char*)src, len & 0xFFFF);
   \   0000000A   0x4602             MOV      R2,R0
   \   0000000C   0xB292             UXTH     R2,R2
   \   0000000E   0x....             LDR.N    R0,??DataTable18_10  ;; 0x40004400
   \   00000010   0x.... 0x....      BL       Stm32UsartSendData
    350          		return 0x01;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xBD02             POP      {R1,PC}
    351          	}
    352          	return 0;
   \                     ??Module_SendMessage_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD02             POP      {R1,PC}          ;; return
    353          }
    354          
    355          
    356          /** 
    357            * 函数功能：
    358            * 参数说明：
    359            * 返回说明：
    360            * 调用范围：
    361            * 完成时间：
    362            * 修改时间：
    363            * 修改原因：
    364            */

   \                                 In section .text, align 2, keep-with-next
    365          PST_PACK_DATA GetStm32UartRecvData(void) 
    366          {
   \                     GetStm32UartRecvData: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    367          	unsigned long ulRecvLen = Stm32UartRecvData((unsigned char *)&g_stRecvData);
    368          	if(ulRecvLen > 0)
   \   00000002   0x....             LDR.N    R4,??DataTable18_11
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0x.... 0x....      BL       Stm32UartRecvData
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD001             BEQ.N    ??GetStm32UartRecvData_0
    369          	{
    370          		return &g_stRecvData;
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0xBD10             POP      {R4,PC}
    371          	}
    372          	return 0;
   \                     ??GetStm32UartRecvData_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    373          }
    374          
    375          /** 
    376            * 函数功能：
    377            * 参数说明：
    378            * 返回说明：
    379            * 调用范围：
    380            * 完成时间：
    381            * 修改时间：
    382            * 修改原因：
    383            */

   \                                 In section .text, align 2, keep-with-next
    384          unsigned long Stm32UartRecvData(unsigned char* lpBuf)
    385          {
   \                     Stm32UartRecvData: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    386              unsigned long ulRingBufUsedLen = RingBufUsed (&g_stUsart1Data.stUartBufRecv);
   \   00000004   0x....             LDR.N    R5,??DataTable18_12
   \   00000006   0x4628             MOV      R0,R5
   \   00000008   0x.... 0x....      BL       RingBufUsed
    387              if(ulRingBufUsedLen >= 0x08)
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD307             BCC.N    ??Stm32UartRecvData_0
    388              {
    389              	
    390          		if(PACK_CMD_DATA_LEN == ulRingBufUsedLen)
   \   00000010   0xD107             BNE.N    ??Stm32UartRecvData_1
    391          		{
    392          			RingBufRead (&g_stUsart1Data.stUartBufRecv, lpBuf, PACK_CMD_DATA_LEN);
   \   00000012   0x2208             MOVS     R2,#+8
   \   00000014   0x4621             MOV      R1,R4
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       RingBufRead
    393          			return PACK_CMD_DATA_LEN;
   \   0000001C   0x2008             MOVS     R0,#+8
   \   0000001E   0xBD32             POP      {R1,R4,R5,PC}
    394          		}
    395          		else
    396          		{
    397          			//RingBufRead (&g_stUsart1Data.stUartBufRecv, lpBuf, ulRingBufUsedLen);
    398          			return ulRingBufUsedLen;
    399          		}
    400          		//debug_printf("%d\r\n", ulRingBufUsedLen);
    401          		//ulRingBufUsedLen = 0;
    402              }
    403              return 0;  
   \                     ??Stm32UartRecvData_0: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \                     ??Stm32UartRecvData_1: (+1)
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    404          }
    405          
    406          /** 
    407            * 函数功能：
    408            * 参数说明：
    409            * 返回说明：
    410            * 调用范围：
    411            * 完成时间：
    412            * 修改时间：
    413            * 修改原因：
    414            */

   \                                 In section .text, align 2, keep-with-next
    415          unsigned long Uart1RecvData(unsigned char* lpBuf)
    416          {
   \                     Uart1RecvData: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    417          	static unsigned long ulBufReadTime = 0;
    418              unsigned long ulRingBufUsedLen = RingBufUsed (&g_stUsart1Data.stUartBufRecv);
   \   00000004   0x....             LDR.N    R5,??DataTable18_8
   \   00000006   0xF505 0x7686      ADD      R6,R5,#+268
   \   0000000A   0x4630             MOV      R0,R6
   \   0000000C   0x.... 0x....      BL       RingBufUsed
   \   00000010   0x0007             MOVS     R7,R0
    419              if(ulRingBufUsedLen >= 0x01)
   \   00000012   0xD00D             BEQ.N    ??Uart1RecvData_0
    420              {
    421              	if(++ulBufReadTime >= 200)
   \   00000014   0x6828             LDR      R0,[R5, #+0]
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0x6028             STR      R0,[R5, #+0]
   \   0000001A   0x28C8             CMP      R0,#+200
   \   0000001C   0xD308             BCC.N    ??Uart1RecvData_0
    422          		{
    423          			RingBufRead(&g_stUsart1Data.stUartBufRecv, lpBuf, ulRingBufUsedLen);
   \   0000001E   0x463A             MOV      R2,R7
   \   00000020   0x4621             MOV      R1,R4
   \   00000022   0x4630             MOV      R0,R6
   \   00000024   0x.... 0x....      BL       RingBufRead
    424          			ulBufReadTime = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x6028             STR      R0,[R5, #+0]
    425          			return ulRingBufUsedLen;
   \   0000002C   0x4638             MOV      R0,R7
   \   0000002E   0xBDF2             POP      {R1,R4-R7,PC}
    426          		}
    427          	}
    428          	return 0;
   \                     ??Uart1RecvData_0: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    429          }
    430          /**
    431            * @brief	等待接收串口数据
    432            * @details	
    433            * @param 	
    434            * @retval 	
    435            */

   \                                 In section .text, align 2, keep-with-next
    436          u8 WaitUartDataReceive(u8* RecvBuffer, u8 ExpectLen)
    437          {
   \                     WaitUartDataReceive: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    438          	u32 ulReceiveLen = 0;									/* 保存的接收数据长度 */
    439          	ulReceiveLen = Uart1RecvData((u8*)RecvBuffer);			/* 接收串口1传过来的数据 */
   \   00000006   0x.... 0x....      BL       Uart1RecvData
   \   0000000A   0x4606             MOV      R6,R0
    440          	if(ulReceiveLen >= ExpectLen)								/* 判断接收到的数据长度 */
   \   0000000C   0x42AE             CMP      R6,R5
   \   0000000E   0xD312             BCC.N    ??WaitUartDataReceive_0
    441          	{
    442          		/* 打印测试 */
    443          		debug_printf("Sensor Recv:");
   \   00000010   0x.... 0x....      ADR.W    R0,?_0
   \   00000014   0x.... 0x....      BL       debug_printf
    444          		for(int i = 0; i < ulReceiveLen; i ++)
   \   00000018   0x2500             MOVS     R5,#+0
   \   0000001A   0xE005             B.N      ??WaitUartDataReceive_1
    445          		{
    446          			debug_printf("%02X ", RecvBuffer[i]);
   \                     ??WaitUartDataReceive_2: (+1)
   \   0000001C   0x5D29             LDRB     R1,[R5, R4]
   \   0000001E   0x.... 0x....      ADR.W    R0,?_1
   \   00000022   0x.... 0x....      BL       debug_printf
    447          		}
   \   00000026   0x1C6D             ADDS     R5,R5,#+1
   \                     ??WaitUartDataReceive_1: (+1)
   \   00000028   0x42B5             CMP      R5,R6
   \   0000002A   0xD3F7             BCC.N    ??WaitUartDataReceive_2
    448          		debug_printf("\r\n");
   \   0000002C   0x....             ADR.N    R0,??DataTable18  ;; 0x0D, 0x0A, 0x00, 0x00
   \   0000002E   0x.... 0x....      BL       debug_printf
    449          		return 0x00;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBD70             POP      {R4-R6,PC}
    450          	}
    451          	return 0x01;
   \                     ??WaitUartDataReceive_0: (+1)
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
    452          }
    453          
    454          
    455          /** 
    456            * 函数功能：
    457            * 参数说明：
    458            * 返回说明：
    459            * 调用范围：
    460            * 完成时间：
    461            * 修改时间：
    462            * 修改原因：
    463            */

   \                                 In section .text, align 2, keep-with-next
    464          unsigned long NBUartRecvData(unsigned char* lpBuf)
    465          {
   \                     NBUartRecvData: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    466          	static unsigned long ulBufReadTime = 0;
    467              unsigned long ulRingBufUsedLen = RingBufUsed (&g_stUsart2Data.stUartBufRecv);
   \   00000004   0x....             LDR.N    R5,??DataTable18_8
   \   00000006   0xF505 0x7608      ADD      R6,R5,#+544
   \   0000000A   0x4630             MOV      R0,R6
   \   0000000C   0x.... 0x....      BL       RingBufUsed
   \   00000010   0x0007             MOVS     R7,R0
    468              if(ulRingBufUsedLen >= 0x01)
   \   00000012   0xD00E             BEQ.N    ??NBUartRecvData_0
    469              {
    470              	if(++ulBufReadTime >= 2000)
   \   00000014   0x6868             LDR      R0,[R5, #+4]
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0x6068             STR      R0,[R5, #+4]
   \   0000001A   0xF5B0 0x6FFA      CMP      R0,#+2000
   \   0000001E   0xD308             BCC.N    ??NBUartRecvData_0
    471          		{
    472          			RingBufRead (&g_stUsart2Data.stUartBufRecv, lpBuf, ulRingBufUsedLen);
   \   00000020   0x463A             MOV      R2,R7
   \   00000022   0x4621             MOV      R1,R4
   \   00000024   0x4630             MOV      R0,R6
   \   00000026   0x.... 0x....      BL       RingBufRead
    473          			ulBufReadTime = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x6068             STR      R0,[R5, #+4]
    474          			return ulRingBufUsedLen;
   \   0000002E   0x4638             MOV      R0,R7
   \   00000030   0xBDF2             POP      {R1,R4-R7,PC}
    475          		}
    476              }
    477              return 0;  
   \                     ??NBUartRecvData_0: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    478          }
    479          
    480          /** 
    481            * 函数功能：
    482            * 参数说明：
    483            * 返回说明：
    484            * 调用范围：
    485            * 完成时间：
    486            * 修改时间：
    487            * 修改原因：
    488            */

   \                                 In section .text, align 2, keep-with-next
    489          unsigned long LORAUartRecvData(unsigned char* lpBuf)
    490          {
   \                     LORAUartRecvData: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    491          	static unsigned long ulBufReadTime = 0;
    492              unsigned long ulRingBufUsedLen = RingBufUsed (&g_stUsart2Data.stUartBufRecv);
   \   00000004   0x....             LDR.N    R5,??DataTable18_8
   \   00000006   0xF505 0x7608      ADD      R6,R5,#+544
   \   0000000A   0x4630             MOV      R0,R6
   \   0000000C   0x.... 0x....      BL       RingBufUsed
   \   00000010   0x0007             MOVS     R7,R0
    493              if(ulRingBufUsedLen >= 0x01)
   \   00000012   0xD00E             BEQ.N    ??LORAUartRecvData_0
    494              {
    495              	if(++ulBufReadTime >= 2000)
   \   00000014   0x68A8             LDR      R0,[R5, #+8]
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0x60A8             STR      R0,[R5, #+8]
   \   0000001A   0xF5B0 0x6FFA      CMP      R0,#+2000
   \   0000001E   0xD308             BCC.N    ??LORAUartRecvData_0
    496          		{
    497          			RingBufRead (&g_stUsart2Data.stUartBufRecv, lpBuf, ulRingBufUsedLen);
   \   00000020   0x463A             MOV      R2,R7
   \   00000022   0x4621             MOV      R1,R4
   \   00000024   0x4630             MOV      R0,R6
   \   00000026   0x.... 0x....      BL       RingBufRead
    498          			ulBufReadTime = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x60A8             STR      R0,[R5, #+8]
    499          			return ulRingBufUsedLen;
   \   0000002E   0x4638             MOV      R0,R7
   \   00000030   0xBDF2             POP      {R1,R4-R7,PC}
    500          		}
    501              }
    502              return 0;  
   \                     ??LORAUartRecvData_0: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    503          }

   \                                 In section .bss, align 4
   \                     ??ulBufReadTime:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
   \   00000008                      DS8 4
   \   0000000C                      DS8 276
   \   00000120                      DS8 276

   \                                 In section .bss, align 4
   \                     g_stRecvData:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
   \                     ??Proiority:
   \   00000000                      DS8 4
    504          /** 
    505            * 函数功能：
    506            * 参数说明：
    507            * 返回说明：
    508            * 调用范围：
    509            * 完成时间：
    510            * 修改时间：
    511            * 修改原因：
    512            */

   \                                 In section .text, align 2, keep-with-next
    513          void BSP_IntHandlerUSART1(void)
    514          {
   \                     BSP_IntHandlerUSART1: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    515          	OS_CPU_SR  cpu_sr;
    516          	OS_ENTER_CRITICAL();                         				/* Tell uC/OS-II that we are starting an ISR          */
   \   00000002   0x.... 0x....      BL       OS_CPU_SR_Save
    517          	OSIntNesting++;
   \   00000006   0x....             LDR.N    R1,??DataTable18_13
   \   00000008   0x780A             LDRB     R2,[R1, #+0]
   \   0000000A   0x1C52             ADDS     R2,R2,#+1
   \   0000000C   0x700A             STRB     R2,[R1, #+0]
    518          	OS_EXIT_CRITICAL();
   \   0000000E   0x.... 0x....      BL       OS_CPU_SR_Restore
    519          	
    520              if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)		/* 接收中断 */
   \   00000012   0x....             LDR.N    R4,??DataTable18_4  ;; 0x40013800
   \   00000014   0xF240 0x5525      MOVW     R5,#+1317
   \   00000018   0x4629             MOV      R1,R5
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       USART_GetITStatus
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD00E             BEQ.N    ??BSP_IntHandlerUSART1_0
    521          	{
    522          		USART_ClearITPendingBit(USART1, USART_IT_RXNE);			/* 清除对应中断位 */
   \   00000024   0x4629             MOV      R1,R5
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       USART_ClearITPendingBit
    523          		UartDataReceiveStorage(USART1, &g_stUsart1Data);
   \   0000002C   0x....             LDR.N    R1,??DataTable18_14
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       UartDataReceiveStorage
    524          		USART_SendData(USART3, USART_ReceiveData(USART1));		/* 回显测试 */
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       USART_ReceiveData
   \   0000003A   0x4601             MOV      R1,R0
   \   0000003C   0x....             LDR.N    R0,??DataTable18_2  ;; 0x40004800
   \   0000003E   0x.... 0x....      BL       USART_SendData
    525          	}
    526          #if 0
    527          	if(USART_GetITStatus(USART1, USART_IT_IDLE) != RESET)		/* 总线空闲中断 */
    528          	{
    529                  USART1->SR;												/* 先读SR，后读DR可以清楚总线空闲位 */
    530                  USART1->DR;	
    531          	}
    532          #endif
    533          	OSIntExit();                                /* Tell uC/OS-II that we are leaving the ISR */
   \                     ??BSP_IntHandlerUSART1_0: (+1)
   \   00000042   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000046   0x.... 0x....      B.W      OSIntExit
    534          }
    535          
    536          /** 
    537            * 函数功能：
    538            * 参数说明：
    539            * 返回说明：
    540            * 调用范围：
    541            * 完成时间：
    542            * 修改时间：
    543            * 修改原因：
    544            */

   \                                 In section .text, align 2, keep-with-next
    545          void BSP_IntHandlerUSART2(void)
    546          {
   \                     BSP_IntHandlerUSART2: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    547          	OS_CPU_SR  cpu_sr;
    548          	
    549              OS_ENTER_CRITICAL();                         				/* Tell uC/OS-II that we are starting an ISR          */
   \   00000002   0x.... 0x....      BL       OS_CPU_SR_Save
    550              OSIntNesting++;
   \   00000006   0x....             LDR.N    R1,??DataTable18_13
   \   00000008   0x780A             LDRB     R2,[R1, #+0]
   \   0000000A   0x1C52             ADDS     R2,R2,#+1
   \   0000000C   0x700A             STRB     R2,[R1, #+0]
    551              OS_EXIT_CRITICAL();
   \   0000000E   0x.... 0x....      BL       OS_CPU_SR_Restore
    552          	
    553              if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)		/* 接收中断 */
   \   00000012   0x....             LDR.N    R4,??DataTable18_10  ;; 0x40004400
   \   00000014   0xF240 0x5525      MOVW     R5,#+1317
   \   00000018   0x4629             MOV      R1,R5
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       USART_GetITStatus
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD007             BEQ.N    ??BSP_IntHandlerUSART2_0
    554          	{
    555          		USART_ClearITPendingBit(USART2, USART_IT_RXNE);			/* 清除对应中断位 */
   \   00000024   0x4629             MOV      R1,R5
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       USART_ClearITPendingBit
    556          		//USART_SendData(USART3, USART_ReceiveData(USART2));		/* 回显测试 */
    557          		UartDataReceiveStorage(USART2, &g_stUsart2Data);	
   \   0000002C   0x....             LDR.N    R1,??DataTable18_15
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       UartDataReceiveStorage
    558          		
    559          	}
    560           
    561          	OSIntExit();                                 /* Tell uC/OS-II that we are leaving the ISR */
   \                     ??BSP_IntHandlerUSART2_0: (+1)
   \   00000034   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000038   0x.... 0x....      B.W      OSIntExit
    562          }
    563          
    564          /** 
    565            * 函数功能：
    566            * 参数说明：
    567            * 返回说明：
    568            * 调用范围：
    569            * 完成时间：
    570            * 修改时间：
    571            * 修改原因：
    572            */

   \                                 In section .text, align 2, keep-with-next
    573          void BSP_IntHandlerUSART3(void)
    574          {
   \                     BSP_IntHandlerUSART3: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    575          	OS_CPU_SR  cpu_sr;
    576              OS_ENTER_CRITICAL();                         /* Tell uC/OS-II that we are starting an ISR          */
   \   00000002   0x.... 0x....      BL       OS_CPU_SR_Save
    577              OSIntNesting++;
   \   00000006   0x....             LDR.N    R1,??DataTable18_13
   \   00000008   0x780A             LDRB     R2,[R1, #+0]
   \   0000000A   0x1C52             ADDS     R2,R2,#+1
   \   0000000C   0x700A             STRB     R2,[R1, #+0]
    578              OS_EXIT_CRITICAL();
   \   0000000E   0x.... 0x....      BL       OS_CPU_SR_Restore
    579          	
    580              if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)		/* 接收中断 */
   \   00000012   0x....             LDR.N    R4,??DataTable18_2  ;; 0x40004800
   \   00000014   0xF240 0x5525      MOVW     R5,#+1317
   \   00000018   0x4629             MOV      R1,R5
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       USART_GetITStatus
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD00A             BEQ.N    ??BSP_IntHandlerUSART3_0
    581          	{
    582          		USART_ClearITPendingBit(USART3, USART_IT_RXNE);			/* 清除对应中断位 */	
   \   00000024   0x4629             MOV      R1,R5
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       USART_ClearITPendingBit
    583          		//UartDataReceiveStorage(&g_stUsartData);
    584          		//USART_SendData(USART3, USART_ReceiveData(USART3));		/* 发送指令回显 */
    585          		USART_SendData(USART1, USART_ReceiveData(USART3));	
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       USART_ReceiveData
   \   00000032   0x4601             MOV      R1,R0
   \   00000034   0x....             LDR.N    R0,??DataTable18_4  ;; 0x40013800
   \   00000036   0x.... 0x....      BL       USART_SendData
    586          		
    587          	}
    588          	OSIntExit();                                 /* Tell uC/OS-II that we are leaving the ISR */     
   \                     ??BSP_IntHandlerUSART3_0: (+1)
   \   0000003A   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   0000003E   0x.... 0x....      B.W      OSIntExit
    589          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x0D 0x0A          DC8      0x0D, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     USART_MODE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x40004800         DC32     0x40004800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x00140010         DC32     0x140010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \   00000000   0x40013800         DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_6:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_7:
   \   00000000   0x........         DC32     ??Proiority

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_8:
   \   00000000   0x........         DC32     ??ulBufReadTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_9:
   \   00000000   0x........         DC32     st_lora_uart_info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_10:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_11:
   \   00000000   0x........         DC32     g_stRecvData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_12:
   \   00000000   0x........         DC32     ??ulBufReadTime+0x10C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_13:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_14:
   \   00000000   0x........         DC32     ??ulBufReadTime+0xC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_15:
   \   00000000   0x........         DC32     ??ulBufReadTime+0x120

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x53 0x65          DC8 "Sensor Recv:"
   \              0x6E 0x73    
   \              0x6F 0x72    
   \              0x20 0x52    
   \              0x65 0x63    
   \              0x76 0x3A    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x25 0x30          DC8 "%02X "
   \              0x32 0x58    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x0D 0x0A          DC8 "\015\012"
   \              0x00         
   \   00000003   0x00               DC8 0
    590          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   BSP_IntHandlerUSART1
         0   -> OSIntExit
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> USART_ClearITPendingBit
        16   -> USART_GetITStatus
        16   -> USART_ReceiveData
        16   -> USART_SendData
        16   -> UartDataReceiveStorage
      16   BSP_IntHandlerUSART2
         0   -> OSIntExit
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> USART_ClearITPendingBit
        16   -> USART_GetITStatus
        16   -> UartDataReceiveStorage
      16   BSP_IntHandlerUSART3
         0   -> OSIntExit
        16   -> OS_CPU_SR_Restore
        16   -> OS_CPU_SR_Save
        16   -> USART_ClearITPendingBit
        16   -> USART_GetITStatus
        16   -> USART_ReceiveData
        16   -> USART_SendData
       8   BSP_UART_Init
         0   -> InitDebugPrintf
         8   -> Stm32UsartConfigInit
         8   -> Stm32UsartQueueInit
       0   GETUSART_MODE
       8   GetStm32UartRecvData
         8   -> Stm32UartRecvData
      24   LORAUartRecvData
        24   -> RingBufRead
        24   -> RingBufUsed
       8   Module_SendMessage
         8   -> Stm32UsartSendData
      24   NBUartRecvData
        24   -> RingBufRead
        24   -> RingBufUsed
       0   SetUSART_MODE
      16   Stm32UartRecvData
        16   -> RingBufRead
        16   -> RingBufUsed
       8   Stm32UsartConfigInit
         8   -> Stm32UsartGPIOConfigInit
         0   -> Stm32UsartIntCfgInit
         8   -> Stm32UsartParamConfigInit
      16   Stm32UsartGPIOConfigInit
        16   -> GPIO_Init
        16   -> GPIO_PinRemapConfig
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> SetUSART_MODE
      16   Stm32UsartIntCfgInit
        16   -> BSP_IntEn
        16   -> BSP_IntVectSet
        16   -> NVIC_Init
        16   -> NVIC_PriorityGroupConfig
        16   -> USART_ClearFlag
        16   -> USART_Cmd
        16   -> USART_ITConfig
      24   Stm32UsartParamConfigInit
        24   -> USART_Init
       8   Stm32UsartQueueInit
         0   -> RingBufInit
         8   -> RingBufInit
      24   Stm32UsartSendData
        24   -> USART_GetFlagStatus
        24   -> USART_SendData
      24   Uart1RecvData
        24   -> RingBufRead
        24   -> RingBufUsed
      16   UartDataReceiveStorage
        16   -> RingBufFree
        16   -> RingBufWriteOne
        16   -> USART_GetFlagStatus
        16   -> USART_ReceiveData
      16   WaitUartDataReceive
        16   -> Uart1RecvData
        16   -> debug_printf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_10
       4  ??DataTable18_11
       4  ??DataTable18_12
       4  ??DataTable18_13
       4  ??DataTable18_14
       4  ??DataTable18_15
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable18_7
       4  ??DataTable18_8
       4  ??DataTable18_9
      16  ?_0
       8  ?_1
       4  ?_2
      74  BSP_IntHandlerUSART1
      60  BSP_IntHandlerUSART2
      66  BSP_IntHandlerUSART3
      38  BSP_UART_Init
       8  GETUSART_MODE
      22  GetStm32UartRecvData
      54  LORAUartRecvData
      28  Module_SendMessage
      54  NBUartRecvData
       4  Proiority
       8  SetUSART_MODE
      36  Stm32UartRecvData
      22  Stm32UsartConfigInit
     208  Stm32UsartGPIOConfigInit
     100  Stm32UsartIntCfgInit
      40  Stm32UsartParamConfigInit
      40  Stm32UsartQueueInit
      42  Stm32UsartSendData
       1  USART_MODE
      52  Uart1RecvData
      56  UartDataReceiveStorage
      58  WaitUartDataReceive
      12  g_stRecvData
      84  st_lora_uart_info
          st_uart3_info
          st_uart1_info
     564  ulBufReadTime
          ulBufReadTime
          ulBufReadTime
          g_stUsart1Data
          g_stUsart2Data

 
   580 bytes in section .bss
    85 bytes in section .data
     4 bytes in section .rodata
 1 154 bytes in section .text
 
 1 154 bytes of CODE  memory
     4 bytes of CONST memory
   665 bytes of DATA  memory

Errors: none
Warnings: 1
